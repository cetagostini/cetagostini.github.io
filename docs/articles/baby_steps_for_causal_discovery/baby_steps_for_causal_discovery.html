<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-02-01">

<title>Baby Steps for Causal Discovery – Marketing Science Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../images/icon/fav.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-9902c68886862a72ad4d9bc7825eafd7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
  .navbar-title {
    font-weight: 700;
    background: linear-gradient(90deg, #383acf 0%, #9c27b0 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }
</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Baby Steps for Causal Discovery – Marketing Science Blog">
<meta property="og:description" content="">
<meta property="og:image" content="https://cetagostini.github.io/cetagostini.github.io/articles/images/baby_steps_for_causal_discovery.png">
<meta property="og:site_name" content="Marketing Science Blog">
<meta name="twitter:title" content="Baby Steps for Causal Discovery – Marketing Science Blog">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="https://cetagostini.github.io/cetagostini.github.io/articles/images/baby_steps_for_causal_discovery.png">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Marketing Science Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../articles.html"> 
<span class="menu-text">Articles</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../talks.html"> 
<span class="menu-text">Talks</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction-to-causal-discovery" id="toc-introduction-to-causal-discovery" class="nav-link active" data-scroll-target="#introduction-to-causal-discovery">Introduction to Causal Discovery</a></li>
  <li><a href="#business-case" id="toc-business-case" class="nav-link" data-scroll-target="#business-case">Business case</a>
  <ul class="collapse">
  <li><a href="#data-generation" id="toc-data-generation" class="nav-link" data-scroll-target="#data-generation">Data generation</a>
  <ul class="collapse">
  <li><a href="#holiday-signal" id="toc-holiday-signal" class="nav-link" data-scroll-target="#holiday-signal">Holiday signal</a></li>
  <li><a href="#generating-inflation" id="toc-generating-inflation" class="nav-link" data-scroll-target="#generating-inflation">Generating inflation</a></li>
  <li><a href="#modeling-marketing-channels" id="toc-modeling-marketing-channels" class="nav-link" data-scroll-target="#modeling-marketing-channels">Modeling Marketing Channels</a></li>
  <li><a href="#target-variable" id="toc-target-variable" class="nav-link" data-scroll-target="#target-variable">Target variable</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#intial-approach" id="toc-intial-approach" class="nav-link" data-scroll-target="#intial-approach">Intial approach</a></li>
  <li><a href="#learning-about-generative-models" id="toc-learning-about-generative-models" class="nav-link" data-scroll-target="#learning-about-generative-models">Learning about generative models</a></li>
  <li><a href="#learning-about-causal-structures" id="toc-learning-about-causal-structures" class="nav-link" data-scroll-target="#learning-about-causal-structures">Learning about causal structures</a></li>
  <li><a href="#lets-check-conditional-independencies" id="toc-lets-check-conditional-independencies" class="nav-link" data-scroll-target="#lets-check-conditional-independencies">Lets check conditional independencies</a></li>
  <li><a href="#identifying-parent-candidates" id="toc-identifying-parent-candidates" class="nav-link" data-scroll-target="#identifying-parent-candidates">Identifying Parent Candidates</a></li>
  <li><a href="#mediation-analysis-for-the-causal-discovery" id="toc-mediation-analysis-for-the-causal-discovery" class="nav-link" data-scroll-target="#mediation-analysis-for-the-causal-discovery">Mediation analysis for the causal discovery</a></li>
  <li><a href="#introduction-to-causal-discovery-1" id="toc-introduction-to-causal-discovery-1" class="nav-link" data-scroll-target="#introduction-to-causal-discovery-1">Introduction to causal discovery</a>
  <ul class="collapse">
  <li><a href="#causal-discovery-algorithms" id="toc-causal-discovery-algorithms" class="nav-link" data-scroll-target="#causal-discovery-algorithms">Causal Discovery Algorithms</a></li>
  </ul></li>
  <li><a href="#how-to-get-right-estimates-if-we-dont-have-all-the-covariates" id="toc-how-to-get-right-estimates-if-we-dont-have-all-the-covariates" class="nav-link" data-scroll-target="#how-to-get-right-estimates-if-we-dont-have-all-the-covariates">How to get right estimates if we don’t have all the covariates?</a></li>
  <li><a href="#conclusions" id="toc-conclusions" class="nav-link" data-scroll-target="#conclusions">Conclusions</a></li>
  <li><a href="#our-causal-discovery-process-in-a-nutshell" id="toc-our-causal-discovery-process-in-a-nutshell" class="nav-link" data-scroll-target="#our-causal-discovery-process-in-a-nutshell">Our causal discovery process in a nutshell</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/cetagostini/cetagostini.github.io/edit/main/articles/baby_steps_for_causal_discovery/baby_steps_for_causal_discovery.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/cetagostini/cetagostini.github.io/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Add the navbar-title class to the navbar brand
    const navbarBrand = document.querySelector('.navbar-brand');
    if (navbarBrand) {
      navbarBrand.classList.add('navbar-title');
    }
  });
</script> 

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Baby Steps for Causal Discovery</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
  <div class="quarto-categories">
    <div class="quarto-category">python</div>
    <div class="quarto-category">experimentation</div>
    <div class="quarto-category">media mix modeling</div>
    <div class="quarto-category">mmm</div>
    <div class="quarto-category">bayesian</div>
    <div class="quarto-category">pymc</div>
    <div class="quarto-category">causal discovery</div>
    <div class="quarto-category">causal learning</div>
    <div class="quarto-category">pydata</div>
    <div class="quarto-category">tallinn</div>
    <div class="quarto-category">estonia</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 1, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction-to-causal-discovery" class="level1">
<h1>Introduction to Causal Discovery</h1>
<p>In this notebook, we’ll dive into how to uncover causal relationships in marketing data, a crucial step for understanding the true impact of various channels on business outcomes. We’ll start by generating synthetic data that mimics real-world marketing scenarios, complete with confounding variables and complex causal structures.</p>
<p>Next, we’ll fit a Bayesian marketing mix model using PyMC-Marketing, check causal directions between variables, and perform mediation analysis to explore indirect effects. Finally, we’ll use structure discovery techniques to infer potential causal graphs. By the end, you’ll have a solid grasp of how to apply these techniques to reveal hidden causal insights in your marketing data.</p>
<div id="e6546878" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">"ignore"</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pymc_marketing.mmm.transformers <span class="im">import</span> geometric_adstock, michaelis_menten</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pymc_marketing.mmm <span class="im">import</span> MMM, GeometricAdstock, MichaelisMentenSaturation</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pymc_marketing.prior <span class="im">import</span> Prior</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> graphviz <span class="im">import</span> Digraph</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pydot</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> arviz <span class="im">as</span> az</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.image <span class="im">as</span> mpimg</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> SVG, display</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> preliz <span class="im">as</span> pz</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pymc <span class="im">as</span> pm</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> io <span class="im">import</span> BytesIO</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> causallearn.graph.Endpoint <span class="im">import</span> Endpoint</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> causallearn.utils.GraphUtils <span class="im">import</span> GraphUtils</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> causallearn.search.ScoreBased.GES <span class="im">import</span> ges</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> causallearn.search.ConstraintBased.PC <span class="im">import</span> pc</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>az.style.use(<span class="st">"arviz-darkgrid"</span>)</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">"figure.figsize"</span>] <span class="op">=</span> [<span class="dv">8</span>, <span class="dv">4</span>]</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">"figure.dpi"</span>] <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">"axes.labelsize"</span>] <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">"xtick.labelsize"</span>] <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">"ytick.labelsize"</span>] <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>plt.rcParams.update({<span class="st">"figure.constrained_layout.use"</span>: <span class="va">True</span>})</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load_ext autoreload</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>autoreload <span class="dv">2</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>config InlineBackend.figure_format <span class="op">=</span> <span class="st">"retina"</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>seed <span class="op">=</span> <span class="bu">sum</span>(<span class="bu">map</span>(<span class="bu">ord</span>, <span class="st">"Estimating effects despite having Confounding Variables"</span>))</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.default_rng(seed)</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(seed)</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(rng)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="business-case" class="level1">
<h1>Business case</h1>
<p>As a company we probably invest in different channels to acquire new customers. Some actions are more direct, like paid ads, and others are more indirect, like offline media marketing, as marketers and scientist, we want to understand the impact of each channel on the target variable (number of new customers).</p>
<p>The following DAG shows a possible causal structure of the problem. Let’s say we have the following variables:</p>
<ul>
<li><span class="math inline">\(x1\)</span>: offline ads, e.g.&nbsp;TV, radio, print, etc.</li>
<li><span class="math inline">\(x2\)</span>: digital ads, e.g.&nbsp;SEM, SEO, social media, etc.</li>
<li><span class="math inline">\(x3\)</span>: internal marketing, e.g.&nbsp;product marketing, internal communication, etc.</li>
<li><span class="math inline">\(y\)</span>: new users</li>
</ul>
<p>Its probable that our offline ads are not directly affecting our new users, but they are affecting our digital ads and internal marketing, users observe a banner of our product and then they search for it online or they are referred by a friend which finally converts using their phone. Independently, some digital ads can impact users which haven’t heard of us before, and those could convert directly.</p>
<p>On top of that, we have some external factors that could affect our new users, e.g.&nbsp;holidays, economic conditions, etc. Things like holidays could affect even more our digital ads, e.g.&nbsp;more users are online shopping, and we are investing more during those days as well.</p>
<p>This creates a complex causal structure, where variables are not fully independent and it is not easy to infer the causal impact of each channel on the target variable.</p>
<div id="ff8c0d1c" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>new_real_dag <span class="op">=</span> Digraph(comment<span class="op">=</span><span class="st">'DAG'</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>new_real_dag.node(<span class="st">'z'</span>, <span class="st">'holiday'</span>, color<span class="op">=</span><span class="st">'grey'</span>, style<span class="op">=</span><span class="st">'dashed'</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>new_real_dag.node(<span class="st">'m'</span>, <span class="st">'inflation'</span>, color<span class="op">=</span><span class="st">'grey'</span>, style<span class="op">=</span><span class="st">'dashed'</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>new_real_dag.node(<span class="st">'x1'</span>, <span class="st">'offline ads'</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>new_real_dag.node(<span class="st">'x2'</span>, <span class="st">'digital ads'</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>new_real_dag.node(<span class="st">'x3'</span>, <span class="st">'internal marketing'</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>new_real_dag.node(<span class="st">'y'</span>, <span class="st">'new users'</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>new_real_dag.edge(<span class="st">'z'</span>, <span class="st">'x2'</span>, style<span class="op">=</span><span class="st">'dashed'</span>)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>new_real_dag.edge(<span class="st">'x1'</span>, <span class="st">'x2'</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>new_real_dag.edge(<span class="st">'x1'</span>, <span class="st">'x3'</span>)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>new_real_dag.edge(<span class="st">'z'</span>, <span class="st">'y'</span>, style<span class="op">=</span><span class="st">'dashed'</span>)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>new_real_dag.edge(<span class="st">'x2'</span>, <span class="st">'y'</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>new_real_dag.edge(<span class="st">'x3'</span>, <span class="st">'y'</span>)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>new_real_dag.edge(<span class="st">'m'</span>, <span class="st">'y'</span>, style<span class="op">=</span><span class="st">'dashed'</span>)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>new_real_dag</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="data-generation" class="level2">
<h2 class="anchored" data-anchor-id="data-generation">Data generation</h2>
<p>Based on the provided DAG, we can create some synthetic data to test how our model performs when we have a complex causal structures. Using the same data, we can test different model compositions and see how could we improve our model to uncover the true causal impact of each channel on the target variable.</p>
<p>We’ll start by setting the date range. Here we’ll use a date range from 2022-01-01 to 2024-11-06, meaning we have almost 3 years of data (1041 days).</p>
<div id="2dbbd0df" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># date range</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>min_date <span class="op">=</span> pd.to_datetime(<span class="st">"2022-01-01"</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>max_date <span class="op">=</span> pd.to_datetime(<span class="st">"2024-11-06"</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>date_range <span class="op">=</span> pd.date_range(start<span class="op">=</span>min_date, end<span class="op">=</span>max_date, freq<span class="op">=</span><span class="st">"D"</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(data<span class="op">=</span>{<span class="st">"date_week"</span>: date_range}).assign(</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    year<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="st">"date_week"</span>].dt.year,</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    month<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="st">"date_week"</span>].dt.month,</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    dayofyear<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="st">"date_week"</span>].dt.dayofyear,</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> df.shape[<span class="dv">0</span>]</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of observations: </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="holiday-signal" class="level3">
<h3 class="anchored" data-anchor-id="holiday-signal">Holiday signal</h3>
<p>Certain holidays, like Christmas, can have a significant impact on consumer behavior before and after the specific date, leading to seasonal spikes in sales. To capture these effects, we introduce a holiday signal based on Gaussian (normal) distributions centered around specific holiday dates.</p>
<p>The function used to model the holiday effect is defined as follows:</p>
<p><span class="math display">\[
H_{t} = \exp\left(-0.5 \left(\frac{\Delta t}{\sigma}\right)^2\right)
\]</span></p>
<p>Where: - <span class="math inline">\(\Delta t\)</span> is the time difference (in days) between the current date and the holiday date. - <span class="math inline">\(\sigma\)</span> is the standard deviation that controls the spread of the effect around the holiday date.</p>
<p>For each holiday, we calculate the holiday signal across the date range and add a <strong>holiday contribution</strong> by scaling the signal with a holiday-specific coefficient. This approach models seasonal holiday spikes using Gaussian functions, which capture the transient increase in market activity around holidays, and their respective decay over time.</p>
<blockquote class="blockquote">
<p>Note: Here we assume a normally distributed signal, nevertheless the signal could be skew or not normal distributed.</p>
</blockquote>
<div id="ad19fb58" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>holiday_dates <span class="op">=</span> [<span class="st">"24-12"</span>, <span class="st">"31-12"</span>, <span class="st">"08-06"</span>, <span class="st">"07-09"</span>]  <span class="co"># List of holidays as month-day strings</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>std_devs <span class="op">=</span> [<span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">3</span>]  <span class="co"># List of standard deviations for each holiday</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>holidays_coefficients <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">6</span>]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize the holiday effect array</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>holiday_signal <span class="op">=</span> np.zeros(<span class="bu">len</span>(date_range))</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>holiday_contributions <span class="op">=</span> np.zeros(<span class="bu">len</span>(date_range))</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate holiday signals</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> holiday, std_dev, holiday_coef <span class="kw">in</span> <span class="bu">zip</span>(</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    holiday_dates, std_devs, holidays_coefficients, strict<span class="op">=</span><span class="va">False</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find all occurrences of the holiday in the date range</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    holiday_occurrences <span class="op">=</span> date_range[date_range.strftime(<span class="st">"</span><span class="sc">%d</span><span class="st">-%m"</span>) <span class="op">==</span> holiday]</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> occurrence <span class="kw">in</span> holiday_occurrences:</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate the time difference in days</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        time_diff <span class="op">=</span> (date_range <span class="op">-</span> occurrence).days</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Generate the Gaussian basis for the holiday</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        _holiday_signal <span class="op">=</span> np.exp(<span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> (time_diff <span class="op">/</span> std_dev) <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add the holiday signal to the holiday effect</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        holiday_signal <span class="op">+=</span> _holiday_signal</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        holiday_contributions <span class="op">+=</span> _holiday_signal <span class="op">*</span> holiday_coef</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"holiday_signal"</span>] <span class="op">=</span> holiday_signal</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"holiday_contributions"</span>] <span class="op">=</span> holiday_contributions</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the holiday effect</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>sns.lineplot(x<span class="op">=</span>date_range, y<span class="op">=</span>holiday_signal, ax<span class="op">=</span>ax)</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(title<span class="op">=</span><span class="st">"Holiday Effect Signal"</span>, xlabel<span class="op">=</span><span class="st">"Date"</span>, ylabel<span class="op">=</span><span class="st">"Signal Intensity"</span>)</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="generating-inflation" class="level3">
<h3 class="anchored" data-anchor-id="generating-inflation">Generating inflation</h3>
<p>Next, we generate the data for <strong>Inflation</strong>. We assume the inflation follows a power-law trend, meaning that growth accelerates over time rather than remaining constant. This can be mathematically defined as:</p>
<p><span class="math display">\[
IN_{t} = (t + \text{baseline})^{\text{exponent}} - 1
\]</span></p>
<p>Where: - <span class="math inline">\(t\)</span>: The time index, representing days since the start of the date range. - <span class="math inline">\(baseline\)</span>: A constant added to <span class="math inline">\(t\)</span> to shift the starting point of the trend. This value affects the initial level of market growth. The starting value of the function will be <span class="math inline">\((baseline)^{exponent} - 1\)</span>, not 0. - <span class="math inline">\(exponent\)</span>: The power to which the time index is raised, determining the rate at which the trend accelerates over time.</p>
<div id="bfd695be" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"inflation"</span>] <span class="op">=</span> (np.linspace(start<span class="op">=</span><span class="fl">0.0</span>, stop<span class="op">=</span><span class="dv">50</span>, num<span class="op">=</span>n) <span class="op">+</span> <span class="dv">10</span>) <span class="op">**</span> (<span class="dv">2</span> <span class="op">/</span> <span class="dv">4</span>) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>sns.lineplot(</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span><span class="st">"date_week"</span>, y<span class="op">=</span><span class="st">"inflation"</span>, color<span class="op">=</span><span class="st">"C2"</span>, label<span class="op">=</span><span class="st">"trend"</span>, data<span class="op">=</span>df, ax<span class="op">=</span>ax</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="st">"upper left"</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(title<span class="op">=</span><span class="st">"Inflation Components"</span>, xlabel<span class="op">=</span><span class="st">"date"</span>, ylabel<span class="op">=</span><span class="va">None</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="modeling-marketing-channels" class="level3">
<h3 class="anchored" data-anchor-id="modeling-marketing-channels">Modeling Marketing Channels</h3>
<p>In this section, we simulate three marketing channels, <span class="math inline">\(x1\)</span>, <span class="math inline">\(x2\)</span>, and <span class="math inline">\(x3\)</span> which represent different advertising channels (e.g., Internal Marketing, Social Marketing, Offline Marketing). Each channel’s behavior is influenced by random variability and confounding effects from seasonal holidays. Here’s how we model each channel mathematically:</p>
<p><strong>Channel <span class="math inline">\(x1\)</span></strong>: As mentioned before, we generate <span class="math inline">\(x1\)</span> which is affected by the holiday signal, we could define it as:</p>
<p><span class="math display">\[
I_{x1_t} = S_{x1_t} + e_{x1}
\]</span></p>
<p><strong>Channel <span class="math inline">\(x2\)</span></strong>: On the other hand, we generate <span class="math inline">\(x2\)</span> which is affected by the holiday signal, and the influence of <span class="math inline">\(x1\)</span>. We could define it as:</p>
<p><span class="math display">\[
I_{x2_t} = S_{x2_t} + H_{t} \times \alpha_{x2} + (I_{x1_t} \times \alpha_{x1_x2}) + e_{x2}
\]</span></p>
<p><strong>Channel <span class="math inline">\(x3\)</span></strong>: For the last variable, we generate <span class="math inline">\(x3\)</span> which is affected by <span class="math inline">\(x1\)</span> only.</p>
<p><span class="math display">\[
I_{x3_t} = S_{x3_t} + (I_{x1_t} \times \alpha_{x1_x3}) + e_{x3}
\]</span></p>
<p>These equations allow us to capture the complex dynamics influencing each marketing channel: - <strong>Holiday Effects</strong> increase channel activity around specific dates, simulating seasonal spikes. - <strong>Cross-channel Influences</strong> introduce interdependencies, modeling how one channel’s success can amplify another’s.</p>
<blockquote class="blockquote">
<p>Note: Here we are assuming an additive impact for the channel interactions.</p>
</blockquote>
<div id="96f92de2" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>x1 <span class="op">=</span> pz.Gamma(mu<span class="op">=</span><span class="dv">1</span>, sigma<span class="op">=</span><span class="dv">3</span>).rvs(n, random_state<span class="op">=</span>rng)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>cofounder_effect_holiday_x1 <span class="op">=</span> <span class="fl">2.5</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>x1_conv <span class="op">=</span> np.convolve(x1, np.ones(<span class="dv">14</span>) <span class="op">/</span> <span class="dv">14</span>, mode<span class="op">=</span><span class="st">"same"</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>noise <span class="op">=</span> pz.Normal(mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="fl">0.1</span>).rvs(<span class="dv">28</span>, random_state<span class="op">=</span>rng)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>x1_conv[:<span class="dv">14</span>] <span class="op">=</span> x1_conv.mean() <span class="op">+</span> noise[:<span class="dv">14</span>]</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>x1_conv[<span class="op">-</span><span class="dv">14</span>:] <span class="op">=</span> x1_conv.mean() <span class="op">+</span> noise[<span class="dv">14</span>:]</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"x1"</span>] <span class="op">=</span> x1_conv</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>x2 <span class="op">=</span> pz.Gamma(mu<span class="op">=</span><span class="dv">2</span>, sigma<span class="op">=</span><span class="dv">2</span>).rvs(n, random_state<span class="op">=</span>rng)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>cofounder_effect_holiday_x2 <span class="op">=</span> <span class="fl">2.2</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>cofounder_effect_x1_x2 <span class="op">=</span> <span class="fl">1.3</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>x2_conv <span class="op">=</span> np.convolve(x2, np.ones(<span class="dv">18</span>) <span class="op">/</span> <span class="dv">12</span>, mode<span class="op">=</span><span class="st">"same"</span>)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>noise <span class="op">=</span> pz.Normal(mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="fl">0.1</span>).rvs(<span class="dv">28</span>, random_state<span class="op">=</span>rng)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>x2_conv[:<span class="dv">14</span>] <span class="op">=</span> x2_conv.mean() <span class="op">+</span> noise[:<span class="dv">14</span>]</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>x2_conv[<span class="op">-</span><span class="dv">14</span>:] <span class="op">=</span> x2_conv.mean() <span class="op">+</span> noise[<span class="dv">14</span>:]</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"x2"</span>] <span class="op">=</span> (</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    x2_conv</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> (holiday_signal <span class="op">*</span> cofounder_effect_holiday_x2)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> (df[<span class="st">"x1"</span>] <span class="op">*</span> cofounder_effect_x1_x2)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>) <span class="co"># digital ads</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>x3 <span class="op">=</span> pz.Gamma(mu<span class="op">=</span><span class="dv">5</span>, sigma<span class="op">=</span><span class="dv">1</span>).rvs(n, random_state<span class="op">=</span>rng)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>cofounder_effect_x1_x3 <span class="op">=</span> <span class="fl">1.5</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>x3_conv <span class="op">=</span> np.convolve(x3, np.ones(<span class="dv">16</span>) <span class="op">/</span> <span class="dv">10</span>, mode<span class="op">=</span><span class="st">"same"</span>)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>noise <span class="op">=</span> pz.Normal(mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="fl">0.1</span>).rvs(<span class="dv">28</span>, random_state<span class="op">=</span>rng)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>x3_conv[:<span class="dv">14</span>] <span class="op">=</span> x3_conv.mean() <span class="op">+</span> noise[:<span class="dv">14</span>]</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>x3_conv[<span class="op">-</span><span class="dv">14</span>:] <span class="op">=</span> x3_conv.mean() <span class="op">+</span> noise[<span class="dv">14</span>:]</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"x3"</span>] <span class="op">=</span> (</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    x3_conv</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> (df[<span class="st">"x1"</span>] <span class="op">*</span> cofounder_effect_x1_x3)</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>) <span class="co"># internal marketing</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We’ll assume all of marketing activities suffer the same transformations Adstock and Saturation. This means, each channel will have individual parameters for the selected transformations, in this case Geometrick adstock and michaelis menten.</p>
<div id="364d84e5" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># apply geometric adstock transformation</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>alpha2: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.4</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>alpha3: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.3</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"x2_adstock"</span>] <span class="op">=</span> (</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    geometric_adstock(x<span class="op">=</span>df[<span class="st">"x2"</span>].to_numpy(), alpha<span class="op">=</span>alpha2, l_max<span class="op">=</span><span class="dv">24</span>, normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    .<span class="bu">eval</span>()</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    .flatten()</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"x3_adstock"</span>] <span class="op">=</span> (</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    geometric_adstock(x<span class="op">=</span>df[<span class="st">"x3"</span>].to_numpy(), alpha<span class="op">=</span>alpha3, l_max<span class="op">=</span><span class="dv">24</span>, normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    .<span class="bu">eval</span>()</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    .flatten()</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="co"># apply saturation transformation</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>lam2: <span class="bu">float</span> <span class="op">=</span> <span class="fl">6.0</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>lam3: <span class="bu">float</span> <span class="op">=</span> <span class="fl">12.0</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>alpha_mm2: <span class="bu">float</span> <span class="op">=</span> <span class="dv">12</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>alpha_mm3: <span class="bu">float</span> <span class="op">=</span> <span class="dv">18</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"x2_adstock_saturated"</span>] <span class="op">=</span> michaelis_menten(</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span>df[<span class="st">"x2_adstock"</span>].to_numpy(), lam<span class="op">=</span>lam2, alpha<span class="op">=</span>alpha_mm2</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"x3_adstock_saturated"</span>] <span class="op">=</span> michaelis_menten(</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span>df[<span class="st">"x3_adstock"</span>].to_numpy(), lam<span class="op">=</span>lam3, alpha<span class="op">=</span>alpha_mm3</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>    nrows<span class="op">=</span><span class="dv">3</span>, ncols<span class="op">=</span><span class="dv">2</span>, sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">False</span>, layout<span class="op">=</span><span class="st">"constrained"</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>sns.lineplot(x<span class="op">=</span><span class="st">"date_week"</span>, y<span class="op">=</span><span class="st">"x2"</span>, data<span class="op">=</span>df, color<span class="op">=</span><span class="st">"C1"</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>sns.lineplot(x<span class="op">=</span><span class="st">"date_week"</span>, y<span class="op">=</span><span class="st">"x3"</span>, data<span class="op">=</span>df, color<span class="op">=</span><span class="st">"C2"</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>sns.lineplot(x<span class="op">=</span><span class="st">"date_week"</span>, y<span class="op">=</span><span class="st">"x2_adstock"</span>, data<span class="op">=</span>df, color<span class="op">=</span><span class="st">"C1"</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>, <span class="dv">0</span>])</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>sns.lineplot(x<span class="op">=</span><span class="st">"date_week"</span>, y<span class="op">=</span><span class="st">"x3_adstock"</span>, data<span class="op">=</span>df, color<span class="op">=</span><span class="st">"C2"</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>, <span class="dv">1</span>])</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>sns.lineplot(x<span class="op">=</span><span class="st">"date_week"</span>, y<span class="op">=</span><span class="st">"x2_adstock_saturated"</span>, data<span class="op">=</span>df, color<span class="op">=</span><span class="st">"C1"</span>, ax<span class="op">=</span>ax[<span class="dv">2</span>, <span class="dv">0</span>])</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>sns.lineplot(x<span class="op">=</span><span class="st">"date_week"</span>, y<span class="op">=</span><span class="st">"x3_adstock_saturated"</span>, data<span class="op">=</span>df, color<span class="op">=</span><span class="st">"C2"</span>, ax<span class="op">=</span>ax[<span class="dv">2</span>, <span class="dv">1</span>])</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>fig.suptitle(<span class="st">"Media Costs Data - Transformed"</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a><span class="co"># adjust size of X axis</span></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>, <span class="dv">0</span>].tick_params(axis<span class="op">=</span><span class="st">"x"</span>, labelsize<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>, <span class="dv">1</span>].tick_params(axis<span class="op">=</span><span class="st">"x"</span>, labelsize<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a><span class="co"># adjust size of x axis labels</span></span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax <span class="kw">in</span> ax.flat:</span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>    ax.tick_params(axis<span class="op">=</span><span class="st">"x"</span>, labelsize<span class="op">=</span><span class="dv">6</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The previous plot shows how the transformations affect each variable, and what would be the true contribution after each transformation.</p>
</section>
<section id="target-variable" class="level3">
<h3 class="anchored" data-anchor-id="target-variable">Target variable</h3>
<p>The target variable is a combination of all variables before. The mathematical formula can be expressed as:</p>
<p><span class="math display">\[
y_{t} = Intercept - f(IN_{t}) + f(H_{t}) + m(I_{x3_t}) + m(I_{x2_t}) + \epsilon
\]</span></p>
<p>Where: - <strong>Intercept</strong>: A baseline level of sales, set to 1.5, representing the base sales level in the absence of other effects. - <strong>Inflation</strong>: Represents the underlying market inflation, with an implicit negative coefficient of 1, adding a steady downward influence. - <strong>Holiday Contributions</strong>: Adds sales spikes around holiday periods, capturing the seasonal increase in consumer demand. - <strong><span class="math inline">\(m(Impressions_{x3_t})\)</span> and <span class="math inline">\(m(Impressions_{x2_t})\)</span></strong>: Represent the <strong>saturated adstock</strong> values for the marketing channels <span class="math inline">\(x3\)</span> and <span class="math inline">\(x2\)</span>. - <strong>Noise <span class="math inline">\(\epsilon\)</span></strong>: A small random error term, drawn from a normal distribution with mean 0 and standard deviation 0.08, to account for unexplained variability in sales.</p>
<div id="4105fab3" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"intercept"</span>] <span class="op">=</span> <span class="fl">1.5</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"epsilon"</span>] <span class="op">=</span> rng.normal(loc<span class="op">=</span><span class="fl">0.0</span>, scale<span class="op">=</span><span class="fl">0.08</span>, size<span class="op">=</span>n)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"y"</span>] <span class="op">=</span> (</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"intercept"</span>]</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> df[<span class="st">"holiday_contributions"</span>]</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> df[<span class="st">"x2_adstock_saturated"</span>]</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> df[<span class="st">"x3_adstock_saturated"</span>]</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> df[<span class="st">"epsilon"</span>]  <span class="co"># Noise</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>) <span class="op">-</span> df[<span class="st">"inflation"</span>]</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>sns.lineplot(x<span class="op">=</span><span class="st">"date_week"</span>, y<span class="op">=</span><span class="st">"y"</span>, color<span class="op">=</span><span class="st">"black"</span>, data<span class="op">=</span>df, ax<span class="op">=</span>ax)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(title<span class="op">=</span><span class="st">"Sales (Target Variable)"</span>, xlabel<span class="op">=</span><span class="st">"date"</span>, ylabel<span class="op">=</span><span class="st">"y (thousands)"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can scale the full dataset and we’ll have finally something very similar to reality.</p>
<div id="3cf7958e" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># scale df by abs max per column</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"date"</span>] <span class="op">=</span> pd.to_datetime(df[<span class="st">"date_week"</span>])</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>scaled_df <span class="op">=</span> df.copy()</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> scaled_df.columns:</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="op">!=</span> <span class="st">'date'</span> <span class="kw">and</span> col <span class="op">!=</span> <span class="st">'date_week'</span>:</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        scaled_df[col] <span class="op">=</span> scaled_df[col] <span class="op">/</span> scaled_df[col].<span class="bu">abs</span>().<span class="bu">max</span>()</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>scaled_df[[<span class="st">"date"</span>, <span class="st">"x1"</span>, <span class="st">"x2"</span>, <span class="st">"x3"</span>, <span class="st">"y"</span>]].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
</section>
<section id="intial-approach" class="level1">
<h1>Intial approach</h1>
<p>If we have a dataset like the one we just created, we can try to fit a model with the following to find the causal impact of each channel on the target variable. For the example, we’ll use a simple model from Pymc-Marketing for this purpose.</p>
<p>Let’s see what happens if we fit a model with all what we have without any knowledge of the causal structure.</p>
<div id="8bb03ef0" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>scaled_df[[<span class="st">"date"</span>, <span class="st">"x1"</span>, <span class="st">"x2"</span>, <span class="st">"x3"</span>, <span class="st">"y"</span>]].head()</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>model_config <span class="op">=</span> {</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"intercept"</span>: Prior(<span class="st">"Gamma"</span>, mu<span class="op">=</span><span class="dv">1</span>, sigma<span class="op">=</span><span class="dv">1</span>),</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"likelihood"</span>: Prior(<span class="st">"Normal"</span>, sigma<span class="op">=</span>Prior(<span class="st">"Normal"</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="fl">.5</span>)),</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>fit_kwargs <span class="op">=</span> <span class="bu">dict</span>(nuts_sampler<span class="op">=</span><span class="st">"numpyro"</span>, random_seed<span class="op">=</span>rng,)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> df.drop(columns<span class="op">=</span>[<span class="st">"y"</span>])</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> df[<span class="st">"y"</span>]</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>mmm <span class="op">=</span> MMM(</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    date_column<span class="op">=</span><span class="st">"date"</span>,</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    channel_columns<span class="op">=</span>[</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span class="st">"x1"</span>,</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        <span class="st">"x2"</span>,</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        <span class="st">"x3"</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    control_columns<span class="op">=</span>[</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        <span class="st">"holiday_signal"</span>,</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>        <span class="st">"inflation"</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    adstock<span class="op">=</span>GeometricAdstock(l_max<span class="op">=</span><span class="dv">24</span>),</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    saturation<span class="op">=</span>MichaelisMentenSaturation(),</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>mmm.fit(X, y, <span class="op">**</span>fit_kwargs)</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>mmm.sample_posterior_predictive(</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>X,</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>    extend_idata<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>    combined<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>    random_seed<span class="op">=</span>rng,</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>How the recover contributions look like, If we compare to the real contributions?</p>
<div id="f23a8c06" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>initial_model_recover_effect <span class="op">=</span> (</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    az.hdi(mmm.fit_result[<span class="st">"channel_contributions"</span>], hdi_prob<span class="op">=</span><span class="fl">0.95</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> mmm.target_transformer[<span class="st">"scaler"</span>].scale_.item()</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>initial_model_mean_effect <span class="op">=</span> (</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    mmm.fit_result.channel_contributions.mean(dim<span class="op">=</span>[<span class="st">"chain"</span>, <span class="st">"draw"</span>])</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> mmm.target_transformer[<span class="st">"scaler"</span>].scale_.item()</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">1</span>, sharex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="co"># x2 -&gt; online</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    date_range,</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    initial_model_mean_effect.sel(channel<span class="op">=</span><span class="st">"x2"</span>),</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="st">"Mean Recover x2 Effect"</span>,</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    linestyle<span class="op">=</span><span class="st">"--"</span>,</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span><span class="st">"orange"</span>,</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].fill_between(</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    date_range,</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    initial_model_recover_effect.channel_contributions.isel(hdi<span class="op">=</span><span class="dv">0</span>).sel(channel<span class="op">=</span><span class="st">"x2"</span>),</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    initial_model_recover_effect.channel_contributions.isel(hdi<span class="op">=</span><span class="dv">1</span>).sel(channel<span class="op">=</span><span class="st">"x2"</span>),</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    alpha<span class="op">=</span><span class="fl">0.2</span>,</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="st">"95% Credible Interval"</span>,</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span><span class="st">"orange"</span>,</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    date_range, df[<span class="st">"x2_adstock_saturated"</span>], label<span class="op">=</span><span class="st">"Real x2 Effect"</span>, color<span class="op">=</span><span class="st">"black"</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a><span class="co"># x3 -&gt; internal</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>    date_range,</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>    initial_model_mean_effect.sel(channel<span class="op">=</span><span class="st">"x3"</span>),</span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="st">"Mean Recover x3 Effect"</span>,</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>    linestyle<span class="op">=</span><span class="st">"--"</span>,</span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span><span class="st">"green"</span>,</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].fill_between(</span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>    date_range,</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>    initial_model_recover_effect.channel_contributions.isel(hdi<span class="op">=</span><span class="dv">0</span>).sel(channel<span class="op">=</span><span class="st">"x3"</span>),</span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>    initial_model_recover_effect.channel_contributions.isel(hdi<span class="op">=</span><span class="dv">1</span>).sel(channel<span class="op">=</span><span class="st">"x3"</span>),</span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>    alpha<span class="op">=</span><span class="fl">0.2</span>,</span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="st">"95% Credible Interval"</span>,</span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span><span class="st">"green"</span>,</span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(</span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a>    date_range, df[<span class="st">"x3_adstock_saturated"</span>], label<span class="op">=</span><span class="st">"Real x3 Effect"</span>, color<span class="op">=</span><span class="st">"black"</span></span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a><span class="co"># formatting</span></span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].legend()</span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].legend()</span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].<span class="bu">set</span>(xlabel<span class="op">=</span><span class="st">"date"</span>)</span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a>fig.suptitle(<span class="st">"Media Contribution Recovery"</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>As anticipated, the model fails to accurately reflect the true contributions, resulting in estimates that significantly deviate from the actual values. How can this occur, and why is this happening?</p>
<p>The explanation is straightforward: by neglecting any causal structure, we inadvertently impose one onto the data. The issue lies in our assumption of the simplest causal framework, which rarely aligns with real-world complexity.</p>
<p>What kind of causal structure are we implicitly assuming when we fit the model?</p>
<div id="2f2cb39c" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize a directed graph</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph <span class="op">=</span> Digraph()</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Add nodes</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.node(<span class="st">"X1"</span>, <span class="st">"Offline"</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.node(<span class="st">"X2"</span>, <span class="st">"Online"</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.node(<span class="st">"X3"</span>, <span class="st">"Internal"</span>)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.node(<span class="st">"E"</span>, <span class="st">"Exogenous variables"</span>, style<span class="op">=</span><span class="st">"dashed"</span>)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.node(<span class="st">"T"</span>, <span class="st">"Target"</span>)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.edge(<span class="st">"E"</span>, <span class="st">"T"</span>, style<span class="op">=</span><span class="st">"dashed"</span>)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.edge(<span class="st">"X1"</span>, <span class="st">"T"</span>)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.edge(<span class="st">"X2"</span>, <span class="st">"T"</span>)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.edge(<span class="st">"X3"</span>, <span class="st">"T"</span>)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Render the graph to SVG and display it inline</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>svg_str <span class="op">=</span> naive_causal_mmm_graph.pipe(<span class="bu">format</span><span class="op">=</span><span class="st">"svg"</span>)</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>display(SVG(svg_str))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The DAG above represents the causal structure that we are implicitly assuming when we fit the model. Here all variables are independent of each other, and those impact directly the target variable.</p>
<p>During the model development, we established a specific structure and flow for our data. We concluded that the impacts of our channels operate independently of each other. Moreover, we determined that if any component of our ecosystem is missing, its influence will be accounted for by the baseline term due to this equation. As you can see, even by adopting this basic model, we are making significant assumptions.</p>
<p>On one hand, you are assuming that the impact is not linear by applying these transformations, and you are suggesting that the impact is positive and that there may be a maximum delay of a certain number of days.</p>
<p>You’ve even defined the direction of your relationships. By defining these relationships and assuming no direct causal connections between our variables, we can conclude that, if the nature of their relationship is accurately represented by the provided equation, then by controlling the relevant channels, we could uncover their true effects.</p>
<p>This leads us to which causal DAG we assume is correct, based on our previous assumptions. If you recognize this process, congratulations! You’ve created a generative model or Structural Causal Model, with a Structural Causal Equation, using PyMC-marketing.</p>
<p>However, this Causal DAG does not depict the true Causal DAG. Since our PyMC model is structural and causal, we must ask: <em>What happens if I create a model with a different causal structure than the real one?</em></p>
<p>The answer is what we observed above, the model will not be able to recover the true causal structure.</p>
</section>
<section id="learning-about-generative-models" class="level1">
<h1>Learning about generative models</h1>
<p>Generative models are frameworks that describe how data could be produced in the real world. They outline a process by defining probability distributions for each component, simulating the creation of data from underlying random variables. This approach captures uncertainty and variability, providing a complete picture of the data generation mechanism.</p>
<p>In PyMC, this concept is at the core of every model. PyMC lets you explicitly define priors, likelihoods, and the structure of your data generation process. Even simple models built in PyMC carry an inherent generative assumption, making them flexible and robust in representing how data might naturally arise.</p>
<p>This means that each possible graph with N number of variables can be a specific model. How many models could we specify if we have 5 variables for one target?</p>
<div id="27b106e9" class="cell" data-execution_count="13">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> lru_cache</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="at">@lru_cache</span>(maxsize<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dag_with_exactly_s_sources(n: <span class="bu">int</span>, s: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Count DAGs with exactly s source nodes.</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Uses formula: S(n,s) = C(n,s) * sum[(-1)^j * C(n-s,j) * 2^((m-j)(m-j-1)/2) *</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co">    (2^(m-j)-1)^s] where m=n-s and j=0..m. When n=s, S(n,n)=1.</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="co">    n : int</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="co">        Total number of labeled nodes</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="co">    s : int</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="co">        Number of source nodes</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a><span class="co">    int</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="co">        Number of possible DAGs</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> s:</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> n <span class="op">-</span> s</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>        term <span class="op">=</span> (</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>            (<span class="op">-</span><span class="dv">1</span>) <span class="op">**</span> j</span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span> math.comb(m, j)</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span> <span class="dv">2</span> <span class="op">**</span> (((m <span class="op">-</span> j) <span class="op">*</span> (m <span class="op">-</span> j <span class="op">-</span> <span class="dv">1</span>)) <span class="op">//</span> <span class="dv">2</span>)</span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span> (<span class="dv">2</span> <span class="op">**</span> (m <span class="op">-</span> j) <span class="op">-</span> <span class="dv">1</span>) <span class="op">**</span> s</span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> term</span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> math.comb(n, s) <span class="op">*</span> total</span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_valid_final_graphs_with_parents(num_regressors: <span class="bu">int</span>, num_parents: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Count valid final graphs with parent node restrictions.</span></span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a><span class="co">    The counting process has two main steps:</span></span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a><span class="co">    1. Build a DAG among regressors where parents have no incoming edges:</span></span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a><span class="co">       - For non-parents (Q = num_regressors - num_parents), count DAGs with given sinks</span></span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a><span class="co">       - Parents can only have edges to non-parents (Q options each)</span></span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a><span class="co">       - Non-sink parents must have ≥1 outgoing edge (2^Q - 1 ways)</span></span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a><span class="co">       - Sink parents have no edges (1 way)</span></span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a><span class="co">    2. Add edges from regressors to target:</span></span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a><span class="co">       - Sink regressors must connect to target</span></span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a><span class="co">       - Non-sink regressors optionally connect</span></span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a><span class="co">       - Yields factor 2^(num_regressors - total_sinks)</span></span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a><span class="co">    The total count formula is:</span></span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a><span class="co">    sum_{s_p=0}^P sum_{s_q=1}^Q [binom(P,s_p) * (2^Q-1)^(P-s_p) *</span></span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a><span class="co">    (DAGs_Q_s_q) * 2^((P+Q)-(s_p+s_q))]</span></span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true" tabindex="-1"></a><span class="co">    where P = num_parents, Q = num_regressors - num_parents</span></span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true" tabindex="-1"></a><span class="co">    When Q = 0 (all regressors are parents), the final graph is unique.</span></span>
<span id="cb13-61"><a href="#cb13-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-62"><a href="#cb13-62" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb13-63"><a href="#cb13-63" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb13-64"><a href="#cb13-64" aria-hidden="true" tabindex="-1"></a><span class="co">    num_regressors : int</span></span>
<span id="cb13-65"><a href="#cb13-65" aria-hidden="true" tabindex="-1"></a><span class="co">        Total number of regressor nodes in the graph</span></span>
<span id="cb13-66"><a href="#cb13-66" aria-hidden="true" tabindex="-1"></a><span class="co">    num_parents : int</span></span>
<span id="cb13-67"><a href="#cb13-67" aria-hidden="true" tabindex="-1"></a><span class="co">        Number of designated parent nodes that cannot have incoming edges</span></span>
<span id="cb13-68"><a href="#cb13-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-69"><a href="#cb13-69" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb13-70"><a href="#cb13-70" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb13-71"><a href="#cb13-71" aria-hidden="true" tabindex="-1"></a><span class="co">    int</span></span>
<span id="cb13-72"><a href="#cb13-72" aria-hidden="true" tabindex="-1"></a><span class="co">        Total count of valid final graph configurations</span></span>
<span id="cb13-73"><a href="#cb13-73" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb13-74"><a href="#cb13-74" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> num_parents</span>
<span id="cb13-75"><a href="#cb13-75" aria-hidden="true" tabindex="-1"></a>    Q <span class="op">=</span> num_regressors <span class="op">-</span> num_parents  <span class="co"># non-parents</span></span>
<span id="cb13-76"><a href="#cb13-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> Q <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb13-77"><a href="#cb13-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"num_parents cannot exceed num_regressors"</span>)</span>
<span id="cb13-78"><a href="#cb13-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-79"><a href="#cb13-79" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Case where all regressors are parents: no DAG edges are allowed;</span></span>
<span id="cb13-80"><a href="#cb13-80" aria-hidden="true" tabindex="-1"></a>    <span class="co"># every node is isolated (and hence a sink),</span></span>
<span id="cb13-81"><a href="#cb13-81" aria-hidden="true" tabindex="-1"></a>    <span class="co"># so the regressor-to-target assignment is forced.</span></span>
<span id="cb13-82"><a href="#cb13-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> Q <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb13-83"><a href="#cb13-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb13-84"><a href="#cb13-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-85"><a href="#cb13-85" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-86"><a href="#cb13-86" aria-hidden="true" tabindex="-1"></a>    <span class="co"># s_p: number of parents that end up as sinks</span></span>
<span id="cb13-87"><a href="#cb13-87" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (i.e. with no outgoing edge to any non-parent)</span></span>
<span id="cb13-88"><a href="#cb13-88" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s_p <span class="kw">in</span> <span class="bu">range</span>(P <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb13-89"><a href="#cb13-89" aria-hidden="true" tabindex="-1"></a>        <span class="co"># For each parent:</span></span>
<span id="cb13-90"><a href="#cb13-90" aria-hidden="true" tabindex="-1"></a>        <span class="co">#   - If not a sink: choose at least one outgoing edge</span></span>
<span id="cb13-91"><a href="#cb13-91" aria-hidden="true" tabindex="-1"></a>        <span class="co">#     among Q non-parents: (2^Q - 1) ways.</span></span>
<span id="cb13-92"><a href="#cb13-92" aria-hidden="true" tabindex="-1"></a>        <span class="co">#   - If a sink: only 1 way (choose no outgoing edge).</span></span>
<span id="cb13-93"><a href="#cb13-93" aria-hidden="true" tabindex="-1"></a>        parent_config <span class="op">=</span> math.comb(P, s_p) <span class="op">*</span> ((<span class="dv">2</span><span class="op">**</span>Q <span class="op">-</span> <span class="dv">1</span>) <span class="op">**</span> (P <span class="op">-</span> s_p))</span>
<span id="cb13-94"><a href="#cb13-94" aria-hidden="true" tabindex="-1"></a>        <span class="co"># s_q: number of sinks among non-parents in the DAG on Q nodes.</span></span>
<span id="cb13-95"><a href="#cb13-95" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Note: Every DAG on at least one node has at least one sink.</span></span>
<span id="cb13-96"><a href="#cb13-96" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> s_q <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, Q <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb13-97"><a href="#cb13-97" aria-hidden="true" tabindex="-1"></a>            nonparent_count <span class="op">=</span> dag_with_exactly_s_sources(Q, s_q)</span>
<span id="cb13-98"><a href="#cb13-98" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Total sinks in the regressor</span></span>
<span id="cb13-99"><a href="#cb13-99" aria-hidden="true" tabindex="-1"></a>            <span class="co"># DAG is s_p (from parents) plus s_q (from non-parents)</span></span>
<span id="cb13-100"><a href="#cb13-100" aria-hidden="true" tabindex="-1"></a>            total_sinks <span class="op">=</span> s_p <span class="op">+</span> s_q</span>
<span id="cb13-101"><a href="#cb13-101" aria-hidden="true" tabindex="-1"></a>            <span class="co"># For each regressor that is not a sink,</span></span>
<span id="cb13-102"><a href="#cb13-102" aria-hidden="true" tabindex="-1"></a>            <span class="co"># the regressor-to-target edge is optional.</span></span>
<span id="cb13-103"><a href="#cb13-103" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Thus, a factor of 2^( (P+Q) - total_sinks ).</span></span>
<span id="cb13-104"><a href="#cb13-104" aria-hidden="true" tabindex="-1"></a>            assignment_factor <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> ((P <span class="op">+</span> Q) <span class="op">-</span> total_sinks)</span>
<span id="cb13-105"><a href="#cb13-105" aria-hidden="true" tabindex="-1"></a>            total <span class="op">+=</span> parent_config <span class="op">*</span> nonparent_count <span class="op">*</span> assignment_factor</span>
<span id="cb13-106"><a href="#cb13-106" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total</span>
<span id="cb13-107"><a href="#cb13-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-108"><a href="#cb13-108" aria-hidden="true" tabindex="-1"></a>possible_dags <span class="op">=</span> count_valid_final_graphs_with_parents(num_regressors<span class="op">=</span><span class="dv">5</span>, num_parents<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb13-109"><a href="#cb13-109" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of possible DAGs with two parents (Graphical/Generative Model): </span><span class="sc">{</span>possible_dags<span class="sc">:,}</span><span class="ss">"</span>)</span>
<span id="cb13-110"><a href="#cb13-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-111"><a href="#cb13-111" aria-hidden="true" tabindex="-1"></a>possible_dags <span class="op">=</span> count_valid_final_graphs_with_parents(num_regressors<span class="op">=</span><span class="dv">5</span>, num_parents<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb13-112"><a href="#cb13-112" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of possible DAGs with one parent (Graphical/Generative Model): </span><span class="sc">{</span>possible_dags<span class="sc">:,}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The number of possible models we can generate with two out of five variables as parents is around 12,000, while having just one parent increases that number to approximately 52,000. Interestingly, removing a single parent node triples the potential models we can create, effectively multiplying the number of possible scenarios.</p>
<p>This sheds light on the challenges posed by large models:<br>
a) As the number of variables increases, the exponential growth in potential relationships becomes overwhelming, making it difficult to pinpoint our actual situation.<br>
b) With more variables, the likelihood of mistakenly controlling for the wrong variables also increases.</p>
<p>This latter point aligns with our earlier observation: if we control for inappropriate variables, the model fails to recover the true causal structure.</p>
<p>So, why is it problematic to control for certain variables? Every variable should add more explanatory power, no?. Let’s start learning about structures to understand.</p>
</section>
<section id="learning-about-causal-structures" class="level1">
<h1>Learning about causal structures</h1>
<p><strong>Forks</strong>: A fork is a causal structure where a single variable acts as a common cause for two or more other variables. This common cause transmits its influence to all its direct descendants. The existence of a fork creates confounding, making the relationship between the descendant variables appear related. Controlling for the common cause can effectively block the backdoor paths created by this structure.</p>
<p><strong>Chains</strong>: A chain represents a sequential causal pathway where one variable influences another, which in turn affects a third variable. This structure highlights the mediation process through which causal effects are transmitted. The intermediate variable acts as a mediator, carrying the influence from the initial cause to the final outcome. Analyzing chains helps distinguish between direct and indirect effects in a causal system. Controlling for the mediator inappropriately may block parts of the causal effect that are of interest.</p>
<p><strong>Colliders</strong>: A collider is a variable that is the common effect of two or more causal factors. It sits at the convergence of different causal paths and can introduce spurious associations when conditioned upon. Controlling for a collider can inadvertently open up non-causal, backdoor paths, leading to biased estimates. This phenomenon, known as collider bias, distorts the true relationships among the causal variables. Avoiding conditioning on colliders is crucial for maintaining the validity of causal models.</p>
<div id="5455f752" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create figure with 3 subplots</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2, ax3) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>,)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create collider DAG</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>collider <span class="op">=</span> Digraph()</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>collider.attr(rankdir<span class="op">=</span><span class="st">'TB'</span>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>collider.node(<span class="st">'A'</span>, <span class="st">'A'</span>)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>collider.node(<span class="st">'B'</span>, <span class="st">'B'</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>collider.node(<span class="st">'C'</span>, <span class="st">'C'</span>)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>collider.edge(<span class="st">'A'</span>, <span class="st">'C'</span>)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>collider.edge(<span class="st">'B'</span>, <span class="st">'C'</span>)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">'Collider (A→C←B)'</span>)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>ax1.imshow(Image.<span class="bu">open</span>(BytesIO(collider.pipe(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>))))</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>ax1.axis(<span class="st">'off'</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Create fork DAG</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>fork <span class="op">=</span> Digraph()</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>fork.attr(rankdir<span class="op">=</span><span class="st">'TB'</span>)</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>fork.node(<span class="st">'A'</span>, <span class="st">'A'</span>)</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>fork.node(<span class="st">'B'</span>, <span class="st">'B'</span>)</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>fork.node(<span class="st">'C'</span>, <span class="st">'C'</span>)</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>fork.edge(<span class="st">'A'</span>, <span class="st">'B'</span>)</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>fork.edge(<span class="st">'A'</span>, <span class="st">'C'</span>)</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">'Fork (B←A→C)'</span>)</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>ax2.imshow(Image.<span class="bu">open</span>(BytesIO(fork.pipe(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>))))</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>ax2.axis(<span class="st">'off'</span>)</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Create chain DAG</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>chain <span class="op">=</span> Digraph()</span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>chain.attr(rankdir<span class="op">=</span><span class="st">'TB'</span>)</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>chain.node(<span class="st">'A'</span>, <span class="st">'A'</span>)</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>chain.node(<span class="st">'B'</span>, <span class="st">'B'</span>)</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>chain.node(<span class="st">'C'</span>, <span class="st">'C'</span>)</span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>chain.edge(<span class="st">'A'</span>, <span class="st">'B'</span>)</span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>chain.edge(<span class="st">'B'</span>, <span class="st">'C'</span>)</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>ax3.set_title(<span class="st">'Chain (A→B→C)'</span>)</span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>ax3.imshow(Image.<span class="bu">open</span>(BytesIO(chain.pipe(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>))))</span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>ax3.axis(<span class="st">'off'</span>)</span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Causal structures play a crucial role in various causal inference methods, serving as the foundation for their functionality. For instance, chain structures are key to methods like instrumental variables (IV). In IV analysis, this chain structure comes into play by introducing an instrument—a variable that impacts the exposure but does not directly affect the outcome, except through that exposure. This approach helps break the confounding path, allowing us to isolate the exogenous variation in treatment.</p>
<p>As a result, it enables a consistent estimation of causal effects, even when we encounter endogeneity. Therefore, grasping chain structures is essential, as it not only supports the rationale behind IV methods but also underscores the significance of identifying valid instruments.</p>
<p>If you’re particularly interested in learning more about IVs, I recommend checking out a post by Anton Bugaev or heading to the fifth floor if you’re at Bolt.</p>
<p>Ultimately, each of these causal structures exhibits different observational behaviors. This means that based on the observational data, we can deduce which structure is present, and consecuently determinate whats the right variable set to control.</p>
<p>One thing to understand what to control is find out the parent nodes to avoid to control by mediators, we could identify this understanding the conditional dependencies.</p>
</section>
<section id="lets-check-conditional-independencies" class="level1">
<h1>Lets check conditional independencies</h1>
<p>Conditional independence is a core concept in probability theory and statistics where two variables are independent of each other once a third variable is held constant. This means that, given the value of the conditioning variable, the two variables do not provide additional information about one another. In causal discovery, conditional independencies are crucial because they reveal the underlying structure of causal relationships in a model or a directed acyclic graph (DAG). By identifying these independencies, we can determine how variables are related to each other, or not.</p>
<p>Bayesian regression models allow us to estimate the conditional expectation of an outcome given a set of predictors, effectively uncovering the underlying conditional probabilities. In a bayesian linear regression, for example, we estimate <span class="math inline">\(E(Y \mid X) = \beta_0 + \beta_1X_1 + \ldots + \beta_kX_k\)</span>, which represents the average outcome <span class="math inline">\(Y\)</span> when the predictors <span class="math inline">\(X_1, \dots, X_k\)</span> are held at specific values.</p>
<p>Let’s define a function to build and sample a linear model from a formula.</p>
<div id="1986ab8f" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_and_sample_model(data: pd.DataFrame, formula: <span class="bu">str</span>):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Build and sample a linear model from a formula.</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Parse the formula to get target and channels</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    target, channels <span class="op">=</span> formula.split(<span class="st">'~'</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    target <span class="op">=</span> target.strip()</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    channels <span class="op">=</span> [ch.strip() <span class="cf">for</span> ch <span class="kw">in</span> channels.split(<span class="st">'+'</span>) <span class="cf">if</span> ch.strip() <span class="op">!=</span> <span class="st">"1"</span>]</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Define coordinates</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    coordinates <span class="op">=</span> {<span class="st">"date"</span>: data.date.unique()}</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> channels:  <span class="co"># If there are regressors, include them in coordinates</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        coordinates[<span class="st">"channel"</span>] <span class="op">=</span> channels</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Filter the dataset based on the formula</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> pm.Model(coords<span class="op">=</span>coordinates) <span class="im">as</span> linear_model:</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Load Data in Model</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        target_data <span class="op">=</span> pm.Data(<span class="st">"target"</span>, data[target].values, dims<span class="op">=</span><span class="st">"date"</span>)</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Constant or intercept</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>        intercept <span class="op">=</span> pm.Gamma(<span class="st">"intercept"</span>, mu<span class="op">=</span><span class="dv">3</span>, sigma<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>        mu_var <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> channels:  <span class="co"># If there are regressors, include them</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>            regressors <span class="op">=</span> pm.Data(<span class="st">"regressors"</span>, data[channels].values, dims<span class="op">=</span>(<span class="st">"date"</span>, <span class="st">"channel"</span>))</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>            gamma <span class="op">=</span> pm.Normal(<span class="st">"gamma"</span>, mu<span class="op">=</span><span class="dv">3</span>, sigma<span class="op">=</span><span class="dv">2</span>, dims<span class="op">=</span><span class="st">"channel"</span>)</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>            mu_var <span class="op">+=</span> (regressors <span class="op">*</span> gamma).<span class="bu">sum</span>(axis<span class="op">=-</span><span class="dv">1</span>) <span class="op">+</span> intercept</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>            mu_var <span class="op">+=</span> intercept</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Likelihood</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>        pm.Normal(<span class="st">"likelihood"</span>, mu<span class="op">=</span>mu_var, sigma<span class="op">=</span>pm.Gamma(<span class="st">"sigma"</span>, mu<span class="op">=</span><span class="dv">2</span>, sigma<span class="op">=</span><span class="dv">3</span>), observed<span class="op">=</span>target_data, dims<span class="op">=</span><span class="st">"date"</span>)</span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sample</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>        idata <span class="op">=</span> pm.sample_prior_predictive(random_seed<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>        idata.extend(</span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a>            pm.sample(tune<span class="op">=</span><span class="dv">1000</span>, draws<span class="op">=</span><span class="dv">500</span>, chains<span class="op">=</span><span class="dv">4</span>, random_seed<span class="op">=</span><span class="dv">42</span>, target_accept<span class="op">=</span><span class="fl">0.9</span>, nuts_sampler<span class="op">=</span><span class="st">"numpyro"</span>, progressbar<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>        pm.compute_log_likelihood(idata, progressbar<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>        idata.extend(</span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>            pm.sample_posterior_predictive(idata, random_seed<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (idata, linear_model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Now, let’s build and sample the models for each variable.</p>
<div id="931404b9" class="cell" data-execution_count="16">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>idata1, model1 <span class="op">=</span> build_and_sample_model(</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    scaled_df,</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"x1 ~ 1"</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>idata2, model2 <span class="op">=</span> build_and_sample_model(</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    scaled_df,</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"x1 ~ x2 + 1"</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>idata3, model3 <span class="op">=</span> build_and_sample_model(</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    scaled_df,</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">"x1 ~ x3 + 1"</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>idata4, model4 <span class="op">=</span> build_and_sample_model(</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    scaled_df,</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    <span class="st">"x1 ~ x2 + x3 + 1"</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>_real_mean <span class="op">=</span> scaled_df[<span class="st">"x1"</span>].mean()</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>_estimated_mean1 <span class="op">=</span> idata1.posterior_predictive.likelihood.mean(dim<span class="op">=</span>[<span class="st">"date"</span>]).values.flatten()</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>_estimated_mean2 <span class="op">=</span> idata2.posterior_predictive.likelihood.mean(dim<span class="op">=</span>[<span class="st">"date"</span>]).values.flatten()</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>_estimated_mean3 <span class="op">=</span> idata3.posterior_predictive.likelihood.mean(dim<span class="op">=</span>[<span class="st">"date"</span>]).values.flatten()</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(_estimated_mean1 <span class="op">-</span> _real_mean, label<span class="op">=</span><span class="st">'Estimated Mean f(x1 ~ 1)'</span>, fill<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(_estimated_mean2 <span class="op">-</span> _real_mean, label<span class="op">=</span><span class="st">'Estimated Mean f(x1 ~ x2 + 1)'</span>, fill<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(_estimated_mean3 <span class="op">-</span> _real_mean, label<span class="op">=</span><span class="st">'Estimated Mean f(x1 ~ x3 + 1)'</span>, fill<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'Zero'</span>)</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>In a causal system where the true direction is <span class="math inline">\(x_1\)</span> to <span class="math inline">\(x_2\)</span>, the joint distribution factorizes as <span class="math display">\[
P(x_1, x_2) = P(x_1) \, P(x_2 \mid x_1),
\]</span></p>
<p>where <span class="math inline">\(x_1\)</span> is exogenous and independent of any effects. This structure reflects that <span class="math inline">\(x_1\)</span>’s distribution remains unchanged regardless of the downstream variable <span class="math inline">\(x_2\)</span>.</p>
<p>When regressing <span class="math inline">\(x_2\)</span> on <span class="math inline">\(x_1\)</span>, the model leverages the causal direction, and the conditional distribution <span class="math inline">\(P(x_2 \mid do(x_1))\)</span> is more concentrated than the marginal <span class="math inline">\(P(x_2)\)</span>. This results in residuals that are centered around zero, indicating that most variability in <span class="math inline">\(x_2\)</span> is explained by <span class="math inline">\(x_1\)</span>.</p>
<p>In contrast, reversing the regression by modeling <span class="math inline">\(x_1\)</span> as a function of <span class="math inline">\(x_2\)</span> disrupts the causal order. The conditional distribution <span class="math inline">\(P(x_1 \mid do(x2))\)</span> deviates from the true marginal <span class="math inline">\(P(x_1)\)</span>, as it attempts to capture the cause from its effect, which is not supported by the causal structure.</p>
<p>The bias in the reverse regression arises because conditioning on <span class="math inline">\(x_2\)</span> introduces variability from the noise inherent in <span class="math inline">\(x_2\)</span>. This misattribution conflates the independent variability of <span class="math inline">\(x_1\)</span> with that induced by <span class="math inline">\(x_2\)</span>, leading to residuals that systematically deviate from zero. Respect to the null model, the residuals are further from zero.</p>
<p>This discrepancy underscores the importance of preserving the correct causal direction to avoid bias, as reversing the regression violates the causal Markov condition.</p>
<p>Using this logic, we can identify not only independent variables but also the candidate parents for each variable based on how they deviate from the null model.</p>
<div id="01e710b1" class="cell" data-execution_count="17">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>idata1, model1 <span class="op">=</span> build_and_sample_model(</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>scaled_df,</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="st">"x2 ~ 1"</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>idata2, model2 <span class="op">=</span> build_and_sample_model(</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>scaled_df,</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="st">"x2 ~ x1 + 1"</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>idata3, model3 <span class="op">=</span> build_and_sample_model(</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>scaled_df,</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="st">"x2 ~ x3 + 1"</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>idata4, model4 <span class="op">=</span> build_and_sample_model(</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>scaled_df,</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a><span class="st">"x2 ~ x1 + x3 + 1"</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>_real_mean <span class="op">=</span> scaled_df[<span class="st">"x2"</span>].mean()</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>_estimated_mean1 <span class="op">=</span> idata1.posterior_predictive.likelihood.mean(dim<span class="op">=</span>[<span class="st">"date"</span>]).values.flatten()</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>_estimated_mean2 <span class="op">=</span> idata2.posterior_predictive.likelihood.mean(dim<span class="op">=</span>[<span class="st">"date"</span>]).values.flatten()</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>_estimated_mean3 <span class="op">=</span> idata3.posterior_predictive.likelihood.mean(dim<span class="op">=</span>[<span class="st">"date"</span>]).values.flatten()</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a><span class="co">#plot distribution of means and real mean as vertical line</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(_estimated_mean1 <span class="op">-</span> _real_mean, label<span class="op">=</span><span class="st">'Estimated Mean f(x2 ~ 1)'</span>, fill<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(_estimated_mean2 <span class="op">-</span> _real_mean, label<span class="op">=</span><span class="st">'Estimated Mean f(x2 ~ x1 + 1)'</span>, fill<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(_estimated_mean3 <span class="op">-</span> _real_mean, label<span class="op">=</span><span class="st">'Estimated Mean f(x2 ~ x3 + 1)'</span>, fill<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'Zero'</span>)</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Here we can see that the residuals are centered around zero when we regress the marginal probability of <span class="math inline">\(x_2\)</span>, but they are closer to zero with a probability distribution narrower than the null model when we regress <span class="math inline">\(x_2\)</span> on <span class="math inline">\(x_1\)</span>. This is a good sign that <span class="math inline">\(x_1\)</span> is a parent of <span class="math inline">\(x_2\)</span>.</p>
<p>We can repeat this process for all the variables in our dataset to start to identify the parents of each variable, and thus identifying sections of the true causal graph.</p>
<p>Let’s implement this in code.</p>
</section>
<section id="identifying-parent-candidates" class="level1">
<h1>Identifying Parent Candidates</h1>
<p>To systematically identify potential parent variables in our causal graph, we’ll create a class that evaluates different regression models and compares their residual distributions. This approach leverages the principle that when we correctly model the causal direction, residuals should be more tightly centered around zero compared to misspecified models.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p>While this approach provides a good initial signal for causal relationships, it has limitations. The method assumes linear relationships, doesn’t account for hidden confounders, and may struggle with complex causal structures. Results should be considered as preliminary evidence rather than definitive proof of causal relationships.</p>
</div>
</div>
<p>The <code>ParentCandidateIdentifier</code> class below will: 1. Run a baseline model with only an intercept 2. Run models with each potential parent variable 3. Compare how much probability mass is concentrated near zero in the residual distributions 4. Identify variables that improve the model fit as potential parent candidates</p>
<div id="232fb459" class="cell" data-execution_count="18">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ParentCandidateIdentifier:</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data: pd.DataFrame, node: <span class="bu">str</span>, possible_parents: <span class="bu">list</span>, epsilon: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.005</span>):</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters:</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co">            data: DataFrame containing your data.</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="co">            node: The target variable for which to identify candidate parents.</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co">            possible_parents: A list of potential parent variable names.</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="co">            epsilon: Threshold to define "mass around zero" (default 0.05).</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.data <span class="op">=</span> data</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.node <span class="op">=</span> node</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.possible_parents <span class="op">=</span> possible_parents</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.epsilon <span class="op">=</span> epsilon</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.runs <span class="op">=</span> {}</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.results <span class="op">=</span> <span class="va">None</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> build_and_sample_model(<span class="va">self</span>, formula: <span class="bu">str</span>):</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Wrapper for the sampling function."""</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> build_and_sample_model(<span class="va">self</span>.data, formula)</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> compute_mass_around_zero(<span class="va">self</span>, idata, real_mean):</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a><span class="co">        Compute the fraction of posterior predictive likelihood samples</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a><span class="co">        (averaged over dates) within epsilon of the real mean.</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>        estimated_mean <span class="op">=</span> idata.posterior_predictive.likelihood.mean(dim<span class="op">=</span>[<span class="st">"date"</span>]).values.flatten()</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>        distribution <span class="op">=</span> estimated_mean <span class="op">-</span> real_mean</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>        mass <span class="op">=</span> np.mean(np.<span class="bu">abs</span>(distribution) <span class="op">&lt;</span> <span class="va">self</span>.epsilon)</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> mass, distribution</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> run_all_models(<span class="va">self</span>):</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a><span class="co">        Run the intercept-only model and each individual parent's model,</span></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a><span class="co">        storing the sampling results, mass, and error distributions.</span></span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>        real_mean <span class="op">=</span> <span class="va">self</span>.data[<span class="va">self</span>.node].mean()</span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>        runs <span class="op">=</span> {}</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Intercept-only model: P(node)</span></span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>        formula_intercept <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>node<span class="sc">}</span><span class="ss"> ~ 1"</span></span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>        idata_int, _ <span class="op">=</span> <span class="va">self</span>.build_and_sample_model(formula_intercept)</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>        mass_int, dist_int <span class="op">=</span> <span class="va">self</span>.compute_mass_around_zero(idata_int, real_mean)</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a>        runs[<span class="st">"intercept_only"</span>] <span class="op">=</span> {</span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>            <span class="st">"formula"</span>: formula_intercept,</span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a>            <span class="st">"idata"</span>: idata_int,</span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a>            <span class="st">"mass"</span>: mass_int,</span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a>            <span class="st">"distribution"</span>: dist_int</span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb18-49"><a href="#cb18-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-50"><a href="#cb18-50" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Individual candidate parent models: P(node|parent)</span></span>
<span id="cb18-51"><a href="#cb18-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> parent <span class="kw">in</span> <span class="va">self</span>.possible_parents:</span>
<span id="cb18-52"><a href="#cb18-52" aria-hidden="true" tabindex="-1"></a>            formula_parent <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>node<span class="sc">}</span><span class="ss"> ~ </span><span class="sc">{</span>parent<span class="sc">}</span><span class="ss"> + 1"</span></span>
<span id="cb18-53"><a href="#cb18-53" aria-hidden="true" tabindex="-1"></a>            idata_parent, _ <span class="op">=</span> <span class="va">self</span>.build_and_sample_model(formula_parent)</span>
<span id="cb18-54"><a href="#cb18-54" aria-hidden="true" tabindex="-1"></a>            mass_parent, dist_parent <span class="op">=</span> <span class="va">self</span>.compute_mass_around_zero(idata_parent, real_mean)</span>
<span id="cb18-55"><a href="#cb18-55" aria-hidden="true" tabindex="-1"></a>            runs[<span class="ss">f"parent_</span><span class="sc">{</span>parent<span class="sc">}</span><span class="ss">"</span>] <span class="op">=</span> {</span>
<span id="cb18-56"><a href="#cb18-56" aria-hidden="true" tabindex="-1"></a>                <span class="st">"formula"</span>: formula_parent,</span>
<span id="cb18-57"><a href="#cb18-57" aria-hidden="true" tabindex="-1"></a>                <span class="st">"idata"</span>: idata_parent,</span>
<span id="cb18-58"><a href="#cb18-58" aria-hidden="true" tabindex="-1"></a>                <span class="st">"mass"</span>: mass_parent,</span>
<span id="cb18-59"><a href="#cb18-59" aria-hidden="true" tabindex="-1"></a>                <span class="st">"distribution"</span>: dist_parent</span>
<span id="cb18-60"><a href="#cb18-60" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb18-61"><a href="#cb18-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-62"><a href="#cb18-62" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.runs <span class="op">=</span> runs</span>
<span id="cb18-63"><a href="#cb18-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> runs</span>
<span id="cb18-64"><a href="#cb18-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-65"><a href="#cb18-65" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> identify_candidate_parents(<span class="va">self</span>):</span>
<span id="cb18-66"><a href="#cb18-66" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb18-67"><a href="#cb18-67" aria-hidden="true" tabindex="-1"></a><span class="co">        Runs all models (if not already run), compares the mass around zero,</span></span>
<span id="cb18-68"><a href="#cb18-68" aria-hidden="true" tabindex="-1"></a><span class="co">        and returns a decision: if the intercept-only model is best, the target</span></span>
<span id="cb18-69"><a href="#cb18-69" aria-hidden="true" tabindex="-1"></a><span class="co">        is independent; otherwise, return the candidate parent with the highest mass.</span></span>
<span id="cb18-70"><a href="#cb18-70" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb18-71"><a href="#cb18-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.runs:</span>
<span id="cb18-72"><a href="#cb18-72" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.run_all_models()</span>
<span id="cb18-73"><a href="#cb18-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-74"><a href="#cb18-74" aria-hidden="true" tabindex="-1"></a>        best_key, best_info <span class="op">=</span> <span class="bu">max</span>(<span class="va">self</span>.runs.items(), key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>][<span class="st">"mass"</span>])</span>
<span id="cb18-75"><a href="#cb18-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-76"><a href="#cb18-76" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> best_key <span class="op">==</span> <span class="st">"intercept_only"</span>:</span>
<span id="cb18-77"><a href="#cb18-77" aria-hidden="true" tabindex="-1"></a>            decision <span class="op">=</span> <span class="st">"independent"</span></span>
<span id="cb18-78"><a href="#cb18-78" aria-hidden="true" tabindex="-1"></a>            candidate_parents <span class="op">=</span> []</span>
<span id="cb18-79"><a href="#cb18-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb18-80"><a href="#cb18-80" aria-hidden="true" tabindex="-1"></a>            decision <span class="op">=</span> <span class="st">"dependent"</span></span>
<span id="cb18-81"><a href="#cb18-81" aria-hidden="true" tabindex="-1"></a>            candidate_parents <span class="op">=</span> [best_key.split(<span class="st">"_"</span>, <span class="dv">1</span>)[<span class="dv">1</span>]]</span>
<span id="cb18-82"><a href="#cb18-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-83"><a href="#cb18-83" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.results <span class="op">=</span> {</span>
<span id="cb18-84"><a href="#cb18-84" aria-hidden="true" tabindex="-1"></a>            <span class="st">"results"</span>: <span class="va">self</span>.runs,</span>
<span id="cb18-85"><a href="#cb18-85" aria-hidden="true" tabindex="-1"></a>            <span class="st">"best_model"</span>: {best_key: best_info},</span>
<span id="cb18-86"><a href="#cb18-86" aria-hidden="true" tabindex="-1"></a>            <span class="st">"decision"</span>: decision,</span>
<span id="cb18-87"><a href="#cb18-87" aria-hidden="true" tabindex="-1"></a>            <span class="st">"candidate_parents"</span>: candidate_parents</span>
<span id="cb18-88"><a href="#cb18-88" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb18-89"><a href="#cb18-89" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.results</span>
<span id="cb18-90"><a href="#cb18-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-91"><a href="#cb18-91" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> plot_distributions(<span class="va">self</span>):</span>
<span id="cb18-92"><a href="#cb18-92" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb18-93"><a href="#cb18-93" aria-hidden="true" tabindex="-1"></a><span class="co">        Plot the error distributions from the stored runs using Seaborn.</span></span>
<span id="cb18-94"><a href="#cb18-94" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb18-95"><a href="#cb18-95" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.runs:</span>
<span id="cb18-96"><a href="#cb18-96" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.run_all_models()</span>
<span id="cb18-97"><a href="#cb18-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-98"><a href="#cb18-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> key, run <span class="kw">in</span> <span class="va">self</span>.runs.items():</span>
<span id="cb18-99"><a href="#cb18-99" aria-hidden="true" tabindex="-1"></a>            sns.kdeplot(run[<span class="st">"distribution"</span>], label<span class="op">=</span>run[<span class="st">"formula"</span>], fill<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-100"><a href="#cb18-100" aria-hidden="true" tabindex="-1"></a>        plt.axvline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'Zero Error'</span>)</span>
<span id="cb18-101"><a href="#cb18-101" aria-hidden="true" tabindex="-1"></a>        plt.xlabel(<span class="st">"Error (Estimated Mean - Real Mean)"</span>)</span>
<span id="cb18-102"><a href="#cb18-102" aria-hidden="true" tabindex="-1"></a>        plt.ylabel(<span class="st">"Density"</span>)</span>
<span id="cb18-103"><a href="#cb18-103" aria-hidden="true" tabindex="-1"></a>        plt.title(<span class="st">"Posterior Predictive Error Distributions"</span>)</span>
<span id="cb18-104"><a href="#cb18-104" aria-hidden="true" tabindex="-1"></a>        plt.legend()</span>
<span id="cb18-105"><a href="#cb18-105" aria-hidden="true" tabindex="-1"></a>        plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Now we can identify the candidate parents for each variable..</p>
<div id="6bc74e17" class="cell" data-execution_count="19">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>identifier <span class="op">=</span> ParentCandidateIdentifier(data<span class="op">=</span>scaled_df, node<span class="op">=</span><span class="st">"x3"</span>, possible_parents<span class="op">=</span>[<span class="st">"x1"</span>, <span class="st">"x2"</span>], epsilon<span class="op">=</span><span class="fl">0.0005</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>decision_info <span class="op">=</span> identifier.identify_candidate_parents()</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Possible parents: "</span>, decision_info[<span class="st">"candidate_parents"</span>])</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>identifier.plot_distributions()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Understanding the conditional independencies of the variables in our dataset allows us to identify the parents of each variable. Currently, we have identified that <span class="math inline">\(x_3\)</span> and <span class="math inline">\(x_2\)</span> are children of <span class="math inline">\(x_1\)</span>, and <span class="math inline">\(x_1\)</span> is independent or truly exogenous.</p>
<p>We can now use this information to update our causal graph.</p>
<div id="5194814a" class="cell" data-execution_count="20">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize a directed graph</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph <span class="op">=</span> Digraph()</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Add nodes</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.node(<span class="st">"X1"</span>, <span class="st">"Offline"</span>)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.node(<span class="st">"X2"</span>, <span class="st">"Online"</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.node(<span class="st">"X3"</span>, <span class="st">"Internal"</span>)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.node(<span class="st">"E"</span>, <span class="st">"Exogenous variables"</span>, style<span class="op">=</span><span class="st">"dashed"</span>)</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.node(<span class="st">"T"</span>, <span class="st">"Target"</span>)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.edge(<span class="st">"E"</span>, <span class="st">"T"</span>, style<span class="op">=</span><span class="st">"dashed"</span>)</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.edge(<span class="st">"X1"</span>, <span class="st">"T"</span>)</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.edge(<span class="st">"X1"</span>,<span class="st">"X2"</span>)</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.edge(<span class="st">"X1"</span>,<span class="st">"X3"</span>)</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.edge(<span class="st">"X2"</span>, <span class="st">"T"</span>)</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.edge(<span class="st">"X3"</span>, <span class="st">"T"</span>)</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a figure with five subplots</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>,)</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Set titles for each subplot</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>titles <span class="op">=</span> [<span class="st">"Naive DAG"</span>, <span class="st">"Updated DAG"</span>]</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, title <span class="kw">in</span> <span class="bu">zip</span>(axes, titles):</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>    ax.set_title(title, fontsize<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>    ax.axis(<span class="st">'off'</span>)</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Render and plot each graph</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/naive_dag'</span>)</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].imshow(mpimg.imread(<span class="st">'images/naive_dag.png'</span>))</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/updated_dag'</span>)</span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].imshow(mpimg.imread(<span class="st">'images/updated_dag.png'</span>))</span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Add main title</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">"Comparison of DAG Graphs"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Great, we can update our model of the world to include the causal relationships we have identified. How else can we use this information to learn more about the causal relationships in our dataset?</p>
</section>
<section id="mediation-analysis-for-the-causal-discovery" class="level1">
<h1>Mediation analysis for the causal discovery</h1>
<p>In mediation analysis, the total effect of a predictor <span class="math inline">\(X1\)</span> on a target <span class="math inline">\(T\)</span> is decomposed into direct and indirect components. The indirect effect operates through a mediator <span class="math inline">\(M\)</span>, modeled as <span class="math inline">\(M = \alpha_m + a \times X1 + \text{error}\)</span>. Simultaneously, the outcome is modeled as <span class="math inline">\(T = \alpha_y + c' \times X1 + b \times M + \text{error}\)</span>. Here, the product <span class="math inline">\(a \times b\)</span> quantifies the indirect effect, while <span class="math inline">\(c'\)</span> represents the direct effect of <span class="math inline">\(X1\)</span> on <span class="math inline">\(T\)</span>. By estimating these coefficients, we can assess whether the influence of <span class="math inline">\(X1\)</span> on <span class="math inline">\(T\)</span> is transmitted via <span class="math inline">\(M\)</span>, entirely direct, or a combination of both. Statistical inference is performed using credible intervals, where intervals excluding zero indicate significant effects.</p>
<p>If the indirect effect <span class="math inline">\(a \times b\)</span> is significant and the direct effect <span class="math inline">\(c'\)</span> is not, we conclude that <span class="math inline">\(X1\)</span>’s impact on <span class="math inline">\(T\)</span> is fully mediated by <span class="math inline">\(M\)</span>. Conversely, significant values for both <span class="math inline">\(a \times b\)</span> and <span class="math inline">\(c'\)</span> suggest that <span class="math inline">\(X1\)</span> exerts both direct and indirect influences on <span class="math inline">\(T\)</span>.</p>
<p>In simple terms, mediation analysis helps us determine whether a predictor <span class="math inline">\(X1\)</span> influences an outcome <span class="math inline">\(T\)</span> directly or mainly by first affecting a mediator <span class="math inline">\(M\)</span>, which then impacts <span class="math inline">\(T\)</span>. If the mediator’s effect is significant while the direct effect is not, it suggests that <span class="math inline">\(X1\)</span> affects <span class="math inline">\(T\)</span> primarily through its influence on <span class="math inline">\(M\)</span>.</p>
<p>Why do this on top of the causal discovery we have already done? The reason is that we can use the mediation analysis to verify the causal relationships we have identified, becuase if a node is parent the other then some effect is mediated, if we can detect that mediation, then we can decide if the causal relationship is direct or indirect. If we fail to detect mediation, then probably our findings are not robust to the causal discovery we have done.</p>
<div id="4a8e3340" class="cell" data-execution_count="21">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MediationAnalysis:</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co">    A class for performing Bayesian mediation analysis using a joint mediation model.</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co">    The model is specified as:</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="co">      Mediator:    M = α_m + a * X + error</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="co">      Outcome:     Y = α_y + c′ * X + b * M + error</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Derived parameters:</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="co">      - Indirect effect: ab = a * b</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="co">      - Total effect:    c  = c′ + (a * b)</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="co">    data : pd.DataFrame</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a><span class="co">        DataFrame containing the predictor, mediator, and outcome variables.</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a><span class="co">    x : str</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a><span class="co">        Column name for the predictor (X).</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a><span class="co">    m : str</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span class="co">        Column name for the mediator (M).</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a><span class="co">    y : str</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a><span class="co">        Column name for the outcome (Y).</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a><span class="co">    hdi : float, optional</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a><span class="co">        Credible interval width for HDI (default 0.95).</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a><span class="co">    sampler_kwargs : dict, optional</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a><span class="co">        Additional keyword arguments for the sampler.</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a><span class="co">        Default: {"tune": 1000, "draws": 500, "chains": 4,</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a><span class="co">                  "random_seed": 42, "target_accept": 0.9,</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a><span class="co">                  "nuts_sampler": "numpyro", "progressbar": False}</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data: pd.DataFrame, x: <span class="bu">str</span>, m: <span class="bu">str</span>, y: <span class="bu">str</span>, hdi: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.95</span>, sampler_kwargs: <span class="bu">dict</span> <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.data <span class="op">=</span> data</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> x</span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.m <span class="op">=</span> m</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.y <span class="op">=</span> y</span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.hdi <span class="op">=</span> hdi</span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sampler_kwargs <span class="op">=</span> sampler_kwargs <span class="kw">or</span> {</span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>            <span class="st">"tune"</span>: <span class="dv">1000</span>,</span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>            <span class="st">"draws"</span>: <span class="dv">500</span>,</span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>            <span class="st">"chains"</span>: <span class="dv">4</span>,</span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>            <span class="st">"random_seed"</span>: <span class="dv">42</span>,</span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>            <span class="st">"target_accept"</span>: <span class="fl">0.9</span>,</span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>            <span class="st">"nuts_sampler"</span>: <span class="st">"numpyro"</span>,</span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>            <span class="st">"progressbar"</span>: <span class="va">False</span></span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.idata <span class="op">=</span> <span class="va">None</span></span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.model <span class="op">=</span> <span class="va">None</span></span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> build_model(<span class="va">self</span>):</span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a><span class="co">        Build the Bayesian mediation model.</span></span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-53"><a href="#cb21-53" aria-hidden="true" tabindex="-1"></a><span class="co">        This method constructs the PyMC model and stores it in self.model.</span></span>
<span id="cb21-54"><a href="#cb21-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-55"><a href="#cb21-55" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb21-56"><a href="#cb21-56" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb21-57"><a href="#cb21-57" aria-hidden="true" tabindex="-1"></a><span class="co">        model : pm.Model</span></span>
<span id="cb21-58"><a href="#cb21-58" aria-hidden="true" tabindex="-1"></a><span class="co">            The constructed PyMC model.</span></span>
<span id="cb21-59"><a href="#cb21-59" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb21-60"><a href="#cb21-60" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract data arrays</span></span>
<span id="cb21-61"><a href="#cb21-61" aria-hidden="true" tabindex="-1"></a>        X_data <span class="op">=</span> <span class="va">self</span>.data[<span class="va">self</span>.x].values</span>
<span id="cb21-62"><a href="#cb21-62" aria-hidden="true" tabindex="-1"></a>        M_data <span class="op">=</span> <span class="va">self</span>.data[<span class="va">self</span>.m].values</span>
<span id="cb21-63"><a href="#cb21-63" aria-hidden="true" tabindex="-1"></a>        Y_data <span class="op">=</span> <span class="va">self</span>.data[<span class="va">self</span>.y].values</span>
<span id="cb21-64"><a href="#cb21-64" aria-hidden="true" tabindex="-1"></a>        N <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.data)</span>
<span id="cb21-65"><a href="#cb21-65" aria-hidden="true" tabindex="-1"></a>        coords <span class="op">=</span> {<span class="st">"obs"</span>: <span class="bu">range</span>(N)}</span>
<span id="cb21-66"><a href="#cb21-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-67"><a href="#cb21-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> pm.Model(coords<span class="op">=</span>coords) <span class="im">as</span> model:</span>
<span id="cb21-68"><a href="#cb21-68" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Mediator path: M = α_m + a * X + error</span></span>
<span id="cb21-69"><a href="#cb21-69" aria-hidden="true" tabindex="-1"></a>            alpha_m <span class="op">=</span> pm.Normal(<span class="st">"alpha_m"</span>, mu<span class="op">=</span><span class="fl">0.0</span>, sigma<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb21-70"><a href="#cb21-70" aria-hidden="true" tabindex="-1"></a>            a <span class="op">=</span> pm.Normal(<span class="st">"a"</span>, mu<span class="op">=</span><span class="fl">0.0</span>, sigma<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb21-71"><a href="#cb21-71" aria-hidden="true" tabindex="-1"></a>            sigma_m <span class="op">=</span> pm.Exponential(<span class="st">"sigma_m"</span>, lam<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb21-72"><a href="#cb21-72" aria-hidden="true" tabindex="-1"></a>            mu_m <span class="op">=</span> alpha_m <span class="op">+</span> a <span class="op">*</span> X_data</span>
<span id="cb21-73"><a href="#cb21-73" aria-hidden="true" tabindex="-1"></a>            pm.Normal(<span class="st">"M_obs"</span>, mu<span class="op">=</span>mu_m, sigma<span class="op">=</span>sigma_m, observed<span class="op">=</span>M_data, dims<span class="op">=</span><span class="st">"obs"</span>)</span>
<span id="cb21-74"><a href="#cb21-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-75"><a href="#cb21-75" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Outcome path: Y = α_y + c′ * X + b * M + error</span></span>
<span id="cb21-76"><a href="#cb21-76" aria-hidden="true" tabindex="-1"></a>            alpha_y <span class="op">=</span> pm.Normal(<span class="st">"alpha_y"</span>, mu<span class="op">=</span><span class="fl">0.0</span>, sigma<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb21-77"><a href="#cb21-77" aria-hidden="true" tabindex="-1"></a>            c_prime <span class="op">=</span> pm.Normal(<span class="st">"c_prime"</span>, mu<span class="op">=</span><span class="fl">0.0</span>, sigma<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb21-78"><a href="#cb21-78" aria-hidden="true" tabindex="-1"></a>            b <span class="op">=</span> pm.Normal(<span class="st">"b"</span>, mu<span class="op">=</span><span class="fl">0.0</span>, sigma<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb21-79"><a href="#cb21-79" aria-hidden="true" tabindex="-1"></a>            sigma_y <span class="op">=</span> pm.Exponential(<span class="st">"sigma_y"</span>, lam<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb21-80"><a href="#cb21-80" aria-hidden="true" tabindex="-1"></a>            mu_y <span class="op">=</span> alpha_y <span class="op">+</span> c_prime <span class="op">*</span> X_data <span class="op">+</span> b <span class="op">*</span> M_data</span>
<span id="cb21-81"><a href="#cb21-81" aria-hidden="true" tabindex="-1"></a>            pm.Normal(<span class="st">"Y_obs"</span>, mu<span class="op">=</span>mu_y, sigma<span class="op">=</span>sigma_y, observed<span class="op">=</span>Y_data, dims<span class="op">=</span><span class="st">"obs"</span>)</span>
<span id="cb21-82"><a href="#cb21-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-83"><a href="#cb21-83" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Derived parameters: indirect and total effects</span></span>
<span id="cb21-84"><a href="#cb21-84" aria-hidden="true" tabindex="-1"></a>            pm.Deterministic(<span class="st">"ab"</span>, a <span class="op">*</span> b)</span>
<span id="cb21-85"><a href="#cb21-85" aria-hidden="true" tabindex="-1"></a>            pm.Deterministic(<span class="st">"c"</span>, c_prime <span class="op">+</span> a <span class="op">*</span> b)</span>
<span id="cb21-86"><a href="#cb21-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-87"><a href="#cb21-87" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.model <span class="op">=</span> model</span>
<span id="cb21-88"><a href="#cb21-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-89"><a href="#cb21-89" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fit(<span class="va">self</span>):</span>
<span id="cb21-90"><a href="#cb21-90" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb21-91"><a href="#cb21-91" aria-hidden="true" tabindex="-1"></a><span class="co">        Sample from the previously built mediation model.</span></span>
<span id="cb21-92"><a href="#cb21-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-93"><a href="#cb21-93" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb21-94"><a href="#cb21-94" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb21-95"><a href="#cb21-95" aria-hidden="true" tabindex="-1"></a><span class="co">        self : MediationAnalysis</span></span>
<span id="cb21-96"><a href="#cb21-96" aria-hidden="true" tabindex="-1"></a><span class="co">            The fitted mediation analysis object.</span></span>
<span id="cb21-97"><a href="#cb21-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-98"><a href="#cb21-98" aria-hidden="true" tabindex="-1"></a><span class="co">        Raises</span></span>
<span id="cb21-99"><a href="#cb21-99" aria-hidden="true" tabindex="-1"></a><span class="co">        ------</span></span>
<span id="cb21-100"><a href="#cb21-100" aria-hidden="true" tabindex="-1"></a><span class="co">        ValueError</span></span>
<span id="cb21-101"><a href="#cb21-101" aria-hidden="true" tabindex="-1"></a><span class="co">            If the model has not been built yet.</span></span>
<span id="cb21-102"><a href="#cb21-102" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb21-103"><a href="#cb21-103" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.model <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb21-104"><a href="#cb21-104" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"The model has not been built. Call build_model() before fit()."</span>)</span>
<span id="cb21-105"><a href="#cb21-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-106"><a href="#cb21-106" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> <span class="va">self</span>.model:</span>
<span id="cb21-107"><a href="#cb21-107" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.idata <span class="op">=</span> pm.sample(<span class="op">**</span><span class="va">self</span>.sampler_kwargs)</span>
<span id="cb21-108"><a href="#cb21-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-109"><a href="#cb21-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-110"><a href="#cb21-110" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_summary(<span class="va">self</span>):</span>
<span id="cb21-111"><a href="#cb21-111" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb21-112"><a href="#cb21-112" aria-hidden="true" tabindex="-1"></a><span class="co">        Get a numerical summary of the mediation parameters.</span></span>
<span id="cb21-113"><a href="#cb21-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-114"><a href="#cb21-114" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb21-115"><a href="#cb21-115" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb21-116"><a href="#cb21-116" aria-hidden="true" tabindex="-1"></a><span class="co">        dict</span></span>
<span id="cb21-117"><a href="#cb21-117" aria-hidden="true" tabindex="-1"></a><span class="co">            Dictionary with mean estimates and HDI bounds for each parameter.</span></span>
<span id="cb21-118"><a href="#cb21-118" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb21-119"><a href="#cb21-119" aria-hidden="true" tabindex="-1"></a>        var_names <span class="op">=</span> [<span class="st">"alpha_m"</span>, <span class="st">"a"</span>, <span class="st">"alpha_y"</span>, <span class="st">"c_prime"</span>, <span class="st">"b"</span>, <span class="st">"ab"</span>, <span class="st">"c"</span>]</span>
<span id="cb21-120"><a href="#cb21-120" aria-hidden="true" tabindex="-1"></a>        summary_df <span class="op">=</span> az.summary(<span class="va">self</span>.idata, var_names<span class="op">=</span>var_names, hdi_prob<span class="op">=</span><span class="va">self</span>.hdi)</span>
<span id="cb21-121"><a href="#cb21-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-122"><a href="#cb21-122" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compute the HDI column names based on the specified interval</span></span>
<span id="cb21-123"><a href="#cb21-123" aria-hidden="true" tabindex="-1"></a>        lower_percent <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.hdi) <span class="op">/</span> <span class="dv">2</span> <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb21-124"><a href="#cb21-124" aria-hidden="true" tabindex="-1"></a>        upper_percent <span class="op">=</span> <span class="dv">100</span> <span class="op">-</span> lower_percent</span>
<span id="cb21-125"><a href="#cb21-125" aria-hidden="true" tabindex="-1"></a>        lower_col <span class="op">=</span> <span class="ss">f"hdi_</span><span class="sc">{</span>lower_percent<span class="sc">:.1f}</span><span class="ss">%"</span></span>
<span id="cb21-126"><a href="#cb21-126" aria-hidden="true" tabindex="-1"></a>        upper_col <span class="op">=</span> <span class="ss">f"hdi_</span><span class="sc">{</span>upper_percent<span class="sc">:.1f}</span><span class="ss">%"</span></span>
<span id="cb21-127"><a href="#cb21-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-128"><a href="#cb21-128" aria-hidden="true" tabindex="-1"></a>        results <span class="op">=</span> {}</span>
<span id="cb21-129"><a href="#cb21-129" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> key <span class="kw">in</span> var_names:</span>
<span id="cb21-130"><a href="#cb21-130" aria-hidden="true" tabindex="-1"></a>            results[key] <span class="op">=</span> {</span>
<span id="cb21-131"><a href="#cb21-131" aria-hidden="true" tabindex="-1"></a>                <span class="st">"mean"</span>: summary_df.loc[key, <span class="st">"mean"</span>],</span>
<span id="cb21-132"><a href="#cb21-132" aria-hidden="true" tabindex="-1"></a>                <span class="st">"hdi_lower"</span>: summary_df.loc[key, lower_col],</span>
<span id="cb21-133"><a href="#cb21-133" aria-hidden="true" tabindex="-1"></a>                <span class="st">"hdi_upper"</span>: summary_df.loc[key, upper_col]</span>
<span id="cb21-134"><a href="#cb21-134" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb21-135"><a href="#cb21-135" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> results</span>
<span id="cb21-136"><a href="#cb21-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-137"><a href="#cb21-137" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_report(<span class="va">self</span>, x_label: <span class="bu">str</span> <span class="op">=</span> <span class="va">None</span>, m_label: <span class="bu">str</span> <span class="op">=</span> <span class="va">None</span>, y_label: <span class="bu">str</span> <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb21-138"><a href="#cb21-138" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb21-139"><a href="#cb21-139" aria-hidden="true" tabindex="-1"></a><span class="co">        Generate a plain-language report of the mediation analysis results.</span></span>
<span id="cb21-140"><a href="#cb21-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-141"><a href="#cb21-141" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb21-142"><a href="#cb21-142" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb21-143"><a href="#cb21-143" aria-hidden="true" tabindex="-1"></a><span class="co">        x_label : str, optional</span></span>
<span id="cb21-144"><a href="#cb21-144" aria-hidden="true" tabindex="-1"></a><span class="co">            Label for the predictor variable (default uses self.x).</span></span>
<span id="cb21-145"><a href="#cb21-145" aria-hidden="true" tabindex="-1"></a><span class="co">        m_label : str, optional</span></span>
<span id="cb21-146"><a href="#cb21-146" aria-hidden="true" tabindex="-1"></a><span class="co">            Label for the mediator variable (default uses self.m).</span></span>
<span id="cb21-147"><a href="#cb21-147" aria-hidden="true" tabindex="-1"></a><span class="co">        y_label : str, optional</span></span>
<span id="cb21-148"><a href="#cb21-148" aria-hidden="true" tabindex="-1"></a><span class="co">            Label for the outcome variable (default uses self.y).</span></span>
<span id="cb21-149"><a href="#cb21-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-150"><a href="#cb21-150" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb21-151"><a href="#cb21-151" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb21-152"><a href="#cb21-152" aria-hidden="true" tabindex="-1"></a><span class="co">        str</span></span>
<span id="cb21-153"><a href="#cb21-153" aria-hidden="true" tabindex="-1"></a><span class="co">            A human-readable summary of the mediation effects.</span></span>
<span id="cb21-154"><a href="#cb21-154" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb21-155"><a href="#cb21-155" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Use provided labels or default to variable names</span></span>
<span id="cb21-156"><a href="#cb21-156" aria-hidden="true" tabindex="-1"></a>        x_label <span class="op">=</span> x_label <span class="kw">or</span> <span class="va">self</span>.x</span>
<span id="cb21-157"><a href="#cb21-157" aria-hidden="true" tabindex="-1"></a>        m_label <span class="op">=</span> m_label <span class="kw">or</span> <span class="va">self</span>.m</span>
<span id="cb21-158"><a href="#cb21-158" aria-hidden="true" tabindex="-1"></a>        y_label <span class="op">=</span> y_label <span class="kw">or</span> <span class="va">self</span>.y</span>
<span id="cb21-159"><a href="#cb21-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-160"><a href="#cb21-160" aria-hidden="true" tabindex="-1"></a>        var_names <span class="op">=</span> [<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c_prime"</span>, <span class="st">"ab"</span>, <span class="st">"c"</span>]</span>
<span id="cb21-161"><a href="#cb21-161" aria-hidden="true" tabindex="-1"></a>        summary_df <span class="op">=</span> az.summary(<span class="va">self</span>.idata, var_names<span class="op">=</span>var_names, hdi_prob<span class="op">=</span><span class="va">self</span>.hdi)</span>
<span id="cb21-162"><a href="#cb21-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-163"><a href="#cb21-163" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> hdi_includes_zero(row):</span>
<span id="cb21-164"><a href="#cb21-164" aria-hidden="true" tabindex="-1"></a>            lower_percent <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.hdi) <span class="op">/</span> <span class="dv">2</span> <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb21-165"><a href="#cb21-165" aria-hidden="true" tabindex="-1"></a>            upper_percent <span class="op">=</span> <span class="dv">100</span> <span class="op">-</span> lower_percent</span>
<span id="cb21-166"><a href="#cb21-166" aria-hidden="true" tabindex="-1"></a>            lower_col <span class="op">=</span> <span class="ss">f"hdi_</span><span class="sc">{</span>lower_percent<span class="sc">:.1f}</span><span class="ss">%"</span></span>
<span id="cb21-167"><a href="#cb21-167" aria-hidden="true" tabindex="-1"></a>            upper_col <span class="op">=</span> <span class="ss">f"hdi_</span><span class="sc">{</span>upper_percent<span class="sc">:.1f}</span><span class="ss">%"</span></span>
<span id="cb21-168"><a href="#cb21-168" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> row[lower_col] <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">&lt;=</span> row[upper_col]</span>
<span id="cb21-169"><a href="#cb21-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-170"><a href="#cb21-170" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract summary statistics</span></span>
<span id="cb21-171"><a href="#cb21-171" aria-hidden="true" tabindex="-1"></a>        a_stats <span class="op">=</span> summary_df.loc[<span class="st">"a"</span>]</span>
<span id="cb21-172"><a href="#cb21-172" aria-hidden="true" tabindex="-1"></a>        b_stats <span class="op">=</span> summary_df.loc[<span class="st">"b"</span>]</span>
<span id="cb21-173"><a href="#cb21-173" aria-hidden="true" tabindex="-1"></a>        c_prime_stats <span class="op">=</span> summary_df.loc[<span class="st">"c_prime"</span>]</span>
<span id="cb21-174"><a href="#cb21-174" aria-hidden="true" tabindex="-1"></a>        ab_stats <span class="op">=</span> summary_df.loc[<span class="st">"ab"</span>]</span>
<span id="cb21-175"><a href="#cb21-175" aria-hidden="true" tabindex="-1"></a>        c_stats <span class="op">=</span> summary_df.loc[<span class="st">"c"</span>]</span>
<span id="cb21-176"><a href="#cb21-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-177"><a href="#cb21-177" aria-hidden="true" tabindex="-1"></a>        a_mean <span class="op">=</span> a_stats[<span class="st">"mean"</span>]</span>
<span id="cb21-178"><a href="#cb21-178" aria-hidden="true" tabindex="-1"></a>        b_mean <span class="op">=</span> b_stats[<span class="st">"mean"</span>]</span>
<span id="cb21-179"><a href="#cb21-179" aria-hidden="true" tabindex="-1"></a>        c_prime_mean <span class="op">=</span> c_prime_stats[<span class="st">"mean"</span>]</span>
<span id="cb21-180"><a href="#cb21-180" aria-hidden="true" tabindex="-1"></a>        ab_mean <span class="op">=</span> ab_stats[<span class="st">"mean"</span>]</span>
<span id="cb21-181"><a href="#cb21-181" aria-hidden="true" tabindex="-1"></a>        c_mean <span class="op">=</span> c_stats[<span class="st">"mean"</span>]</span>
<span id="cb21-182"><a href="#cb21-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-183"><a href="#cb21-183" aria-hidden="true" tabindex="-1"></a>        a_zero <span class="op">=</span> hdi_includes_zero(a_stats)</span>
<span id="cb21-184"><a href="#cb21-184" aria-hidden="true" tabindex="-1"></a>        b_zero <span class="op">=</span> hdi_includes_zero(b_stats)</span>
<span id="cb21-185"><a href="#cb21-185" aria-hidden="true" tabindex="-1"></a>        c_prime_zero <span class="op">=</span> hdi_includes_zero(c_prime_stats)</span>
<span id="cb21-186"><a href="#cb21-186" aria-hidden="true" tabindex="-1"></a>        ab_zero <span class="op">=</span> hdi_includes_zero(ab_stats)</span>
<span id="cb21-187"><a href="#cb21-187" aria-hidden="true" tabindex="-1"></a>        c_zero <span class="op">=</span> hdi_includes_zero(c_stats)</span>
<span id="cb21-188"><a href="#cb21-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-189"><a href="#cb21-189" aria-hidden="true" tabindex="-1"></a>        lines <span class="op">=</span> []</span>
<span id="cb21-190"><a href="#cb21-190" aria-hidden="true" tabindex="-1"></a>        lines.append(<span class="ss">f"**Bayesian Mediation Analysis Overview** (</span><span class="sc">{</span><span class="bu">int</span>(<span class="va">self</span>.hdi <span class="op">*</span> <span class="dv">100</span>)<span class="sc">}</span><span class="ss">% HDI)"</span>)</span>
<span id="cb21-191"><a href="#cb21-191" aria-hidden="true" tabindex="-1"></a>        lines.append(<span class="ss">f"Variables: </span><span class="sc">{</span>x_label<span class="sc">}</span><span class="ss"> (predictor), </span><span class="sc">{</span>m_label<span class="sc">}</span><span class="ss"> (mediator), </span><span class="sc">{</span>y_label<span class="sc">}</span><span class="ss"> (outcome)."</span>)</span>
<span id="cb21-192"><a href="#cb21-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-193"><a href="#cb21-193" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Interpret each path</span></span>
<span id="cb21-194"><a href="#cb21-194" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> a_zero:</span>
<span id="cb21-195"><a href="#cb21-195" aria-hidden="true" tabindex="-1"></a>            direction <span class="op">=</span> <span class="st">"positive"</span> <span class="cf">if</span> a_mean <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="st">"negative"</span></span>
<span id="cb21-196"><a href="#cb21-196" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Path a (</span><span class="sc">{</span>x_label<span class="sc">}</span><span class="ss"> → </span><span class="sc">{</span>m_label<span class="sc">}</span><span class="ss">) is credibly </span><span class="sc">{</span>direction<span class="sc">}</span><span class="ss"> (mean = </span><span class="sc">{</span>a_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb21-197"><a href="#cb21-197" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb21-198"><a href="#cb21-198" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Path a (</span><span class="sc">{</span>x_label<span class="sc">}</span><span class="ss"> → </span><span class="sc">{</span>m_label<span class="sc">}</span><span class="ss">) is weak (HDI includes 0, mean = </span><span class="sc">{</span>a_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb21-199"><a href="#cb21-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-200"><a href="#cb21-200" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> b_zero:</span>
<span id="cb21-201"><a href="#cb21-201" aria-hidden="true" tabindex="-1"></a>            direction <span class="op">=</span> <span class="st">"positive"</span> <span class="cf">if</span> b_mean <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="st">"negative"</span></span>
<span id="cb21-202"><a href="#cb21-202" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Path b (</span><span class="sc">{</span>m_label<span class="sc">}</span><span class="ss"> → </span><span class="sc">{</span>y_label<span class="sc">}</span><span class="ss">, controlling for </span><span class="sc">{</span>x_label<span class="sc">}</span><span class="ss">) is credibly </span><span class="sc">{</span>direction<span class="sc">}</span><span class="ss"> (mean = </span><span class="sc">{</span>b_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb21-203"><a href="#cb21-203" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb21-204"><a href="#cb21-204" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Path b (</span><span class="sc">{</span>m_label<span class="sc">}</span><span class="ss"> → </span><span class="sc">{</span>y_label<span class="sc">}</span><span class="ss">, controlling for </span><span class="sc">{</span>x_label<span class="sc">}</span><span class="ss">) is weak (HDI includes 0, mean = </span><span class="sc">{</span>b_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb21-205"><a href="#cb21-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-206"><a href="#cb21-206" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> ab_zero:</span>
<span id="cb21-207"><a href="#cb21-207" aria-hidden="true" tabindex="-1"></a>            direction <span class="op">=</span> <span class="st">"positive"</span> <span class="cf">if</span> ab_mean <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="st">"negative"</span></span>
<span id="cb21-208"><a href="#cb21-208" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Indirect effect (a×b) is credibly </span><span class="sc">{</span>direction<span class="sc">}</span><span class="ss"> (mean = </span><span class="sc">{</span>ab_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb21-209"><a href="#cb21-209" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb21-210"><a href="#cb21-210" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Indirect effect (a×b) is uncertain (HDI includes 0, mean = </span><span class="sc">{</span>ab_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb21-211"><a href="#cb21-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-212"><a href="#cb21-212" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> c_prime_zero:</span>
<span id="cb21-213"><a href="#cb21-213" aria-hidden="true" tabindex="-1"></a>            direction <span class="op">=</span> <span class="st">"positive"</span> <span class="cf">if</span> c_prime_mean <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="st">"negative"</span></span>
<span id="cb21-214"><a href="#cb21-214" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Direct effect (c') is credibly </span><span class="sc">{</span>direction<span class="sc">}</span><span class="ss"> (mean = </span><span class="sc">{</span>c_prime_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb21-215"><a href="#cb21-215" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb21-216"><a href="#cb21-216" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Direct effect (c') is near zero (HDI includes 0, mean = </span><span class="sc">{</span>c_prime_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb21-217"><a href="#cb21-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-218"><a href="#cb21-218" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> c_zero:</span>
<span id="cb21-219"><a href="#cb21-219" aria-hidden="true" tabindex="-1"></a>            direction <span class="op">=</span> <span class="st">"positive"</span> <span class="cf">if</span> c_mean <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="st">"negative"</span></span>
<span id="cb21-220"><a href="#cb21-220" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Total effect (c) is credibly </span><span class="sc">{</span>direction<span class="sc">}</span><span class="ss"> (mean = </span><span class="sc">{</span>c_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb21-221"><a href="#cb21-221" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb21-222"><a href="#cb21-222" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Total effect (c) is uncertain (HDI includes 0, mean = </span><span class="sc">{</span>c_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb21-223"><a href="#cb21-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-224"><a href="#cb21-224" aria-hidden="true" tabindex="-1"></a>        lines.append(<span class="st">""</span>)</span>
<span id="cb21-225"><a href="#cb21-225" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> ab_zero <span class="kw">and</span> c_prime_zero:</span>
<span id="cb21-226"><a href="#cb21-226" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"It appears that </span><span class="sc">{</span>m_label<span class="sc">}</span><span class="ss"> fully mediates the effect of </span><span class="sc">{</span>x_label<span class="sc">}</span><span class="ss"> on </span><span class="sc">{</span>y_label<span class="sc">}</span><span class="ss"> (indirect effect is non-zero while direct effect is near zero)."</span>)</span>
<span id="cb21-227"><a href="#cb21-227" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="kw">not</span> ab_zero <span class="kw">and</span> <span class="kw">not</span> c_prime_zero:</span>
<span id="cb21-228"><a href="#cb21-228" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"It appears that </span><span class="sc">{</span>m_label<span class="sc">}</span><span class="ss"> partially mediates the effect of </span><span class="sc">{</span>x_label<span class="sc">}</span><span class="ss"> on </span><span class="sc">{</span>y_label<span class="sc">}</span><span class="ss"> (both indirect and direct effects are credibly non-zero)."</span>)</span>
<span id="cb21-229"><a href="#cb21-229" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb21-230"><a href="#cb21-230" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="st">"Mediation is unclear or absent (the indirect effect includes zero or the total effect is not clearly different from zero)."</span>)</span>
<span id="cb21-231"><a href="#cb21-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-232"><a href="#cb21-232" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>.join(lines)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Let’s run the mediation analysis for the first two variables.</p>
<div id="a2e4f9fd" class="cell" data-execution_count="22">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>analysis1 <span class="op">=</span> MediationAnalysis(data<span class="op">=</span>scaled_df, x<span class="op">=</span><span class="st">"x1"</span>, m<span class="op">=</span><span class="st">"x2"</span>, y<span class="op">=</span><span class="st">"y"</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>analysis1.build_model()</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>analysis1.fit()</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>analysis1.get_summary()</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(analysis1.get_report())</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>analysis2 <span class="op">=</span> MediationAnalysis(data<span class="op">=</span>scaled_df, x<span class="op">=</span><span class="st">"x1"</span>, m<span class="op">=</span><span class="st">"x3"</span>, y<span class="op">=</span><span class="st">"y"</span>)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>analysis2.build_model()</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>analysis2.fit()</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>analysis2.get_summary()</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(analysis2.get_report())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Great 👏🏻 Based on the following results we can conclude that <span class="math inline">\(x_1\)</span> affects <span class="math inline">\(y\)</span> through <span class="math inline">\(x_2\)</span> and <span class="math inline">\(x_3\)</span> but not directly. This conclusion is based on the indirect effect being significant and the direct effect being near zero when controlling for the mediator <span class="math inline">\(x2\)</span> and partial for <span class="math inline">\(x3\)</span>.</p>
<p>If both factor were present, the indirect effect would be stronger, given the previous results. So, for simplicity, we’ll not test the mediation when both factors are present.</p>
<p>We can again, update our causal graph to reflect the new findings.</p>
<div id="41ec1d3d" class="cell" data-execution_count="23">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize a directed graph</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1 <span class="op">=</span> Digraph()</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Add nodes</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.node(<span class="st">"X1"</span>, <span class="st">"Offline"</span>)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.node(<span class="st">"X2"</span>, <span class="st">"Online"</span>)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.node(<span class="st">"X3"</span>, <span class="st">"Internal"</span>)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.node(<span class="st">"E"</span>, <span class="st">"Exogenous variables"</span>, style<span class="op">=</span><span class="st">"dashed"</span>)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.node(<span class="st">"T"</span>, <span class="st">"Target"</span>)</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.edge(<span class="st">"E"</span>, <span class="st">"T"</span>, style<span class="op">=</span><span class="st">"dashed"</span>)</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.edge(<span class="st">"X1"</span>,<span class="st">"X2"</span>)</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.edge(<span class="st">"X1"</span>,<span class="st">"X3"</span>)</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.edge(<span class="st">"X2"</span>, <span class="st">"T"</span>)</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.edge(<span class="st">"X3"</span>, <span class="st">"T"</span>)</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a figure with five subplots</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>,)</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Set titles for each subplot</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>titles <span class="op">=</span> [<span class="st">"Naive DAG"</span>, <span class="st">"Updated DAG V0"</span>, <span class="st">"Updated DAG V1"</span>]</span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, title <span class="kw">in</span> <span class="bu">zip</span>(axes, titles):</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>    ax.set_title(title, fontsize<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>    ax.axis(<span class="st">'off'</span>)</span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Render and plot each graph</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/naive_dag'</span>)</span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].imshow(mpimg.imread(<span class="st">'images/naive_dag.png'</span>))</span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/updated_dag'</span>)</span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].imshow(mpimg.imread(<span class="st">'images/updated_dag.png'</span>))</span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/updated_dag1'</span>)</span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].imshow(mpimg.imread(<span class="st">'images/updated_dag1.png'</span>))</span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Add main title</span></span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">"Comparison of DAG Graphs"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>This is great! Our new causal graph is more complex, but it is more accurate to the one defined before. Nevertheless, we need a significant amount of time, and manual work to arrive to this conclusion.</p>
<p>How could we automate this process? It’s even possible? and how this would solve the intial problem?</p>
<p>Yes, it is possible! We can use causal discovery algorithms to automate this process.</p>
</section>
<section id="introduction-to-causal-discovery-1" class="level1">
<h1>Introduction to causal discovery</h1>
<p>Causal discovery infers directional cause-and-effect relationships from observational data. It uses computational algorithms to construct directed acyclic graphs that represent potential causal mechanisms. These techniques are based on the causal Markov condition and the assumption of statistical faithfulness. They employ statistical tests for conditional independence to differentiate direct influences from indirect associations. This approach integrates statistical inference and graph theory to model complex systems. Overall, it uncovers hidden causal structures that enhance our understanding and estimations of dynamic phenomena.</p>
<blockquote class="blockquote">
<p>Causal Markov Assumption: Each variable is independent of its non-effects given its direct causes, meaning that the joint probability distribution can be factorized according to the directed acyclic graph structure. This implies that once you condition on a variable’s immediate causes, any further upstream or parallel influences are rendered statistically irrelevant.</p>
</blockquote>
<blockquote class="blockquote">
<p>Statistical Faithfulness: This assumption posits that all and only the conditional independence relations observed in the data are those implied by the causal graph. In other words, there are no accidental cancellations or coincidental independencies beyond what the causal structure predicts.</p>
</blockquote>
<div id="c5dcfc7f" class="cell" data-execution_count="24">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CausalDiscovery:</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data):</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.data <span class="op">=</span> data</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.labels <span class="op">=</span> [<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> col <span class="kw">in</span> data.columns.to_list()]</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> greedy_search(<span class="va">self</span>, <span class="op">**</span>kwargs):</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> ges(X<span class="op">=</span><span class="va">self</span>.data.to_numpy(), <span class="op">**</span>kwargs)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result[<span class="st">"G"</span>]</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> peter_clark(<span class="va">self</span>, <span class="op">**</span>kwargs):</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> pc(<span class="va">self</span>.data.to_numpy(), <span class="op">**</span>kwargs)</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result.G</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> to_pydot(<span class="va">self</span>, graph):</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> GraphUtils.to_pydot(graph, labels<span class="op">=</span><span class="va">self</span>.labels)</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> to_dict(<span class="va">self</span>, graph):</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a><span class="co">        Convert a general graph to a dictionary representation where each node is a key</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a><span class="co">        and the value is a list of its descendants.</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a><span class="co">        graph : causallearn.graph.GeneralGraph.GeneralGraph</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a><span class="co">            The input graph.</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a><span class="co">        dict</span></span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a><span class="co">            A dictionary where keys are node labels and values are lists of descendant node labels.</span></span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> {}</span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>        nodes <span class="op">=</span> <span class="bu">sorted</span>(graph.get_nodes(), key<span class="op">=</span><span class="kw">lambda</span> x: <span class="bu">str</span>(x))</span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Initialize the dictionary with empty lists for all nodes</span></span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, node <span class="kw">in</span> <span class="bu">enumerate</span>(nodes):</span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a>            result[<span class="va">self</span>.labels[i]] <span class="op">=</span> []</span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true" tabindex="-1"></a>        <span class="co"># For each node, find its children (direct descendants)</span></span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, node <span class="kw">in</span> <span class="bu">enumerate</span>(nodes):</span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true" tabindex="-1"></a>            node_label <span class="op">=</span> <span class="va">self</span>.labels[i]</span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j, potential_child <span class="kw">in</span> <span class="bu">enumerate</span>(nodes):</span>
<span id="cb24-43"><a href="#cb24-43" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="op">!=</span> j <span class="kw">and</span> graph.get_edge(node, potential_child) <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb24-44"><a href="#cb24-44" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Check if there's a directed edge from node to potential_child</span></span>
<span id="cb24-45"><a href="#cb24-45" aria-hidden="true" tabindex="-1"></a>                    edge <span class="op">=</span> graph.get_edge(node, potential_child)</span>
<span id="cb24-46"><a href="#cb24-46" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> (edge.get_endpoint1() <span class="op">==</span> Endpoint.TAIL <span class="kw">and</span></span>
<span id="cb24-47"><a href="#cb24-47" aria-hidden="true" tabindex="-1"></a>                        edge.get_endpoint2() <span class="op">==</span> Endpoint.ARROW):</span>
<span id="cb24-48"><a href="#cb24-48" aria-hidden="true" tabindex="-1"></a>                        result[node_label].append(<span class="va">self</span>.labels[j])</span>
<span id="cb24-49"><a href="#cb24-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-50"><a href="#cb24-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result</span>
<span id="cb24-51"><a href="#cb24-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-52"><a href="#cb24-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-53"><a href="#cb24-53" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> to_graphviz(<span class="va">self</span>, graph, handle_circle<span class="op">=</span><span class="st">"skip"</span>):</span>
<span id="cb24-54"><a href="#cb24-54" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb24-55"><a href="#cb24-55" aria-hidden="true" tabindex="-1"></a><span class="co">        Convert a general graph into a Graphviz Digraph using the pydot conversion</span></span>
<span id="cb24-56"><a href="#cb24-56" aria-hidden="true" tabindex="-1"></a><span class="co">        for nodes while preserving the original directed edge ordering.</span></span>
<span id="cb24-57"><a href="#cb24-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-58"><a href="#cb24-58" aria-hidden="true" tabindex="-1"></a><span class="co">        Only if the original graph indicates that an edge is undirected (both endpoints</span></span>
<span id="cb24-59"><a href="#cb24-59" aria-hidden="true" tabindex="-1"></a><span class="co">        are TAIL) do we override the arrow style (using dir="none"). Otherwise, we leave</span></span>
<span id="cb24-60"><a href="#cb24-60" aria-hidden="true" tabindex="-1"></a><span class="co">        the pydot-provided direction unchanged.</span></span>
<span id="cb24-61"><a href="#cb24-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-62"><a href="#cb24-62" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb24-63"><a href="#cb24-63" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb24-64"><a href="#cb24-64" aria-hidden="true" tabindex="-1"></a><span class="co">        graph : causallearn.graph.GeneralGraph.GeneralGraph</span></span>
<span id="cb24-65"><a href="#cb24-65" aria-hidden="true" tabindex="-1"></a><span class="co">            The input graph.</span></span>
<span id="cb24-66"><a href="#cb24-66" aria-hidden="true" tabindex="-1"></a><span class="co">        handle_circle : str, optional</span></span>
<span id="cb24-67"><a href="#cb24-67" aria-hidden="true" tabindex="-1"></a><span class="co">            How to handle circle endpoints (not used explicitly here but available for future logic).</span></span>
<span id="cb24-68"><a href="#cb24-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-69"><a href="#cb24-69" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb24-70"><a href="#cb24-70" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb24-71"><a href="#cb24-71" aria-hidden="true" tabindex="-1"></a><span class="co">        graphviz.Digraph</span></span>
<span id="cb24-72"><a href="#cb24-72" aria-hidden="true" tabindex="-1"></a><span class="co">            A Graphviz Digraph where undirected edges are rendered without arrowheads.</span></span>
<span id="cb24-73"><a href="#cb24-73" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb24-74"><a href="#cb24-74" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Get the pydot graph (for node positions/labels)</span></span>
<span id="cb24-75"><a href="#cb24-75" aria-hidden="true" tabindex="-1"></a>        dot <span class="op">=</span> <span class="va">self</span>.to_pydot(graph)</span>
<span id="cb24-76"><a href="#cb24-76" aria-hidden="true" tabindex="-1"></a>        digraph <span class="op">=</span> Digraph()</span>
<span id="cb24-77"><a href="#cb24-77" aria-hidden="true" tabindex="-1"></a>        digraph.attr(size<span class="op">=</span><span class="st">'8,8'</span>)</span>
<span id="cb24-78"><a href="#cb24-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-79"><a href="#cb24-79" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Build a mapping of the original graph nodes based on sorted order.</span></span>
<span id="cb24-80"><a href="#cb24-80" aria-hidden="true" tabindex="-1"></a>        original_nodes <span class="op">=</span> <span class="bu">sorted</span>(graph.get_nodes(), key<span class="op">=</span><span class="kw">lambda</span> x: <span class="bu">str</span>(x))</span>
<span id="cb24-81"><a href="#cb24-81" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Map string indices ("0", "1", …) to the original nodes.</span></span>
<span id="cb24-82"><a href="#cb24-82" aria-hidden="true" tabindex="-1"></a>        index_to_node <span class="op">=</span> {<span class="bu">str</span>(i): node <span class="cf">for</span> i, node <span class="kw">in</span> <span class="bu">enumerate</span>(original_nodes)}</span>
<span id="cb24-83"><a href="#cb24-83" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Map indices to labels using self.labels.</span></span>
<span id="cb24-84"><a href="#cb24-84" aria-hidden="true" tabindex="-1"></a>        node_labels <span class="op">=</span> {<span class="bu">str</span>(i): <span class="va">self</span>.labels[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(original_nodes))}</span>
<span id="cb24-85"><a href="#cb24-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-86"><a href="#cb24-86" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add nodes to the Graphviz Digraph.</span></span>
<span id="cb24-87"><a href="#cb24-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> idx_str, label <span class="kw">in</span> node_labels.items():</span>
<span id="cb24-88"><a href="#cb24-88" aria-hidden="true" tabindex="-1"></a>            digraph.node(label)</span>
<span id="cb24-89"><a href="#cb24-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-90"><a href="#cb24-90" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Process each edge from the pydot graph.</span></span>
<span id="cb24-91"><a href="#cb24-91" aria-hidden="true" tabindex="-1"></a>        processed <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb24-92"><a href="#cb24-92" aria-hidden="true" tabindex="-1"></a>        pydot_edges <span class="op">=</span> dot.get_edges()</span>
<span id="cb24-93"><a href="#cb24-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-94"><a href="#cb24-94" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> edge <span class="kw">in</span> pydot_edges:</span>
<span id="cb24-95"><a href="#cb24-95" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Get source and destination from pydot.</span></span>
<span id="cb24-96"><a href="#cb24-96" aria-hidden="true" tabindex="-1"></a>            src_raw <span class="op">=</span> edge.get_source()</span>
<span id="cb24-97"><a href="#cb24-97" aria-hidden="true" tabindex="-1"></a>            dst_raw <span class="op">=</span> edge.get_destination()</span>
<span id="cb24-98"><a href="#cb24-98" aria-hidden="true" tabindex="-1"></a>            src_str <span class="op">=</span> src_raw.strip(<span class="st">'"'</span>) <span class="cf">if</span> <span class="bu">isinstance</span>(src_raw, <span class="bu">str</span>) <span class="cf">else</span> <span class="bu">str</span>(src_raw)</span>
<span id="cb24-99"><a href="#cb24-99" aria-hidden="true" tabindex="-1"></a>            dst_str <span class="op">=</span> dst_raw.strip(<span class="st">'"'</span>) <span class="cf">if</span> <span class="bu">isinstance</span>(dst_raw, <span class="bu">str</span>) <span class="cf">else</span> <span class="bu">str</span>(dst_raw)</span>
<span id="cb24-100"><a href="#cb24-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-101"><a href="#cb24-101" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Get original node objects using our mapping.</span></span>
<span id="cb24-102"><a href="#cb24-102" aria-hidden="true" tabindex="-1"></a>            src_node <span class="op">=</span> index_to_node.get(src_str)</span>
<span id="cb24-103"><a href="#cb24-103" aria-hidden="true" tabindex="-1"></a>            dst_node <span class="op">=</span> index_to_node.get(dst_str)</span>
<span id="cb24-104"><a href="#cb24-104" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> src_node <span class="kw">is</span> <span class="va">None</span> <span class="kw">or</span> dst_node <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb24-105"><a href="#cb24-105" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb24-106"><a href="#cb24-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-107"><a href="#cb24-107" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Get display labels.</span></span>
<span id="cb24-108"><a href="#cb24-108" aria-hidden="true" tabindex="-1"></a>            src_label <span class="op">=</span> node_labels.get(src_str, src_str)</span>
<span id="cb24-109"><a href="#cb24-109" aria-hidden="true" tabindex="-1"></a>            dst_label <span class="op">=</span> node_labels.get(dst_str, dst_str)</span>
<span id="cb24-110"><a href="#cb24-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-111"><a href="#cb24-111" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Use a tuple (src_str, dst_str) to ensure we don't add duplicates.</span></span>
<span id="cb24-112"><a href="#cb24-112" aria-hidden="true" tabindex="-1"></a>            edge_key <span class="op">=</span> (src_str, dst_str)</span>
<span id="cb24-113"><a href="#cb24-113" aria-hidden="true" tabindex="-1"></a>            reverse_key <span class="op">=</span> (dst_str, src_str)</span>
<span id="cb24-114"><a href="#cb24-114" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> edge_key <span class="kw">in</span> processed <span class="kw">or</span> reverse_key <span class="kw">in</span> processed:</span>
<span id="cb24-115"><a href="#cb24-115" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb24-116"><a href="#cb24-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-117"><a href="#cb24-117" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb24-118"><a href="#cb24-118" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Get endpoint information from the original graph.</span></span>
<span id="cb24-119"><a href="#cb24-119" aria-hidden="true" tabindex="-1"></a>                e_uv <span class="op">=</span> graph.get_endpoint(src_node, dst_node)</span>
<span id="cb24-120"><a href="#cb24-120" aria-hidden="true" tabindex="-1"></a>                e_vu <span class="op">=</span> graph.get_endpoint(dst_node, src_node)</span>
<span id="cb24-121"><a href="#cb24-121" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span> <span class="pp">KeyError</span>:</span>
<span id="cb24-122"><a href="#cb24-122" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Skip if the original graph doesn't contain this edge.</span></span>
<span id="cb24-123"><a href="#cb24-123" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb24-124"><a href="#cb24-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-125"><a href="#cb24-125" aria-hidden="true" tabindex="-1"></a>            <span class="co"># If both endpoints are TAIL, we treat the edge as undirected.</span></span>
<span id="cb24-126"><a href="#cb24-126" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> e_uv <span class="op">==</span> Endpoint.TAIL <span class="kw">and</span> e_vu <span class="op">==</span> Endpoint.TAIL:</span>
<span id="cb24-127"><a href="#cb24-127" aria-hidden="true" tabindex="-1"></a>                digraph.edge(src_label, dst_label, <span class="bu">dir</span><span class="op">=</span><span class="st">"none"</span>)</span>
<span id="cb24-128"><a href="#cb24-128" aria-hidden="true" tabindex="-1"></a>                processed.add(edge_key)</span>
<span id="cb24-129"><a href="#cb24-129" aria-hidden="true" tabindex="-1"></a>                processed.add(reverse_key)</span>
<span id="cb24-130"><a href="#cb24-130" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb24-131"><a href="#cb24-131" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Otherwise, preserve the original pydot direction.</span></span>
<span id="cb24-132"><a href="#cb24-132" aria-hidden="true" tabindex="-1"></a>                digraph.edge(src_label, dst_label)</span>
<span id="cb24-133"><a href="#cb24-133" aria-hidden="true" tabindex="-1"></a>                processed.add(edge_key)</span>
<span id="cb24-134"><a href="#cb24-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-135"><a href="#cb24-135" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> digraph</span>
<span id="cb24-136"><a href="#cb24-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-137"><a href="#cb24-137" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> to_networkx(<span class="va">self</span>, graph) <span class="op">-&gt;</span> nx.DiGraph:</span>
<span id="cb24-138"><a href="#cb24-138" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb24-139"><a href="#cb24-139" aria-hidden="true" tabindex="-1"></a><span class="co">        Convert a general graph (e.g. from causallearn) into a NetworkX DiGraph.</span></span>
<span id="cb24-140"><a href="#cb24-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-141"><a href="#cb24-141" aria-hidden="true" tabindex="-1"></a><span class="co">        Nodes are added as provided by graph.get_nodes(), and for each ordered pair (u, v)</span></span>
<span id="cb24-142"><a href="#cb24-142" aria-hidden="true" tabindex="-1"></a><span class="co">        where an edge exists (as determined by graph.get_endpoint(u, v)), we add a directed</span></span>
<span id="cb24-143"><a href="#cb24-143" aria-hidden="true" tabindex="-1"></a><span class="co">        edge with an attribute 'endpoint' that stores the edge marker.</span></span>
<span id="cb24-144"><a href="#cb24-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-145"><a href="#cb24-145" aria-hidden="true" tabindex="-1"></a><span class="co">        If the general graph does not provide a direct list of edges (e.g. via a get_edges() method),</span></span>
<span id="cb24-146"><a href="#cb24-146" aria-hidden="true" tabindex="-1"></a><span class="co">        we iterate over all pairs of nodes.</span></span>
<span id="cb24-147"><a href="#cb24-147" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb24-148"><a href="#cb24-148" aria-hidden="true" tabindex="-1"></a>        digraph <span class="op">=</span> nx.DiGraph()</span>
<span id="cb24-149"><a href="#cb24-149" aria-hidden="true" tabindex="-1"></a>        nodes <span class="op">=</span> graph.get_nodes()</span>
<span id="cb24-150"><a href="#cb24-150" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add nodes to the networkx graph.</span></span>
<span id="cb24-151"><a href="#cb24-151" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> node <span class="kw">in</span> nodes:</span>
<span id="cb24-152"><a href="#cb24-152" aria-hidden="true" tabindex="-1"></a>            digraph.add_node(node)</span>
<span id="cb24-153"><a href="#cb24-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-154"><a href="#cb24-154" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If available, use a dedicated method to get edges.</span></span>
<span id="cb24-155"><a href="#cb24-155" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb24-156"><a href="#cb24-156" aria-hidden="true" tabindex="-1"></a>            edges <span class="op">=</span> graph.get_edges()</span>
<span id="cb24-157"><a href="#cb24-157" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">AttributeError</span>:</span>
<span id="cb24-158"><a href="#cb24-158" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Fallback: iterate over all ordered pairs (inefficient for large graphs)</span></span>
<span id="cb24-159"><a href="#cb24-159" aria-hidden="true" tabindex="-1"></a>            edges <span class="op">=</span> []</span>
<span id="cb24-160"><a href="#cb24-160" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> u <span class="kw">in</span> nodes:</span>
<span id="cb24-161"><a href="#cb24-161" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> v <span class="kw">in</span> nodes:</span>
<span id="cb24-162"><a href="#cb24-162" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> u <span class="op">==</span> v:</span>
<span id="cb24-163"><a href="#cb24-163" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">continue</span></span>
<span id="cb24-164"><a href="#cb24-164" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">try</span>:</span>
<span id="cb24-165"><a href="#cb24-165" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Attempt to get an endpoint; if present, we consider that an edge exists.</span></span>
<span id="cb24-166"><a href="#cb24-166" aria-hidden="true" tabindex="-1"></a>                        _ <span class="op">=</span> graph.get_endpoint(u, v)</span>
<span id="cb24-167"><a href="#cb24-167" aria-hidden="true" tabindex="-1"></a>                        edges.append((u, v))</span>
<span id="cb24-168"><a href="#cb24-168" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">except</span> <span class="pp">KeyError</span>:</span>
<span id="cb24-169"><a href="#cb24-169" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">continue</span></span>
<span id="cb24-170"><a href="#cb24-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-171"><a href="#cb24-171" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add edges with endpoint attributes.</span></span>
<span id="cb24-172"><a href="#cb24-172" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> u, v <span class="kw">in</span> edges:</span>
<span id="cb24-173"><a href="#cb24-173" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb24-174"><a href="#cb24-174" aria-hidden="true" tabindex="-1"></a>                endpoint_uv <span class="op">=</span> graph.get_endpoint(u, v)</span>
<span id="cb24-175"><a href="#cb24-175" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span> <span class="pp">KeyError</span>:</span>
<span id="cb24-176"><a href="#cb24-176" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb24-177"><a href="#cb24-177" aria-hidden="true" tabindex="-1"></a>            digraph.add_edge(u, v, endpoint<span class="op">=</span>endpoint_uv)</span>
<span id="cb24-178"><a href="#cb24-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-179"><a href="#cb24-179" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> digraph</span>
<span id="cb24-180"><a href="#cb24-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-181"><a href="#cb24-181" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _networkx_to_graphviz(<span class="va">self</span>, nx_graph: nx.DiGraph) <span class="op">-&gt;</span> Digraph:</span>
<span id="cb24-182"><a href="#cb24-182" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb24-183"><a href="#cb24-183" aria-hidden="true" tabindex="-1"></a><span class="co">        Convert a NetworkX DiGraph into a Graphviz Digraph.</span></span>
<span id="cb24-184"><a href="#cb24-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-185"><a href="#cb24-185" aria-hidden="true" tabindex="-1"></a><span class="co">        This method uses similar logic to 'to_graphviz', checking for reciprocal edges.</span></span>
<span id="cb24-186"><a href="#cb24-186" aria-hidden="true" tabindex="-1"></a><span class="co">        If an edge (u,v) and its reverse (v,u) exist and both have the attribute endpoint</span></span>
<span id="cb24-187"><a href="#cb24-187" aria-hidden="true" tabindex="-1"></a><span class="co">        equal to Endpoint.TAIL, the edge is rendered as undirected (dir="none").</span></span>
<span id="cb24-188"><a href="#cb24-188" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb24-189"><a href="#cb24-189" aria-hidden="true" tabindex="-1"></a>        digraph <span class="op">=</span> Digraph()</span>
<span id="cb24-190"><a href="#cb24-190" aria-hidden="true" tabindex="-1"></a>        digraph.attr(size<span class="op">=</span><span class="st">'8,8'</span>)</span>
<span id="cb24-191"><a href="#cb24-191" aria-hidden="true" tabindex="-1"></a>        processed <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb24-192"><a href="#cb24-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-193"><a href="#cb24-193" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sort nodes to create a consistent mapping with self.labels.</span></span>
<span id="cb24-194"><a href="#cb24-194" aria-hidden="true" tabindex="-1"></a>        sorted_nodes <span class="op">=</span> <span class="bu">sorted</span>(nx_graph.nodes(), key<span class="op">=</span><span class="kw">lambda</span> x: <span class="bu">str</span>(x))</span>
<span id="cb24-195"><a href="#cb24-195" aria-hidden="true" tabindex="-1"></a>        node_labels <span class="op">=</span> {}</span>
<span id="cb24-196"><a href="#cb24-196" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, node <span class="kw">in</span> <span class="bu">enumerate</span>(sorted_nodes):</span>
<span id="cb24-197"><a href="#cb24-197" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Use self.labels if available, otherwise default to the node's string representation.</span></span>
<span id="cb24-198"><a href="#cb24-198" aria-hidden="true" tabindex="-1"></a>            label <span class="op">=</span> <span class="va">self</span>.labels[i] <span class="cf">if</span> i <span class="op">&lt;</span> <span class="bu">len</span>(<span class="va">self</span>.labels) <span class="cf">else</span> <span class="bu">str</span>(node)</span>
<span id="cb24-199"><a href="#cb24-199" aria-hidden="true" tabindex="-1"></a>            node_labels[node] <span class="op">=</span> label</span>
<span id="cb24-200"><a href="#cb24-200" aria-hidden="true" tabindex="-1"></a>            digraph.node(label)</span>
<span id="cb24-201"><a href="#cb24-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-202"><a href="#cb24-202" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> u, v <span class="kw">in</span> nx_graph.edges():</span>
<span id="cb24-203"><a href="#cb24-203" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (u, v) <span class="kw">in</span> processed <span class="kw">or</span> (v, u) <span class="kw">in</span> processed:</span>
<span id="cb24-204"><a href="#cb24-204" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb24-205"><a href="#cb24-205" aria-hidden="true" tabindex="-1"></a>            src_label <span class="op">=</span> node_labels.get(u, <span class="bu">str</span>(u))</span>
<span id="cb24-206"><a href="#cb24-206" aria-hidden="true" tabindex="-1"></a>            dst_label <span class="op">=</span> node_labels.get(v, <span class="bu">str</span>(v))</span>
<span id="cb24-207"><a href="#cb24-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-208"><a href="#cb24-208" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Check if the reverse edge exists to potentially mark as undirected.</span></span>
<span id="cb24-209"><a href="#cb24-209" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nx_graph.has_edge(v, u):</span>
<span id="cb24-210"><a href="#cb24-210" aria-hidden="true" tabindex="-1"></a>                endpoint_uv <span class="op">=</span> nx_graph.edges[u, v].get(<span class="st">'endpoint'</span>, <span class="va">None</span>)</span>
<span id="cb24-211"><a href="#cb24-211" aria-hidden="true" tabindex="-1"></a>                endpoint_vu <span class="op">=</span> nx_graph.edges[v, u].get(<span class="st">'endpoint'</span>, <span class="va">None</span>)</span>
<span id="cb24-212"><a href="#cb24-212" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> endpoint_uv <span class="op">==</span> Endpoint.TAIL <span class="kw">and</span> endpoint_vu <span class="op">==</span> Endpoint.TAIL:</span>
<span id="cb24-213"><a href="#cb24-213" aria-hidden="true" tabindex="-1"></a>                    digraph.edge(src_label, dst_label, <span class="bu">dir</span><span class="op">=</span><span class="st">"none"</span>)</span>
<span id="cb24-214"><a href="#cb24-214" aria-hidden="true" tabindex="-1"></a>                    processed.add((u, v))</span>
<span id="cb24-215"><a href="#cb24-215" aria-hidden="true" tabindex="-1"></a>                    processed.add((v, u))</span>
<span id="cb24-216"><a href="#cb24-216" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">continue</span></span>
<span id="cb24-217"><a href="#cb24-217" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Otherwise, add the edge as directed.</span></span>
<span id="cb24-218"><a href="#cb24-218" aria-hidden="true" tabindex="-1"></a>            digraph.edge(src_label, dst_label)</span>
<span id="cb24-219"><a href="#cb24-219" aria-hidden="true" tabindex="-1"></a>            processed.add((u, v))</span>
<span id="cb24-220"><a href="#cb24-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-221"><a href="#cb24-221" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> digraph</span>
<span id="cb24-222"><a href="#cb24-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-223"><a href="#cb24-223" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _graphviz_to_networkx(<span class="va">self</span>, gv_graph: Digraph) <span class="op">-&gt;</span> nx.DiGraph:</span>
<span id="cb24-224"><a href="#cb24-224" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb24-225"><a href="#cb24-225" aria-hidden="true" tabindex="-1"></a><span class="co">        Convert a Graphviz Digraph into a NetworkX DiGraph.</span></span>
<span id="cb24-226"><a href="#cb24-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-227"><a href="#cb24-227" aria-hidden="true" tabindex="-1"></a><span class="co">        This method extracts the DOT source from the provided Graphviz Digraph,</span></span>
<span id="cb24-228"><a href="#cb24-228" aria-hidden="true" tabindex="-1"></a><span class="co">        parses it using pydot, and then converts the resulting pydot graph into</span></span>
<span id="cb24-229"><a href="#cb24-229" aria-hidden="true" tabindex="-1"></a><span class="co">        a NetworkX directed graph. This ensures that node labels and edge orientations</span></span>
<span id="cb24-230"><a href="#cb24-230" aria-hidden="true" tabindex="-1"></a><span class="co">        are maintained consistently.</span></span>
<span id="cb24-231"><a href="#cb24-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-232"><a href="#cb24-232" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb24-233"><a href="#cb24-233" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb24-234"><a href="#cb24-234" aria-hidden="true" tabindex="-1"></a><span class="co">        gv_graph : graphviz.Digraph</span></span>
<span id="cb24-235"><a href="#cb24-235" aria-hidden="true" tabindex="-1"></a><span class="co">            The Graphviz Digraph to be converted.</span></span>
<span id="cb24-236"><a href="#cb24-236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-237"><a href="#cb24-237" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb24-238"><a href="#cb24-238" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb24-239"><a href="#cb24-239" aria-hidden="true" tabindex="-1"></a><span class="co">        nx.DiGraph</span></span>
<span id="cb24-240"><a href="#cb24-240" aria-hidden="true" tabindex="-1"></a><span class="co">            A NetworkX DiGraph representation of the input Graphviz graph.</span></span>
<span id="cb24-241"><a href="#cb24-241" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb24-242"><a href="#cb24-242" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Retrieve the DOT source code from the Graphviz Digraph.</span></span>
<span id="cb24-243"><a href="#cb24-243" aria-hidden="true" tabindex="-1"></a>        dot_str <span class="op">=</span> gv_graph.source</span>
<span id="cb24-244"><a href="#cb24-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-245"><a href="#cb24-245" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Parse the DOT data using pydot.</span></span>
<span id="cb24-246"><a href="#cb24-246" aria-hidden="true" tabindex="-1"></a>        pydot_graphs <span class="op">=</span> pydot.graph_from_dot_data(dot_str)</span>
<span id="cb24-247"><a href="#cb24-247" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> pydot_graphs:</span>
<span id="cb24-248"><a href="#cb24-248" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"No valid pydot graphs could be parsed from the DOT data."</span>)</span>
<span id="cb24-249"><a href="#cb24-249" aria-hidden="true" tabindex="-1"></a>        <span class="co"># pydot.graph_from_dot_data returns a list; we take the first one.</span></span>
<span id="cb24-250"><a href="#cb24-250" aria-hidden="true" tabindex="-1"></a>        pydot_graph <span class="op">=</span> pydot_graphs[<span class="dv">0</span>]</span>
<span id="cb24-251"><a href="#cb24-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-252"><a href="#cb24-252" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Use NetworkX’s built-in conversion from a pydot graph to a DiGraph.</span></span>
<span id="cb24-253"><a href="#cb24-253" aria-hidden="true" tabindex="-1"></a>        nx_graph <span class="op">=</span> nx.nx_pydot.from_pydot(pydot_graph)</span>
<span id="cb24-254"><a href="#cb24-254" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> nx_graph</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Causal Learn allows use to use different algorithms to infer the markov equivalent class of the causal graph. The previous class is a wrapper that allows us to use the different algorithms implemented in the causal learn library, and plot them more easily.</p>
<p>Currently we wrap the following algorithms:</p>
<ul>
<li>Greedy Search (GES)</li>
<li>Peter-Clark (PC)</li>
</ul>
<section id="causal-discovery-algorithms" class="level2 callout-info">
<h2 class="anchored" data-anchor-id="causal-discovery-algorithms">Causal Discovery Algorithms</h2>
<p>The <strong>Peter-Clark algorithm</strong> is a constraint-based method that infers causal structures from observational data using conditional independence tests. It starts with a fully connected undirected graph where every variable is initially connected to every other variable. The algorithm systematically tests conditional independence between pairs of variables, conditioning on increasingly larger subsets of other variables. When a conditional independence is detected, the corresponding edge is removed from the graph.</p>
<p>On the other hand, <strong>Greedy Search</strong> is a score-based method that iteratively improves a candidate causal model by locally modifying its structure. It begins with an initial directed acyclic graph and evaluates a scoring metric that balances goodness-of-fit with model complexity. The algorithm explores modifications such as adding, deleting, or reversing edges to find local improvements in the score. At each iteration, it selects the change that produces the highest increase in the score, following a step-by-step improvement strategy. The search continues until no single modification can further enhance the model’s score. This method efficiently navigates the combinatorial search space of possible graphs by making locally optimal choices.</p>
</section>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Causal Sufficiency Assumption
</div>
</div>
<div class="callout-body-container callout-body">
<p>Any causal discovery algorithm is based on the assumption that all the relevant variables are observed. If some relevant variable is not observed, the algorithm will not be able to infer the correct causal graph. Each variable, even the unobserved ones, should be represented in the dataset, so the algorithm can include them in the causal graph and validation tests.</p>
</div>
</div>
<p>The following example shows the causal graph inferred using the Greedy Search algorithm.</p>
<div id="d8ebd951" class="cell" data-execution_count="25">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>causal_model <span class="op">=</span> CausalDiscovery(scaled_df[[<span class="st">"holiday_signal"</span>, <span class="st">"inflation"</span>, <span class="st">"x1"</span>, <span class="st">"x2"</span>, <span class="st">"x3"</span>, <span class="st">"y"</span>]])</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>ges_graph <span class="op">=</span> causal_model.greedy_search()</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a figure with five subplots</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">4</span>,)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Set titles for each subplot</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>titles <span class="op">=</span> [<span class="st">"Naive DAG"</span>, <span class="st">"Updated DAG"</span>, <span class="st">"Updated DAG 1"</span>, <span class="st">"Discovered DAG"</span>]</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, title <span class="kw">in</span> <span class="bu">zip</span>(axes, titles):</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    ax.set_title(title, fontsize<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    ax.axis(<span class="st">'off'</span>)</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Render and plot each graph</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/naive_dag'</span>)</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].imshow(mpimg.imread(<span class="st">'images/naive_dag.png'</span>))</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/updated_dag'</span>)</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].imshow(mpimg.imread(<span class="st">'images/updated_dag.png'</span>))</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/updated_dag1'</span>)</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].imshow(mpimg.imread(<span class="st">'images/updated_dag1.png'</span>))</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>real_dag_graph <span class="op">=</span> causal_model.to_graphviz(ges_graph)</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>real_dag_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/discovered_dag'</span>)</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>].imshow(mpimg.imread(<span class="st">'images/discovered_dag.png'</span>))</span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Add main title</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">"Comparison of DAG Graphs"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The causal graph capture by greedy search is very similar to the true causal graph. Some arrows are directed to variables that are not related, but this is expected given the nature of the data, we still have noise in the data, and sporious correlations that can’t be fully falsify by the independence tests. Additionally, the finded graph can lie in the markov equivalence class of the true causal graph, meaning that there are multiple DAGs that are compatible with the data.</p>
<p>This instead of being a problem, is a great news because we can now start to work with experimentation to test the current structure, and improve it iteratively, without the need to wait for these answers to get the right estimates in a regression model.</p>
<p>Let’s break down the causal paths from x2 to y in the graph:</p>
<p><strong>Confounding paths:</strong></p>
<ul>
<li>Holiday: Affects both x2 and y (holiday → x2 and holiday → y).</li>
<li>Inflation: Affects both x2 and y (inflation → x2 and inflation → y).</li>
<li>x1: Influences x2 (x1 → x2) and also affects y indirectly through x3 (x1 → x3 → y).</li>
</ul>
<p><strong>Mediating path:</strong></p>
<ul>
<li>x3: Lies on the causal pathway from x2 to y (x2 → x3 → y).</li>
</ul>
<p><strong>What needs to be controlled?</strong></p>
<p>To estimate the total effect of x2 on y without bias, you need to block all backdoor (confounding) paths. This means controlling for the common causes:</p>
<ul>
<li>Holiday</li>
<li>Inflation</li>
<li>x1</li>
</ul>
<p><strong>Why not control for x3?</strong> Since x3 is a mediator (i.e., it transmits part of the effect of x2 to y), including it in your regression would block the indirect effect of x2 on y. This “over-control” would result in an estimate that reflects only the direct effect of x2 on y, not the total effect. Additionally, controlling for mediators can sometimes introduce bias if there are other complex relationships in the graph.</p>
<div id="20cfab48" class="cell" data-execution_count="26">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>mmm <span class="op">=</span> MMM(</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    model_config<span class="op">=</span>model_config,</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    date_column<span class="op">=</span><span class="st">"date"</span>,</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    channel_columns<span class="op">=</span>[</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"x1"</span>,</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># "x2",</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">"x3"</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    control_columns<span class="op">=</span>[</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">"holiday_signal"</span>,</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>        <span class="st">"inflation"</span>,</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    adstock<span class="op">=</span>GeometricAdstock(l_max<span class="op">=</span><span class="dv">24</span>),</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    saturation<span class="op">=</span>MichaelisMentenSaturation(),</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>mmm.fit(X, y, <span class="op">**</span>fit_kwargs)</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>mmm.sample_posterior_predictive(</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>X,</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>    extend_idata<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>    combined<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>    random_seed<span class="op">=</span>rng,</span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>initial_model_recover_effect <span class="op">=</span> (</span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a>    az.hdi(mmm.fit_result[<span class="st">"channel_contributions"</span>], hdi_prob<span class="op">=</span><span class="fl">0.95</span>)</span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> mmm.target_transformer[<span class="st">"scaler"</span>].scale_.item()</span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a>initial_model_mean_effect <span class="op">=</span> (</span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a>    mmm.fit_result.channel_contributions.mean(dim<span class="op">=</span>[<span class="st">"chain"</span>, <span class="st">"draw"</span>])</span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> mmm.target_transformer[<span class="st">"scaler"</span>].scale_.item()</span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Now let’s plot the posterior distribution of the effect of x3 on y.</p>
<div id="826dda52" class="cell" data-execution_count="27">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_posterior(y_real, posterior, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>), path_color<span class="op">=</span><span class="st">'orange'</span>, hist_color<span class="op">=</span><span class="st">'orange'</span>, <span class="op">**</span>kwargs):</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Plot the posterior distribution of a stochastic process.</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="co">    y_real : array-like</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="co">        The real values to compare against the posterior.</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="co">    posterior : xarray.DataArray</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="co">        The posterior distribution with shape (draw, chain, date).</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="co">    figsize : tuple, optional</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="co">        Size of the figure. Default is (8, 4).</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a><span class="co">    path_color : str, optional</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a><span class="co">        Color of the paths in the time series plot. Default is 'orange'.</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a><span class="co">    hist_color : str, optional</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a><span class="co">        Color of the histogram. Default is 'orange'.</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a><span class="co">    **kwargs : dict</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a><span class="co">        Additional keyword arguments to pass to the plotting functions.</span></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a><span class="co">    fig : matplotlib.figure.Figure</span></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a><span class="co">        The figure object containing the plots.</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the expected value (mean) across all draws and chains for each date</span></span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>    expected_value <span class="op">=</span> posterior.mean(dim<span class="op">=</span>(<span class="st">"draw"</span>, <span class="st">"chain"</span>))</span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a figure and a grid of subplots</span></span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a>    fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>figsize)</span>
<span id="cb27-31"><a href="#cb27-31" aria-hidden="true" tabindex="-1"></a>    gs <span class="op">=</span> fig.add_gridspec(<span class="dv">1</span>, <span class="dv">2</span>, width_ratios<span class="op">=</span>[<span class="dv">3</span>, <span class="dv">1</span>])</span>
<span id="cb27-32"><a href="#cb27-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-33"><a href="#cb27-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Time series plot</span></span>
<span id="cb27-34"><a href="#cb27-34" aria-hidden="true" tabindex="-1"></a>    ax1 <span class="op">=</span> fig.add_subplot(gs[<span class="dv">0</span>])</span>
<span id="cb27-35"><a href="#cb27-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> chain <span class="kw">in</span> <span class="bu">range</span>(posterior.shape[<span class="dv">1</span>]):</span>
<span id="cb27-36"><a href="#cb27-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> draw <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, posterior.shape[<span class="dv">0</span>], <span class="dv">10</span>):  <span class="co"># Plot every 10th draw for performance</span></span>
<span id="cb27-37"><a href="#cb27-37" aria-hidden="true" tabindex="-1"></a>            ax1.plot(posterior.date, posterior[draw, chain], color<span class="op">=</span>path_color, alpha<span class="op">=</span><span class="fl">0.1</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb27-38"><a href="#cb27-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-39"><a href="#cb27-39" aria-hidden="true" tabindex="-1"></a>    ax1.plot(posterior.date, expected_value, color<span class="op">=</span><span class="st">'grey'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb27-40"><a href="#cb27-40" aria-hidden="true" tabindex="-1"></a>    ax1.plot(posterior.date, y_real, color<span class="op">=</span><span class="st">'black'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Real'</span>,)</span>
<span id="cb27-41"><a href="#cb27-41" aria-hidden="true" tabindex="-1"></a>    ax1.set_title(<span class="st">"Posterior Predictive"</span>)</span>
<span id="cb27-42"><a href="#cb27-42" aria-hidden="true" tabindex="-1"></a>    ax1.set_xlabel(<span class="st">'Date'</span>)</span>
<span id="cb27-43"><a href="#cb27-43" aria-hidden="true" tabindex="-1"></a>    ax1.set_ylabel(<span class="st">'Value'</span>)</span>
<span id="cb27-44"><a href="#cb27-44" aria-hidden="true" tabindex="-1"></a>    ax1.grid(<span class="va">True</span>)</span>
<span id="cb27-45"><a href="#cb27-45" aria-hidden="true" tabindex="-1"></a>    ax1.legend()</span>
<span id="cb27-46"><a href="#cb27-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-47"><a href="#cb27-47" aria-hidden="true" tabindex="-1"></a>    <span class="co"># KDE plot</span></span>
<span id="cb27-48"><a href="#cb27-48" aria-hidden="true" tabindex="-1"></a>    ax2 <span class="op">=</span> fig.add_subplot(gs[<span class="dv">1</span>])</span>
<span id="cb27-49"><a href="#cb27-49" aria-hidden="true" tabindex="-1"></a>    final_values <span class="op">=</span> posterior[:, :, <span class="op">-</span><span class="dv">1</span>].values.flatten()</span>
<span id="cb27-50"><a href="#cb27-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-51"><a href="#cb27-51" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Use seaborn for KDE plot</span></span>
<span id="cb27-52"><a href="#cb27-52" aria-hidden="true" tabindex="-1"></a>    sns.kdeplot(y<span class="op">=</span>final_values, ax<span class="op">=</span>ax2, fill<span class="op">=</span><span class="va">True</span>, color<span class="op">=</span>hist_color, alpha<span class="op">=</span><span class="fl">0.6</span>, <span class="op">**</span>kwargs)</span>
<span id="cb27-53"><a href="#cb27-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-54"><a href="#cb27-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add histogram on top of KDE</span></span>
<span id="cb27-55"><a href="#cb27-55" aria-hidden="true" tabindex="-1"></a>    ax2.hist(final_values, orientation<span class="op">=</span><span class="st">'horizontal'</span>, color<span class="op">=</span>hist_color, bins<span class="op">=</span><span class="dv">30</span>,</span>
<span id="cb27-56"><a href="#cb27-56" aria-hidden="true" tabindex="-1"></a>             alpha<span class="op">=</span><span class="fl">0.3</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb27-57"><a href="#cb27-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-58"><a href="#cb27-58" aria-hidden="true" tabindex="-1"></a>    ax2.axhline(y<span class="op">=</span>expected_value[<span class="op">-</span><span class="dv">1</span>], color<span class="op">=</span><span class="st">'grey'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb27-59"><a href="#cb27-59" aria-hidden="true" tabindex="-1"></a>    ax2.set_title(<span class="st">'Distribution at T'</span>)</span>
<span id="cb27-60"><a href="#cb27-60" aria-hidden="true" tabindex="-1"></a>    ax2.set_xlabel(<span class="st">'Density'</span>)</span>
<span id="cb27-61"><a href="#cb27-61" aria-hidden="true" tabindex="-1"></a>    ax2.set_yticklabels([])  <span class="co"># Hide y tick labels to avoid duplication</span></span>
<span id="cb27-62"><a href="#cb27-62" aria-hidden="true" tabindex="-1"></a>    ax2.grid(<span class="va">True</span>)</span>
<span id="cb27-63"><a href="#cb27-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fig</span>
<span id="cb27-64"><a href="#cb27-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-65"><a href="#cb27-65" aria-hidden="true" tabindex="-1"></a>plot_posterior(</span>
<span id="cb27-66"><a href="#cb27-66" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"x3_adstock_saturated"</span>].values,</span>
<span id="cb27-67"><a href="#cb27-67" aria-hidden="true" tabindex="-1"></a>    mmm.idata.posterior.channel_contributions.sel(channel<span class="op">=</span><span class="st">"x3"</span>) <span class="op">*</span> df[<span class="st">"y"</span>].<span class="bu">max</span>(),</span>
<span id="cb27-68"><a href="#cb27-68" aria-hidden="true" tabindex="-1"></a>    path_color<span class="op">=</span><span class="st">'lightblue'</span>,</span>
<span id="cb27-69"><a href="#cb27-69" aria-hidden="true" tabindex="-1"></a>    hist_color<span class="op">=</span><span class="st">'lightblue'</span></span>
<span id="cb27-70"><a href="#cb27-70" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The effect was recovered perfectly, using this model, we can safely inform how much we’ll get back if we invest in x3. Nevertheless, we need to control by holiday and inflation to get the total effect. What happen if we don’t have this control variables?</p>
</section>
<section id="how-to-get-right-estimates-if-we-dont-have-all-the-covariates" class="level1">
<h1>How to get right estimates if we don’t have all the covariates?</h1>
<p>If we are confident in our data generative process we can be sure that by surgically excluding a node, a Gaussian process can absorb such variability. Let’s see how this works in practice.</p>
<div id="9086edfb" class="cell" data-execution_count="28">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>mmm <span class="op">=</span> MMM(</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    model_config<span class="op">=</span>model_config,</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    date_column<span class="op">=</span><span class="st">"date"</span>,</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    channel_columns<span class="op">=</span>[</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"x1"</span>,</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"x2"</span>,</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># "x3"</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    adstock<span class="op">=</span>GeometricAdstock(l_max<span class="op">=</span><span class="dv">24</span>),</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    saturation<span class="op">=</span>MichaelisMentenSaturation(),</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    time_varying_intercept<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>mmm.model_config[<span class="st">"intercept_tvp_config"</span>].ls_mu <span class="op">=</span> <span class="dv">15</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>mmm.model_config[<span class="st">"intercept_tvp_config"</span>].m <span class="op">=</span> <span class="dv">200</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>mmm.fit(X, y, <span class="op">**</span>fit_kwargs)</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>mmm.sample_posterior_predictive(</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>X,</span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>    extend_idata<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>    combined<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>    random_seed<span class="op">=</span>rng,</span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>az.summary(mmm.idata, var_names<span class="op">=</span>[<span class="st">"saturation_alpha"</span>, <span class="st">"saturation_lam"</span>, <span class="st">"adstock_alpha"</span>,])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can see by the parameters of the model is able to recover the effect of x2 on y, even though we removed x3 from the model.</p>
<div id="a840b9ac" class="cell" data-execution_count="29">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>plot_posterior(</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"x2_adstock_saturated"</span>].values,</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    mmm.idata.posterior.channel_contributions.sel(channel<span class="op">=</span><span class="st">"x2"</span>) <span class="op">*</span> df[<span class="st">"y"</span>].<span class="bu">max</span>(),</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    path_color<span class="op">=</span><span class="st">'lightgreen'</span>,</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    hist_color<span class="op">=</span><span class="st">'lightgreen'</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>As expected, the effect of x2 on y is recovered, even though we removed control variables from the model, and use a gaussian process to account for the variability of the data instead.</p>
</section>
<section id="conclusions" class="level1">
<h1>Conclusions</h1>
<ol type="1">
<li><p>Don’t seek the one single model: The real world is very dynamic, before its possible that the one single model it doesn’t exist.</p></li>
<li><p>“Find” the Causal Truth: Dive into the world of causal structures and learn how to map out the hidden pathways that influence your outcomes. Not consider causal structures will drive you to consider more simple causal structures, which can be problematic in a real world enviroment.</p></li>
<li><p>Embrace Model Evolution: Don’t get too attached to your first model! As we saw in our DAG progression, models can (and should) change as we learn more. Starting simple is fine, but be ready to level up your model game when the data shows there’s more to the story.</p></li>
</ol>
</section>
<section id="our-causal-discovery-process-in-a-nutshell" class="level1">
<h1>Our causal discovery process in a nutshell</h1>
<p>During the notebook, we have seen how we can use bayesian regression models to identify the causal structure of a dataset, and how we can use this information to make better decisions. We have also seen how we can use this information to make better decisions. In short, we start with a simple naive understanding of the world, which was evolved through the identification of the causal structure of the data, and the use of the causal graph to make better modelling decisions.</p>
<div id="a2beebdf" class="cell" data-execution_count="30">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a figure with five subplots</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">5</span>,)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Set titles for each subplot</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>titles <span class="op">=</span> [<span class="st">"Naive DAG"</span>, <span class="st">"Updated DAG"</span>, <span class="st">"Updated DAG 1"</span>, <span class="st">"Discovered DAG"</span>, <span class="st">"True DAG"</span>]</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, title <span class="kw">in</span> <span class="bu">zip</span>(axes, titles):</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    ax.set_title(title, fontsize<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    ax.axis(<span class="st">'off'</span>)</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Render and plot each graph</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/naive_dag'</span>)</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].imshow(mpimg.imread(<span class="st">'images/naive_dag.png'</span>))</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/updated_dag'</span>)</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].imshow(mpimg.imread(<span class="st">'images/updated_dag.png'</span>))</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/updated_dag1'</span>)</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].imshow(mpimg.imread(<span class="st">'images/updated_dag1.png'</span>))</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>real_dag_graph <span class="op">=</span> causal_model.to_graphviz(ges_graph)</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>real_dag_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/discovered_dag'</span>)</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>].imshow(mpimg.imread(<span class="st">'images/discovered_dag.png'</span>))</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>new_real_dag.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/true_dag'</span>)</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">4</span>].imshow(mpimg.imread(<span class="st">'images/true_dag.png'</span>))</span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Add main title</span></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">"Comparison of DAG Graphs"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Last update:</p>
<div id="fea68d8f" class="cell" data-execution_count="31">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load_ext watermark</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>watermark <span class="op">-</span>n <span class="op">-</span>u <span class="op">-</span>v <span class="op">-</span>iv <span class="op">-</span>w <span class="op">-</span>p pymc_marketing,pytensor</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/cetagostini\.github\.io\/cetagostini\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb32" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Baby Steps for Causal Discovery"</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> "2025-02-01"</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="an">categories:</span><span class="co"> [python, experimentation, media mix modeling, mmm, bayesian, pymc, causal discovery, causal learning, pydata, tallinn, estonia]</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="an">image:</span><span class="co"> "../images/baby_steps_for_causal_discovery.png"</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> cetagostini_web</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="co">  html:</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="co">    code-fold: true</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="co">    code-tools: true</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a><span class="co">    code-overflow: wrap</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction to Causal Discovery</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>In this notebook, we'll dive into how to uncover causal relationships in marketing data, a crucial step for understanding the true impact of various channels on business outcomes. We'll start by generating synthetic data that mimics real-world marketing scenarios, complete with confounding variables and complex causal structures.</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>Next, we'll fit a Bayesian marketing mix model using PyMC-Marketing, check causal directions between variables, and perform mediation analysis to explore indirect effects. Finally, we'll use structure discovery techniques to infer potential causal graphs. By the end, you'll have a solid grasp of how to apply these techniques to reveal hidden causal insights in your marketing data.</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">"ignore"</span>)</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pymc_marketing.mmm.transformers <span class="im">import</span> geometric_adstock, michaelis_menten</span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pymc_marketing.mmm <span class="im">import</span> MMM, GeometricAdstock, MichaelisMentenSaturation</span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pymc_marketing.prior <span class="im">import</span> Prior</span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> graphviz <span class="im">import</span> Digraph</span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pydot</span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> arviz <span class="im">as</span> az</span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.image <span class="im">as</span> mpimg</span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> SVG, display</span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> preliz <span class="im">as</span> pz</span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pymc <span class="im">as</span> pm</span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-47"><a href="#cb32-47" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb32-48"><a href="#cb32-48" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> io <span class="im">import</span> BytesIO</span>
<span id="cb32-49"><a href="#cb32-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-50"><a href="#cb32-50" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> causallearn.graph.Endpoint <span class="im">import</span> Endpoint</span>
<span id="cb32-51"><a href="#cb32-51" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> causallearn.utils.GraphUtils <span class="im">import</span> GraphUtils</span>
<span id="cb32-52"><a href="#cb32-52" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> causallearn.search.ScoreBased.GES <span class="im">import</span> ges</span>
<span id="cb32-53"><a href="#cb32-53" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> causallearn.search.ConstraintBased.PC <span class="im">import</span> pc</span>
<span id="cb32-54"><a href="#cb32-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-55"><a href="#cb32-55" aria-hidden="true" tabindex="-1"></a>az.style.use(<span class="st">"arviz-darkgrid"</span>)</span>
<span id="cb32-56"><a href="#cb32-56" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">"figure.figsize"</span>] <span class="op">=</span> [<span class="dv">8</span>, <span class="dv">4</span>]</span>
<span id="cb32-57"><a href="#cb32-57" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">"figure.dpi"</span>] <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb32-58"><a href="#cb32-58" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">"axes.labelsize"</span>] <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb32-59"><a href="#cb32-59" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">"xtick.labelsize"</span>] <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb32-60"><a href="#cb32-60" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">"ytick.labelsize"</span>] <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb32-61"><a href="#cb32-61" aria-hidden="true" tabindex="-1"></a>plt.rcParams.update({<span class="st">"figure.constrained_layout.use"</span>: <span class="va">True</span>})</span>
<span id="cb32-62"><a href="#cb32-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-63"><a href="#cb32-63" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load_ext autoreload</span>
<span id="cb32-64"><a href="#cb32-64" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>autoreload <span class="dv">2</span></span>
<span id="cb32-65"><a href="#cb32-65" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>config InlineBackend.figure_format <span class="op">=</span> <span class="st">"retina"</span></span>
<span id="cb32-66"><a href="#cb32-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-67"><a href="#cb32-67" aria-hidden="true" tabindex="-1"></a>seed <span class="op">=</span> <span class="bu">sum</span>(<span class="bu">map</span>(<span class="bu">ord</span>, <span class="st">"Estimating effects despite having Confounding Variables"</span>))</span>
<span id="cb32-68"><a href="#cb32-68" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.default_rng(seed)</span>
<span id="cb32-69"><a href="#cb32-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-70"><a href="#cb32-70" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(seed)</span>
<span id="cb32-71"><a href="#cb32-71" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(rng)</span>
<span id="cb32-72"><a href="#cb32-72" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-73"><a href="#cb32-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-74"><a href="#cb32-74" aria-hidden="true" tabindex="-1"></a><span class="fu"># Business case</span></span>
<span id="cb32-75"><a href="#cb32-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-76"><a href="#cb32-76" aria-hidden="true" tabindex="-1"></a>As a company we probably invest in different channels to acquire new customers. Some actions are more direct, like paid ads, and others are more indirect, like offline media marketing, as marketers and scientist, we want to understand the impact of each channel on the target variable (number of new customers).</span>
<span id="cb32-77"><a href="#cb32-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-78"><a href="#cb32-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-79"><a href="#cb32-79" aria-hidden="true" tabindex="-1"></a>The following DAG shows a possible causal structure of the problem. Let's say we have the following variables:</span>
<span id="cb32-80"><a href="#cb32-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-81"><a href="#cb32-81" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$x1$: offline ads, e.g. TV, radio, print, etc.</span>
<span id="cb32-82"><a href="#cb32-82" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$x2$: digital ads, e.g. SEM, SEO, social media, etc.</span>
<span id="cb32-83"><a href="#cb32-83" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$x3$: internal marketing, e.g. product marketing, internal communication, etc.</span>
<span id="cb32-84"><a href="#cb32-84" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$y$: new users</span>
<span id="cb32-85"><a href="#cb32-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-86"><a href="#cb32-86" aria-hidden="true" tabindex="-1"></a>Its probable that our offline ads are not directly affecting our new users, but they are affecting our digital ads and internal marketing, users observe a banner of our product and then they search for it online or they are referred by a friend which finally converts using their phone. Independently, some digital ads can impact users which haven't heard of us before, and those could convert directly.</span>
<span id="cb32-87"><a href="#cb32-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-88"><a href="#cb32-88" aria-hidden="true" tabindex="-1"></a>On top of that, we have some external factors that could affect our new users, e.g. holidays, economic conditions, etc. Things like holidays could affect even more our digital ads, e.g. more users are online shopping, and we are investing more during those days as well.</span>
<span id="cb32-89"><a href="#cb32-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-90"><a href="#cb32-90" aria-hidden="true" tabindex="-1"></a>This creates a complex causal structure, where variables are not fully independent and it is not easy to infer the causal impact of each channel on the target variable.</span>
<span id="cb32-91"><a href="#cb32-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-92"><a href="#cb32-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-95"><a href="#cb32-95" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-96"><a href="#cb32-96" aria-hidden="true" tabindex="-1"></a>new_real_dag <span class="op">=</span> Digraph(comment<span class="op">=</span><span class="st">'DAG'</span>)</span>
<span id="cb32-97"><a href="#cb32-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-98"><a href="#cb32-98" aria-hidden="true" tabindex="-1"></a>new_real_dag.node(<span class="st">'z'</span>, <span class="st">'holiday'</span>, color<span class="op">=</span><span class="st">'grey'</span>, style<span class="op">=</span><span class="st">'dashed'</span>)</span>
<span id="cb32-99"><a href="#cb32-99" aria-hidden="true" tabindex="-1"></a>new_real_dag.node(<span class="st">'m'</span>, <span class="st">'inflation'</span>, color<span class="op">=</span><span class="st">'grey'</span>, style<span class="op">=</span><span class="st">'dashed'</span>)</span>
<span id="cb32-100"><a href="#cb32-100" aria-hidden="true" tabindex="-1"></a>new_real_dag.node(<span class="st">'x1'</span>, <span class="st">'offline ads'</span>)</span>
<span id="cb32-101"><a href="#cb32-101" aria-hidden="true" tabindex="-1"></a>new_real_dag.node(<span class="st">'x2'</span>, <span class="st">'digital ads'</span>)</span>
<span id="cb32-102"><a href="#cb32-102" aria-hidden="true" tabindex="-1"></a>new_real_dag.node(<span class="st">'x3'</span>, <span class="st">'internal marketing'</span>)</span>
<span id="cb32-103"><a href="#cb32-103" aria-hidden="true" tabindex="-1"></a>new_real_dag.node(<span class="st">'y'</span>, <span class="st">'new users'</span>)</span>
<span id="cb32-104"><a href="#cb32-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-105"><a href="#cb32-105" aria-hidden="true" tabindex="-1"></a>new_real_dag.edge(<span class="st">'z'</span>, <span class="st">'x2'</span>, style<span class="op">=</span><span class="st">'dashed'</span>)</span>
<span id="cb32-106"><a href="#cb32-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-107"><a href="#cb32-107" aria-hidden="true" tabindex="-1"></a>new_real_dag.edge(<span class="st">'x1'</span>, <span class="st">'x2'</span>)</span>
<span id="cb32-108"><a href="#cb32-108" aria-hidden="true" tabindex="-1"></a>new_real_dag.edge(<span class="st">'x1'</span>, <span class="st">'x3'</span>)</span>
<span id="cb32-109"><a href="#cb32-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-110"><a href="#cb32-110" aria-hidden="true" tabindex="-1"></a>new_real_dag.edge(<span class="st">'z'</span>, <span class="st">'y'</span>, style<span class="op">=</span><span class="st">'dashed'</span>)</span>
<span id="cb32-111"><a href="#cb32-111" aria-hidden="true" tabindex="-1"></a>new_real_dag.edge(<span class="st">'x2'</span>, <span class="st">'y'</span>)</span>
<span id="cb32-112"><a href="#cb32-112" aria-hidden="true" tabindex="-1"></a>new_real_dag.edge(<span class="st">'x3'</span>, <span class="st">'y'</span>)</span>
<span id="cb32-113"><a href="#cb32-113" aria-hidden="true" tabindex="-1"></a>new_real_dag.edge(<span class="st">'m'</span>, <span class="st">'y'</span>, style<span class="op">=</span><span class="st">'dashed'</span>)</span>
<span id="cb32-114"><a href="#cb32-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-115"><a href="#cb32-115" aria-hidden="true" tabindex="-1"></a>new_real_dag</span>
<span id="cb32-116"><a href="#cb32-116" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-117"><a href="#cb32-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-118"><a href="#cb32-118" aria-hidden="true" tabindex="-1"></a><span class="fu">## Data generation</span></span>
<span id="cb32-119"><a href="#cb32-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-120"><a href="#cb32-120" aria-hidden="true" tabindex="-1"></a>Based on the provided DAG, we can create some synthetic data to test how our model performs when we have a complex causal structures. Using the same data, we can test different model compositions and see how could we improve our model to uncover the true causal impact of each channel on the target variable.</span>
<span id="cb32-121"><a href="#cb32-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-122"><a href="#cb32-122" aria-hidden="true" tabindex="-1"></a>We'll start by setting the date range. Here we'll use a date range from 2022-01-01 to 2024-11-06, meaning we have almost 3 years of data (1041 days).</span>
<span id="cb32-123"><a href="#cb32-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-124"><a href="#cb32-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-127"><a href="#cb32-127" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-128"><a href="#cb32-128" aria-hidden="true" tabindex="-1"></a><span class="co"># date range</span></span>
<span id="cb32-129"><a href="#cb32-129" aria-hidden="true" tabindex="-1"></a>min_date <span class="op">=</span> pd.to_datetime(<span class="st">"2022-01-01"</span>)</span>
<span id="cb32-130"><a href="#cb32-130" aria-hidden="true" tabindex="-1"></a>max_date <span class="op">=</span> pd.to_datetime(<span class="st">"2024-11-06"</span>)</span>
<span id="cb32-131"><a href="#cb32-131" aria-hidden="true" tabindex="-1"></a>date_range <span class="op">=</span> pd.date_range(start<span class="op">=</span>min_date, end<span class="op">=</span>max_date, freq<span class="op">=</span><span class="st">"D"</span>)</span>
<span id="cb32-132"><a href="#cb32-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-133"><a href="#cb32-133" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(data<span class="op">=</span>{<span class="st">"date_week"</span>: date_range}).assign(</span>
<span id="cb32-134"><a href="#cb32-134" aria-hidden="true" tabindex="-1"></a>    year<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="st">"date_week"</span>].dt.year,</span>
<span id="cb32-135"><a href="#cb32-135" aria-hidden="true" tabindex="-1"></a>    month<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="st">"date_week"</span>].dt.month,</span>
<span id="cb32-136"><a href="#cb32-136" aria-hidden="true" tabindex="-1"></a>    dayofyear<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="st">"date_week"</span>].dt.dayofyear,</span>
<span id="cb32-137"><a href="#cb32-137" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-138"><a href="#cb32-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-139"><a href="#cb32-139" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> df.shape[<span class="dv">0</span>]</span>
<span id="cb32-140"><a href="#cb32-140" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of observations: </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb32-141"><a href="#cb32-141" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-142"><a href="#cb32-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-143"><a href="#cb32-143" aria-hidden="true" tabindex="-1"></a><span class="fu">### Holiday signal</span></span>
<span id="cb32-144"><a href="#cb32-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-145"><a href="#cb32-145" aria-hidden="true" tabindex="-1"></a>Certain holidays, like Christmas, can have a significant impact on consumer behavior before and after the specific date, leading to seasonal spikes in sales. To capture these effects, we introduce a holiday signal based on Gaussian (normal) distributions centered around specific holiday dates.</span>
<span id="cb32-146"><a href="#cb32-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-147"><a href="#cb32-147" aria-hidden="true" tabindex="-1"></a>The function used to model the holiday effect is defined as follows:</span>
<span id="cb32-148"><a href="#cb32-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-149"><a href="#cb32-149" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb32-150"><a href="#cb32-150" aria-hidden="true" tabindex="-1"></a>H_{t} = \exp\left(-0.5 \left(\frac{\Delta t}{\sigma}\right)^2\right)</span>
<span id="cb32-151"><a href="#cb32-151" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb32-152"><a href="#cb32-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-153"><a href="#cb32-153" aria-hidden="true" tabindex="-1"></a>Where:</span>
<span id="cb32-154"><a href="#cb32-154" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\Delta t$ is the time difference (in days) between the current date and the holiday date.</span>
<span id="cb32-155"><a href="#cb32-155" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\sigma$ is the standard deviation that controls the spread of the effect around the holiday date.</span>
<span id="cb32-156"><a href="#cb32-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-157"><a href="#cb32-157" aria-hidden="true" tabindex="-1"></a>For each holiday, we calculate the holiday signal across the date range and add a **holiday contribution** by scaling the signal with a holiday-specific coefficient. This approach models seasonal holiday spikes using Gaussian functions, which capture the transient increase in market activity around holidays, and their respective decay over time.</span>
<span id="cb32-158"><a href="#cb32-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-159"><a href="#cb32-159" aria-hidden="true" tabindex="-1"></a><span class="at">&gt; Note: Here we assume a normally distributed signal, nevertheless the signal could be skew or not normal distributed.</span></span>
<span id="cb32-160"><a href="#cb32-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-161"><a href="#cb32-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-164"><a href="#cb32-164" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-165"><a href="#cb32-165" aria-hidden="true" tabindex="-1"></a>holiday_dates <span class="op">=</span> [<span class="st">"24-12"</span>, <span class="st">"31-12"</span>, <span class="st">"08-06"</span>, <span class="st">"07-09"</span>]  <span class="co"># List of holidays as month-day strings</span></span>
<span id="cb32-166"><a href="#cb32-166" aria-hidden="true" tabindex="-1"></a>std_devs <span class="op">=</span> [<span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">3</span>]  <span class="co"># List of standard deviations for each holiday</span></span>
<span id="cb32-167"><a href="#cb32-167" aria-hidden="true" tabindex="-1"></a>holidays_coefficients <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">6</span>]</span>
<span id="cb32-168"><a href="#cb32-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-169"><a href="#cb32-169" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize the holiday effect array</span></span>
<span id="cb32-170"><a href="#cb32-170" aria-hidden="true" tabindex="-1"></a>holiday_signal <span class="op">=</span> np.zeros(<span class="bu">len</span>(date_range))</span>
<span id="cb32-171"><a href="#cb32-171" aria-hidden="true" tabindex="-1"></a>holiday_contributions <span class="op">=</span> np.zeros(<span class="bu">len</span>(date_range))</span>
<span id="cb32-172"><a href="#cb32-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-173"><a href="#cb32-173" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate holiday signals</span></span>
<span id="cb32-174"><a href="#cb32-174" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> holiday, std_dev, holiday_coef <span class="kw">in</span> <span class="bu">zip</span>(</span>
<span id="cb32-175"><a href="#cb32-175" aria-hidden="true" tabindex="-1"></a>    holiday_dates, std_devs, holidays_coefficients, strict<span class="op">=</span><span class="va">False</span></span>
<span id="cb32-176"><a href="#cb32-176" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb32-177"><a href="#cb32-177" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find all occurrences of the holiday in the date range</span></span>
<span id="cb32-178"><a href="#cb32-178" aria-hidden="true" tabindex="-1"></a>    holiday_occurrences <span class="op">=</span> date_range[date_range.strftime(<span class="st">"</span><span class="sc">%d</span><span class="st">-%m"</span>) <span class="op">==</span> holiday]</span>
<span id="cb32-179"><a href="#cb32-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-180"><a href="#cb32-180" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> occurrence <span class="kw">in</span> holiday_occurrences:</span>
<span id="cb32-181"><a href="#cb32-181" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate the time difference in days</span></span>
<span id="cb32-182"><a href="#cb32-182" aria-hidden="true" tabindex="-1"></a>        time_diff <span class="op">=</span> (date_range <span class="op">-</span> occurrence).days</span>
<span id="cb32-183"><a href="#cb32-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-184"><a href="#cb32-184" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Generate the Gaussian basis for the holiday</span></span>
<span id="cb32-185"><a href="#cb32-185" aria-hidden="true" tabindex="-1"></a>        _holiday_signal <span class="op">=</span> np.exp(<span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> (time_diff <span class="op">/</span> std_dev) <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb32-186"><a href="#cb32-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-187"><a href="#cb32-187" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add the holiday signal to the holiday effect</span></span>
<span id="cb32-188"><a href="#cb32-188" aria-hidden="true" tabindex="-1"></a>        holiday_signal <span class="op">+=</span> _holiday_signal</span>
<span id="cb32-189"><a href="#cb32-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-190"><a href="#cb32-190" aria-hidden="true" tabindex="-1"></a>        holiday_contributions <span class="op">+=</span> _holiday_signal <span class="op">*</span> holiday_coef</span>
<span id="cb32-191"><a href="#cb32-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-192"><a href="#cb32-192" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"holiday_signal"</span>] <span class="op">=</span> holiday_signal</span>
<span id="cb32-193"><a href="#cb32-193" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"holiday_contributions"</span>] <span class="op">=</span> holiday_contributions</span>
<span id="cb32-194"><a href="#cb32-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-195"><a href="#cb32-195" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the holiday effect</span></span>
<span id="cb32-196"><a href="#cb32-196" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb32-197"><a href="#cb32-197" aria-hidden="true" tabindex="-1"></a>sns.lineplot(x<span class="op">=</span>date_range, y<span class="op">=</span>holiday_signal, ax<span class="op">=</span>ax)</span>
<span id="cb32-198"><a href="#cb32-198" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(title<span class="op">=</span><span class="st">"Holiday Effect Signal"</span>, xlabel<span class="op">=</span><span class="st">"Date"</span>, ylabel<span class="op">=</span><span class="st">"Signal Intensity"</span>)</span>
<span id="cb32-199"><a href="#cb32-199" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb32-200"><a href="#cb32-200" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-201"><a href="#cb32-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-202"><a href="#cb32-202" aria-hidden="true" tabindex="-1"></a><span class="fu">### Generating inflation</span></span>
<span id="cb32-203"><a href="#cb32-203" aria-hidden="true" tabindex="-1"></a>Next, we generate the data for **Inflation**. We assume the inflation follows a power-law trend, meaning that growth accelerates over time rather than remaining constant. This can be mathematically defined as:</span>
<span id="cb32-204"><a href="#cb32-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-205"><a href="#cb32-205" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb32-206"><a href="#cb32-206" aria-hidden="true" tabindex="-1"></a>IN_{t} = (t + \text{baseline})^{\text{exponent}} - 1</span>
<span id="cb32-207"><a href="#cb32-207" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb32-208"><a href="#cb32-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-209"><a href="#cb32-209" aria-hidden="true" tabindex="-1"></a>Where:</span>
<span id="cb32-210"><a href="#cb32-210" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$t$: The time index, representing days since the start of the date range.</span>
<span id="cb32-211"><a href="#cb32-211" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$baseline$: A constant added to $t$ to shift the starting point of the trend. This value affects the initial level of market growth. The starting value of the function will be $(baseline)^{exponent} - 1$, not 0.</span>
<span id="cb32-212"><a href="#cb32-212" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$exponent$: The power to which the time index is raised, determining the rate at which the trend accelerates over time.</span>
<span id="cb32-213"><a href="#cb32-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-214"><a href="#cb32-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-217"><a href="#cb32-217" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-218"><a href="#cb32-218" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"inflation"</span>] <span class="op">=</span> (np.linspace(start<span class="op">=</span><span class="fl">0.0</span>, stop<span class="op">=</span><span class="dv">50</span>, num<span class="op">=</span>n) <span class="op">+</span> <span class="dv">10</span>) <span class="op">**</span> (<span class="dv">2</span> <span class="op">/</span> <span class="dv">4</span>) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb32-219"><a href="#cb32-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-220"><a href="#cb32-220" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb32-221"><a href="#cb32-221" aria-hidden="true" tabindex="-1"></a>sns.lineplot(</span>
<span id="cb32-222"><a href="#cb32-222" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span><span class="st">"date_week"</span>, y<span class="op">=</span><span class="st">"inflation"</span>, color<span class="op">=</span><span class="st">"C2"</span>, label<span class="op">=</span><span class="st">"trend"</span>, data<span class="op">=</span>df, ax<span class="op">=</span>ax</span>
<span id="cb32-223"><a href="#cb32-223" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-224"><a href="#cb32-224" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="st">"upper left"</span>)</span>
<span id="cb32-225"><a href="#cb32-225" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(title<span class="op">=</span><span class="st">"Inflation Components"</span>, xlabel<span class="op">=</span><span class="st">"date"</span>, ylabel<span class="op">=</span><span class="va">None</span>)<span class="op">;</span></span>
<span id="cb32-226"><a href="#cb32-226" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-227"><a href="#cb32-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-228"><a href="#cb32-228" aria-hidden="true" tabindex="-1"></a><span class="fu">### Modeling Marketing Channels</span></span>
<span id="cb32-229"><a href="#cb32-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-230"><a href="#cb32-230" aria-hidden="true" tabindex="-1"></a>In this section, we simulate three marketing channels, $x1$, $x2$, and $x3$ which represent different advertising channels (e.g., Internal Marketing, Social Marketing, Offline Marketing). Each channel's behavior is influenced by random variability and confounding effects from seasonal holidays. Here’s how we model each channel mathematically:</span>
<span id="cb32-231"><a href="#cb32-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-232"><a href="#cb32-232" aria-hidden="true" tabindex="-1"></a>**Channel $x1$**:</span>
<span id="cb32-233"><a href="#cb32-233" aria-hidden="true" tabindex="-1"></a>As mentioned before, we generate $x1$ which is affected by the holiday signal, we could define it as:</span>
<span id="cb32-234"><a href="#cb32-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-235"><a href="#cb32-235" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb32-236"><a href="#cb32-236" aria-hidden="true" tabindex="-1"></a>I_{x1_t} = S_{x1_t} + e_{x1}</span>
<span id="cb32-237"><a href="#cb32-237" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb32-238"><a href="#cb32-238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-239"><a href="#cb32-239" aria-hidden="true" tabindex="-1"></a>**Channel $x2$**:</span>
<span id="cb32-240"><a href="#cb32-240" aria-hidden="true" tabindex="-1"></a>On the other hand, we generate $x2$ which is affected by the holiday signal, and the influence of $x1$. We could define it as:</span>
<span id="cb32-241"><a href="#cb32-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-242"><a href="#cb32-242" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb32-243"><a href="#cb32-243" aria-hidden="true" tabindex="-1"></a>I_{x2_t} = S_{x2_t} + H_{t} \times \alpha_{x2} + (I_{x1_t} \times \alpha_{x1_x2}) + e_{x2}</span>
<span id="cb32-244"><a href="#cb32-244" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb32-245"><a href="#cb32-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-246"><a href="#cb32-246" aria-hidden="true" tabindex="-1"></a>**Channel $x3$**:</span>
<span id="cb32-247"><a href="#cb32-247" aria-hidden="true" tabindex="-1"></a>For the last variable, we generate $x3$ which is affected by $x1$ only.</span>
<span id="cb32-248"><a href="#cb32-248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-249"><a href="#cb32-249" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb32-250"><a href="#cb32-250" aria-hidden="true" tabindex="-1"></a>I_{x3_t} = S_{x3_t} + (I_{x1_t} \times \alpha_{x1_x3}) + e_{x3}</span>
<span id="cb32-251"><a href="#cb32-251" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb32-252"><a href="#cb32-252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-253"><a href="#cb32-253" aria-hidden="true" tabindex="-1"></a>These equations allow us to capture the complex dynamics influencing each marketing channel:</span>
<span id="cb32-254"><a href="#cb32-254" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Holiday Effects** increase channel activity around specific dates, simulating seasonal spikes.</span>
<span id="cb32-255"><a href="#cb32-255" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Cross-channel Influences** introduce interdependencies, modeling how one channel's success can amplify another’s.</span>
<span id="cb32-256"><a href="#cb32-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-257"><a href="#cb32-257" aria-hidden="true" tabindex="-1"></a><span class="at">&gt; Note: Here we are assuming an additive impact for the channel interactions.</span></span>
<span id="cb32-258"><a href="#cb32-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-259"><a href="#cb32-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-262"><a href="#cb32-262" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-263"><a href="#cb32-263" aria-hidden="true" tabindex="-1"></a>x1 <span class="op">=</span> pz.Gamma(mu<span class="op">=</span><span class="dv">1</span>, sigma<span class="op">=</span><span class="dv">3</span>).rvs(n, random_state<span class="op">=</span>rng)</span>
<span id="cb32-264"><a href="#cb32-264" aria-hidden="true" tabindex="-1"></a>cofounder_effect_holiday_x1 <span class="op">=</span> <span class="fl">2.5</span></span>
<span id="cb32-265"><a href="#cb32-265" aria-hidden="true" tabindex="-1"></a>x1_conv <span class="op">=</span> np.convolve(x1, np.ones(<span class="dv">14</span>) <span class="op">/</span> <span class="dv">14</span>, mode<span class="op">=</span><span class="st">"same"</span>)</span>
<span id="cb32-266"><a href="#cb32-266" aria-hidden="true" tabindex="-1"></a>noise <span class="op">=</span> pz.Normal(mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="fl">0.1</span>).rvs(<span class="dv">28</span>, random_state<span class="op">=</span>rng)</span>
<span id="cb32-267"><a href="#cb32-267" aria-hidden="true" tabindex="-1"></a>x1_conv[:<span class="dv">14</span>] <span class="op">=</span> x1_conv.mean() <span class="op">+</span> noise[:<span class="dv">14</span>]</span>
<span id="cb32-268"><a href="#cb32-268" aria-hidden="true" tabindex="-1"></a>x1_conv[<span class="op">-</span><span class="dv">14</span>:] <span class="op">=</span> x1_conv.mean() <span class="op">+</span> noise[<span class="dv">14</span>:]</span>
<span id="cb32-269"><a href="#cb32-269" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"x1"</span>] <span class="op">=</span> x1_conv</span>
<span id="cb32-270"><a href="#cb32-270" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-271"><a href="#cb32-271" aria-hidden="true" tabindex="-1"></a>x2 <span class="op">=</span> pz.Gamma(mu<span class="op">=</span><span class="dv">2</span>, sigma<span class="op">=</span><span class="dv">2</span>).rvs(n, random_state<span class="op">=</span>rng)</span>
<span id="cb32-272"><a href="#cb32-272" aria-hidden="true" tabindex="-1"></a>cofounder_effect_holiday_x2 <span class="op">=</span> <span class="fl">2.2</span></span>
<span id="cb32-273"><a href="#cb32-273" aria-hidden="true" tabindex="-1"></a>cofounder_effect_x1_x2 <span class="op">=</span> <span class="fl">1.3</span></span>
<span id="cb32-274"><a href="#cb32-274" aria-hidden="true" tabindex="-1"></a>x2_conv <span class="op">=</span> np.convolve(x2, np.ones(<span class="dv">18</span>) <span class="op">/</span> <span class="dv">12</span>, mode<span class="op">=</span><span class="st">"same"</span>)</span>
<span id="cb32-275"><a href="#cb32-275" aria-hidden="true" tabindex="-1"></a>noise <span class="op">=</span> pz.Normal(mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="fl">0.1</span>).rvs(<span class="dv">28</span>, random_state<span class="op">=</span>rng)</span>
<span id="cb32-276"><a href="#cb32-276" aria-hidden="true" tabindex="-1"></a>x2_conv[:<span class="dv">14</span>] <span class="op">=</span> x2_conv.mean() <span class="op">+</span> noise[:<span class="dv">14</span>]</span>
<span id="cb32-277"><a href="#cb32-277" aria-hidden="true" tabindex="-1"></a>x2_conv[<span class="op">-</span><span class="dv">14</span>:] <span class="op">=</span> x2_conv.mean() <span class="op">+</span> noise[<span class="dv">14</span>:]</span>
<span id="cb32-278"><a href="#cb32-278" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"x2"</span>] <span class="op">=</span> (</span>
<span id="cb32-279"><a href="#cb32-279" aria-hidden="true" tabindex="-1"></a>    x2_conv</span>
<span id="cb32-280"><a href="#cb32-280" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> (holiday_signal <span class="op">*</span> cofounder_effect_holiday_x2)</span>
<span id="cb32-281"><a href="#cb32-281" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> (df[<span class="st">"x1"</span>] <span class="op">*</span> cofounder_effect_x1_x2)</span>
<span id="cb32-282"><a href="#cb32-282" aria-hidden="true" tabindex="-1"></a>) <span class="co"># digital ads</span></span>
<span id="cb32-283"><a href="#cb32-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-284"><a href="#cb32-284" aria-hidden="true" tabindex="-1"></a>x3 <span class="op">=</span> pz.Gamma(mu<span class="op">=</span><span class="dv">5</span>, sigma<span class="op">=</span><span class="dv">1</span>).rvs(n, random_state<span class="op">=</span>rng)</span>
<span id="cb32-285"><a href="#cb32-285" aria-hidden="true" tabindex="-1"></a>cofounder_effect_x1_x3 <span class="op">=</span> <span class="fl">1.5</span></span>
<span id="cb32-286"><a href="#cb32-286" aria-hidden="true" tabindex="-1"></a>x3_conv <span class="op">=</span> np.convolve(x3, np.ones(<span class="dv">16</span>) <span class="op">/</span> <span class="dv">10</span>, mode<span class="op">=</span><span class="st">"same"</span>)</span>
<span id="cb32-287"><a href="#cb32-287" aria-hidden="true" tabindex="-1"></a>noise <span class="op">=</span> pz.Normal(mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="fl">0.1</span>).rvs(<span class="dv">28</span>, random_state<span class="op">=</span>rng)</span>
<span id="cb32-288"><a href="#cb32-288" aria-hidden="true" tabindex="-1"></a>x3_conv[:<span class="dv">14</span>] <span class="op">=</span> x3_conv.mean() <span class="op">+</span> noise[:<span class="dv">14</span>]</span>
<span id="cb32-289"><a href="#cb32-289" aria-hidden="true" tabindex="-1"></a>x3_conv[<span class="op">-</span><span class="dv">14</span>:] <span class="op">=</span> x3_conv.mean() <span class="op">+</span> noise[<span class="dv">14</span>:]</span>
<span id="cb32-290"><a href="#cb32-290" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"x3"</span>] <span class="op">=</span> (</span>
<span id="cb32-291"><a href="#cb32-291" aria-hidden="true" tabindex="-1"></a>    x3_conv</span>
<span id="cb32-292"><a href="#cb32-292" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> (df[<span class="st">"x1"</span>] <span class="op">*</span> cofounder_effect_x1_x3)</span>
<span id="cb32-293"><a href="#cb32-293" aria-hidden="true" tabindex="-1"></a>) <span class="co"># internal marketing</span></span>
<span id="cb32-294"><a href="#cb32-294" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-295"><a href="#cb32-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-296"><a href="#cb32-296" aria-hidden="true" tabindex="-1"></a>We'll assume all of marketing activities suffer the same transformations Adstock and Saturation. This means, each channel will have individual parameters for the selected transformations, in this case Geometrick adstock and michaelis menten.</span>
<span id="cb32-297"><a href="#cb32-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-298"><a href="#cb32-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-301"><a href="#cb32-301" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-302"><a href="#cb32-302" aria-hidden="true" tabindex="-1"></a><span class="co"># apply geometric adstock transformation</span></span>
<span id="cb32-303"><a href="#cb32-303" aria-hidden="true" tabindex="-1"></a>alpha2: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.4</span></span>
<span id="cb32-304"><a href="#cb32-304" aria-hidden="true" tabindex="-1"></a>alpha3: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.3</span></span>
<span id="cb32-305"><a href="#cb32-305" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-306"><a href="#cb32-306" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"x2_adstock"</span>] <span class="op">=</span> (</span>
<span id="cb32-307"><a href="#cb32-307" aria-hidden="true" tabindex="-1"></a>    geometric_adstock(x<span class="op">=</span>df[<span class="st">"x2"</span>].to_numpy(), alpha<span class="op">=</span>alpha2, l_max<span class="op">=</span><span class="dv">24</span>, normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-308"><a href="#cb32-308" aria-hidden="true" tabindex="-1"></a>    .<span class="bu">eval</span>()</span>
<span id="cb32-309"><a href="#cb32-309" aria-hidden="true" tabindex="-1"></a>    .flatten()</span>
<span id="cb32-310"><a href="#cb32-310" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-311"><a href="#cb32-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-312"><a href="#cb32-312" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"x3_adstock"</span>] <span class="op">=</span> (</span>
<span id="cb32-313"><a href="#cb32-313" aria-hidden="true" tabindex="-1"></a>    geometric_adstock(x<span class="op">=</span>df[<span class="st">"x3"</span>].to_numpy(), alpha<span class="op">=</span>alpha3, l_max<span class="op">=</span><span class="dv">24</span>, normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-314"><a href="#cb32-314" aria-hidden="true" tabindex="-1"></a>    .<span class="bu">eval</span>()</span>
<span id="cb32-315"><a href="#cb32-315" aria-hidden="true" tabindex="-1"></a>    .flatten()</span>
<span id="cb32-316"><a href="#cb32-316" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-317"><a href="#cb32-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-318"><a href="#cb32-318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-319"><a href="#cb32-319" aria-hidden="true" tabindex="-1"></a><span class="co"># apply saturation transformation</span></span>
<span id="cb32-320"><a href="#cb32-320" aria-hidden="true" tabindex="-1"></a>lam2: <span class="bu">float</span> <span class="op">=</span> <span class="fl">6.0</span></span>
<span id="cb32-321"><a href="#cb32-321" aria-hidden="true" tabindex="-1"></a>lam3: <span class="bu">float</span> <span class="op">=</span> <span class="fl">12.0</span></span>
<span id="cb32-322"><a href="#cb32-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-323"><a href="#cb32-323" aria-hidden="true" tabindex="-1"></a>alpha_mm2: <span class="bu">float</span> <span class="op">=</span> <span class="dv">12</span></span>
<span id="cb32-324"><a href="#cb32-324" aria-hidden="true" tabindex="-1"></a>alpha_mm3: <span class="bu">float</span> <span class="op">=</span> <span class="dv">18</span></span>
<span id="cb32-325"><a href="#cb32-325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-326"><a href="#cb32-326" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"x2_adstock_saturated"</span>] <span class="op">=</span> michaelis_menten(</span>
<span id="cb32-327"><a href="#cb32-327" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span>df[<span class="st">"x2_adstock"</span>].to_numpy(), lam<span class="op">=</span>lam2, alpha<span class="op">=</span>alpha_mm2</span>
<span id="cb32-328"><a href="#cb32-328" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-329"><a href="#cb32-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-330"><a href="#cb32-330" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"x3_adstock_saturated"</span>] <span class="op">=</span> michaelis_menten(</span>
<span id="cb32-331"><a href="#cb32-331" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span>df[<span class="st">"x3_adstock"</span>].to_numpy(), lam<span class="op">=</span>lam3, alpha<span class="op">=</span>alpha_mm3</span>
<span id="cb32-332"><a href="#cb32-332" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-333"><a href="#cb32-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-334"><a href="#cb32-334" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(</span>
<span id="cb32-335"><a href="#cb32-335" aria-hidden="true" tabindex="-1"></a>    nrows<span class="op">=</span><span class="dv">3</span>, ncols<span class="op">=</span><span class="dv">2</span>, sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">False</span>, layout<span class="op">=</span><span class="st">"constrained"</span></span>
<span id="cb32-336"><a href="#cb32-336" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-337"><a href="#cb32-337" aria-hidden="true" tabindex="-1"></a>sns.lineplot(x<span class="op">=</span><span class="st">"date_week"</span>, y<span class="op">=</span><span class="st">"x2"</span>, data<span class="op">=</span>df, color<span class="op">=</span><span class="st">"C1"</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb32-338"><a href="#cb32-338" aria-hidden="true" tabindex="-1"></a>sns.lineplot(x<span class="op">=</span><span class="st">"date_week"</span>, y<span class="op">=</span><span class="st">"x3"</span>, data<span class="op">=</span>df, color<span class="op">=</span><span class="st">"C2"</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb32-339"><a href="#cb32-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-340"><a href="#cb32-340" aria-hidden="true" tabindex="-1"></a>sns.lineplot(x<span class="op">=</span><span class="st">"date_week"</span>, y<span class="op">=</span><span class="st">"x2_adstock"</span>, data<span class="op">=</span>df, color<span class="op">=</span><span class="st">"C1"</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>, <span class="dv">0</span>])</span>
<span id="cb32-341"><a href="#cb32-341" aria-hidden="true" tabindex="-1"></a>sns.lineplot(x<span class="op">=</span><span class="st">"date_week"</span>, y<span class="op">=</span><span class="st">"x3_adstock"</span>, data<span class="op">=</span>df, color<span class="op">=</span><span class="st">"C2"</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>, <span class="dv">1</span>])</span>
<span id="cb32-342"><a href="#cb32-342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-343"><a href="#cb32-343" aria-hidden="true" tabindex="-1"></a>sns.lineplot(x<span class="op">=</span><span class="st">"date_week"</span>, y<span class="op">=</span><span class="st">"x2_adstock_saturated"</span>, data<span class="op">=</span>df, color<span class="op">=</span><span class="st">"C1"</span>, ax<span class="op">=</span>ax[<span class="dv">2</span>, <span class="dv">0</span>])</span>
<span id="cb32-344"><a href="#cb32-344" aria-hidden="true" tabindex="-1"></a>sns.lineplot(x<span class="op">=</span><span class="st">"date_week"</span>, y<span class="op">=</span><span class="st">"x3_adstock_saturated"</span>, data<span class="op">=</span>df, color<span class="op">=</span><span class="st">"C2"</span>, ax<span class="op">=</span>ax[<span class="dv">2</span>, <span class="dv">1</span>])</span>
<span id="cb32-345"><a href="#cb32-345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-346"><a href="#cb32-346" aria-hidden="true" tabindex="-1"></a>fig.suptitle(<span class="st">"Media Costs Data - Transformed"</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb32-347"><a href="#cb32-347" aria-hidden="true" tabindex="-1"></a><span class="co"># adjust size of X axis</span></span>
<span id="cb32-348"><a href="#cb32-348" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>, <span class="dv">0</span>].tick_params(axis<span class="op">=</span><span class="st">"x"</span>, labelsize<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb32-349"><a href="#cb32-349" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">2</span>, <span class="dv">1</span>].tick_params(axis<span class="op">=</span><span class="st">"x"</span>, labelsize<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb32-350"><a href="#cb32-350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-351"><a href="#cb32-351" aria-hidden="true" tabindex="-1"></a><span class="co"># adjust size of x axis labels</span></span>
<span id="cb32-352"><a href="#cb32-352" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax <span class="kw">in</span> ax.flat:</span>
<span id="cb32-353"><a href="#cb32-353" aria-hidden="true" tabindex="-1"></a>    ax.tick_params(axis<span class="op">=</span><span class="st">"x"</span>, labelsize<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb32-354"><a href="#cb32-354" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-355"><a href="#cb32-355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-356"><a href="#cb32-356" aria-hidden="true" tabindex="-1"></a>The previous plot shows how the transformations affect each variable, and what would be the true contribution after each transformation.</span>
<span id="cb32-357"><a href="#cb32-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-358"><a href="#cb32-358" aria-hidden="true" tabindex="-1"></a><span class="fu">### Target variable</span></span>
<span id="cb32-359"><a href="#cb32-359" aria-hidden="true" tabindex="-1"></a>The target variable is a combination of all variables before. The mathematical formula can be expressed as:</span>
<span id="cb32-360"><a href="#cb32-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-361"><a href="#cb32-361" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb32-362"><a href="#cb32-362" aria-hidden="true" tabindex="-1"></a>y_{t} = Intercept - f(IN_{t}) + f(H_{t}) + m(I_{x3_t}) + m(I_{x2_t}) + \epsilon</span>
<span id="cb32-363"><a href="#cb32-363" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb32-364"><a href="#cb32-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-365"><a href="#cb32-365" aria-hidden="true" tabindex="-1"></a>Where:</span>
<span id="cb32-366"><a href="#cb32-366" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Intercept**: A baseline level of sales, set to 1.5, representing the base sales level in the absence of other effects.</span>
<span id="cb32-367"><a href="#cb32-367" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Inflation**: Represents the underlying market inflation, with an implicit negative coefficient of 1, adding a steady downward influence.</span>
<span id="cb32-368"><a href="#cb32-368" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Holiday Contributions**: Adds sales spikes around holiday periods, capturing the seasonal increase in consumer demand.</span>
<span id="cb32-369"><a href="#cb32-369" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**$m(Impressions_{x3_t})$ and $m(Impressions_{x2_t})$**: Represent the **saturated adstock** values for the marketing channels $x3$ and $x2$.</span>
<span id="cb32-370"><a href="#cb32-370" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Noise $\epsilon$**: A small random error term, drawn from a normal distribution with mean 0 and standard deviation 0.08, to account for unexplained variability in sales.</span>
<span id="cb32-371"><a href="#cb32-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-372"><a href="#cb32-372" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-375"><a href="#cb32-375" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-376"><a href="#cb32-376" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"intercept"</span>] <span class="op">=</span> <span class="fl">1.5</span></span>
<span id="cb32-377"><a href="#cb32-377" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"epsilon"</span>] <span class="op">=</span> rng.normal(loc<span class="op">=</span><span class="fl">0.0</span>, scale<span class="op">=</span><span class="fl">0.08</span>, size<span class="op">=</span>n)</span>
<span id="cb32-378"><a href="#cb32-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-379"><a href="#cb32-379" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"y"</span>] <span class="op">=</span> (</span>
<span id="cb32-380"><a href="#cb32-380" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"intercept"</span>]</span>
<span id="cb32-381"><a href="#cb32-381" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> df[<span class="st">"holiday_contributions"</span>]</span>
<span id="cb32-382"><a href="#cb32-382" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> df[<span class="st">"x2_adstock_saturated"</span>]</span>
<span id="cb32-383"><a href="#cb32-383" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> df[<span class="st">"x3_adstock_saturated"</span>]</span>
<span id="cb32-384"><a href="#cb32-384" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> df[<span class="st">"epsilon"</span>]  <span class="co"># Noise</span></span>
<span id="cb32-385"><a href="#cb32-385" aria-hidden="true" tabindex="-1"></a>) <span class="op">-</span> df[<span class="st">"inflation"</span>]</span>
<span id="cb32-386"><a href="#cb32-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-387"><a href="#cb32-387" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb32-388"><a href="#cb32-388" aria-hidden="true" tabindex="-1"></a>sns.lineplot(x<span class="op">=</span><span class="st">"date_week"</span>, y<span class="op">=</span><span class="st">"y"</span>, color<span class="op">=</span><span class="st">"black"</span>, data<span class="op">=</span>df, ax<span class="op">=</span>ax)</span>
<span id="cb32-389"><a href="#cb32-389" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(title<span class="op">=</span><span class="st">"Sales (Target Variable)"</span>, xlabel<span class="op">=</span><span class="st">"date"</span>, ylabel<span class="op">=</span><span class="st">"y (thousands)"</span>)<span class="op">;</span></span>
<span id="cb32-390"><a href="#cb32-390" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-391"><a href="#cb32-391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-392"><a href="#cb32-392" aria-hidden="true" tabindex="-1"></a>We can scale the full dataset and we'll have finally something very similar to reality.</span>
<span id="cb32-393"><a href="#cb32-393" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-396"><a href="#cb32-396" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-397"><a href="#cb32-397" aria-hidden="true" tabindex="-1"></a><span class="co"># scale df by abs max per column</span></span>
<span id="cb32-398"><a href="#cb32-398" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"date"</span>] <span class="op">=</span> pd.to_datetime(df[<span class="st">"date_week"</span>])</span>
<span id="cb32-399"><a href="#cb32-399" aria-hidden="true" tabindex="-1"></a>scaled_df <span class="op">=</span> df.copy()</span>
<span id="cb32-400"><a href="#cb32-400" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> scaled_df.columns:</span>
<span id="cb32-401"><a href="#cb32-401" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="op">!=</span> <span class="st">'date'</span> <span class="kw">and</span> col <span class="op">!=</span> <span class="st">'date_week'</span>:</span>
<span id="cb32-402"><a href="#cb32-402" aria-hidden="true" tabindex="-1"></a>        scaled_df[col] <span class="op">=</span> scaled_df[col] <span class="op">/</span> scaled_df[col].<span class="bu">abs</span>().<span class="bu">max</span>()</span>
<span id="cb32-403"><a href="#cb32-403" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-404"><a href="#cb32-404" aria-hidden="true" tabindex="-1"></a>scaled_df[[<span class="st">"date"</span>, <span class="st">"x1"</span>, <span class="st">"x2"</span>, <span class="st">"x3"</span>, <span class="st">"y"</span>]].head()</span>
<span id="cb32-405"><a href="#cb32-405" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-406"><a href="#cb32-406" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-407"><a href="#cb32-407" aria-hidden="true" tabindex="-1"></a><span class="fu"># Intial approach</span></span>
<span id="cb32-408"><a href="#cb32-408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-409"><a href="#cb32-409" aria-hidden="true" tabindex="-1"></a>If we have a dataset like the one we just created, we can try to fit a model with the following to find the causal impact of each channel on the target variable. For the example, we'll use a simple model from Pymc-Marketing for this purpose.</span>
<span id="cb32-410"><a href="#cb32-410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-411"><a href="#cb32-411" aria-hidden="true" tabindex="-1"></a>Let's see what happens if we fit a model with all what we have without any knowledge of the causal structure.</span>
<span id="cb32-412"><a href="#cb32-412" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-415"><a href="#cb32-415" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-416"><a href="#cb32-416" aria-hidden="true" tabindex="-1"></a>scaled_df[[<span class="st">"date"</span>, <span class="st">"x1"</span>, <span class="st">"x2"</span>, <span class="st">"x3"</span>, <span class="st">"y"</span>]].head()</span>
<span id="cb32-417"><a href="#cb32-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-418"><a href="#cb32-418" aria-hidden="true" tabindex="-1"></a>model_config <span class="op">=</span> {</span>
<span id="cb32-419"><a href="#cb32-419" aria-hidden="true" tabindex="-1"></a>    <span class="st">"intercept"</span>: Prior(<span class="st">"Gamma"</span>, mu<span class="op">=</span><span class="dv">1</span>, sigma<span class="op">=</span><span class="dv">1</span>),</span>
<span id="cb32-420"><a href="#cb32-420" aria-hidden="true" tabindex="-1"></a>    <span class="st">"likelihood"</span>: Prior(<span class="st">"Normal"</span>, sigma<span class="op">=</span>Prior(<span class="st">"Normal"</span>, mu<span class="op">=</span><span class="dv">0</span>, sigma<span class="op">=</span><span class="fl">.5</span>)),</span>
<span id="cb32-421"><a href="#cb32-421" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb32-422"><a href="#cb32-422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-423"><a href="#cb32-423" aria-hidden="true" tabindex="-1"></a>fit_kwargs <span class="op">=</span> <span class="bu">dict</span>(nuts_sampler<span class="op">=</span><span class="st">"numpyro"</span>, random_seed<span class="op">=</span>rng,)</span>
<span id="cb32-424"><a href="#cb32-424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-425"><a href="#cb32-425" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> df.drop(columns<span class="op">=</span>[<span class="st">"y"</span>])</span>
<span id="cb32-426"><a href="#cb32-426" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> df[<span class="st">"y"</span>]</span>
<span id="cb32-427"><a href="#cb32-427" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-428"><a href="#cb32-428" aria-hidden="true" tabindex="-1"></a>mmm <span class="op">=</span> MMM(</span>
<span id="cb32-429"><a href="#cb32-429" aria-hidden="true" tabindex="-1"></a>    date_column<span class="op">=</span><span class="st">"date"</span>,</span>
<span id="cb32-430"><a href="#cb32-430" aria-hidden="true" tabindex="-1"></a>    channel_columns<span class="op">=</span>[</span>
<span id="cb32-431"><a href="#cb32-431" aria-hidden="true" tabindex="-1"></a>        <span class="st">"x1"</span>,</span>
<span id="cb32-432"><a href="#cb32-432" aria-hidden="true" tabindex="-1"></a>        <span class="st">"x2"</span>,</span>
<span id="cb32-433"><a href="#cb32-433" aria-hidden="true" tabindex="-1"></a>        <span class="st">"x3"</span></span>
<span id="cb32-434"><a href="#cb32-434" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb32-435"><a href="#cb32-435" aria-hidden="true" tabindex="-1"></a>    control_columns<span class="op">=</span>[</span>
<span id="cb32-436"><a href="#cb32-436" aria-hidden="true" tabindex="-1"></a>        <span class="st">"holiday_signal"</span>,</span>
<span id="cb32-437"><a href="#cb32-437" aria-hidden="true" tabindex="-1"></a>        <span class="st">"inflation"</span></span>
<span id="cb32-438"><a href="#cb32-438" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb32-439"><a href="#cb32-439" aria-hidden="true" tabindex="-1"></a>    adstock<span class="op">=</span>GeometricAdstock(l_max<span class="op">=</span><span class="dv">24</span>),</span>
<span id="cb32-440"><a href="#cb32-440" aria-hidden="true" tabindex="-1"></a>    saturation<span class="op">=</span>MichaelisMentenSaturation(),</span>
<span id="cb32-441"><a href="#cb32-441" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-442"><a href="#cb32-442" aria-hidden="true" tabindex="-1"></a>mmm.fit(X, y, <span class="op">**</span>fit_kwargs)</span>
<span id="cb32-443"><a href="#cb32-443" aria-hidden="true" tabindex="-1"></a>mmm.sample_posterior_predictive(</span>
<span id="cb32-444"><a href="#cb32-444" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>X,</span>
<span id="cb32-445"><a href="#cb32-445" aria-hidden="true" tabindex="-1"></a>    extend_idata<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb32-446"><a href="#cb32-446" aria-hidden="true" tabindex="-1"></a>    combined<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb32-447"><a href="#cb32-447" aria-hidden="true" tabindex="-1"></a>    random_seed<span class="op">=</span>rng,</span>
<span id="cb32-448"><a href="#cb32-448" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-449"><a href="#cb32-449" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-450"><a href="#cb32-450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-451"><a href="#cb32-451" aria-hidden="true" tabindex="-1"></a>How the recover contributions look like, If we compare to the real contributions?</span>
<span id="cb32-452"><a href="#cb32-452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-455"><a href="#cb32-455" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-456"><a href="#cb32-456" aria-hidden="true" tabindex="-1"></a>initial_model_recover_effect <span class="op">=</span> (</span>
<span id="cb32-457"><a href="#cb32-457" aria-hidden="true" tabindex="-1"></a>    az.hdi(mmm.fit_result[<span class="st">"channel_contributions"</span>], hdi_prob<span class="op">=</span><span class="fl">0.95</span>)</span>
<span id="cb32-458"><a href="#cb32-458" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> mmm.target_transformer[<span class="st">"scaler"</span>].scale_.item()</span>
<span id="cb32-459"><a href="#cb32-459" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-460"><a href="#cb32-460" aria-hidden="true" tabindex="-1"></a>initial_model_mean_effect <span class="op">=</span> (</span>
<span id="cb32-461"><a href="#cb32-461" aria-hidden="true" tabindex="-1"></a>    mmm.fit_result.channel_contributions.mean(dim<span class="op">=</span>[<span class="st">"chain"</span>, <span class="st">"draw"</span>])</span>
<span id="cb32-462"><a href="#cb32-462" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> mmm.target_transformer[<span class="st">"scaler"</span>].scale_.item()</span>
<span id="cb32-463"><a href="#cb32-463" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-464"><a href="#cb32-464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-465"><a href="#cb32-465" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">1</span>, sharex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-466"><a href="#cb32-466" aria-hidden="true" tabindex="-1"></a><span class="co"># x2 -&gt; online</span></span>
<span id="cb32-467"><a href="#cb32-467" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(</span>
<span id="cb32-468"><a href="#cb32-468" aria-hidden="true" tabindex="-1"></a>    date_range,</span>
<span id="cb32-469"><a href="#cb32-469" aria-hidden="true" tabindex="-1"></a>    initial_model_mean_effect.sel(channel<span class="op">=</span><span class="st">"x2"</span>),</span>
<span id="cb32-470"><a href="#cb32-470" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="st">"Mean Recover x2 Effect"</span>,</span>
<span id="cb32-471"><a href="#cb32-471" aria-hidden="true" tabindex="-1"></a>    linestyle<span class="op">=</span><span class="st">"--"</span>,</span>
<span id="cb32-472"><a href="#cb32-472" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span><span class="st">"orange"</span>,</span>
<span id="cb32-473"><a href="#cb32-473" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-474"><a href="#cb32-474" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].fill_between(</span>
<span id="cb32-475"><a href="#cb32-475" aria-hidden="true" tabindex="-1"></a>    date_range,</span>
<span id="cb32-476"><a href="#cb32-476" aria-hidden="true" tabindex="-1"></a>    initial_model_recover_effect.channel_contributions.isel(hdi<span class="op">=</span><span class="dv">0</span>).sel(channel<span class="op">=</span><span class="st">"x2"</span>),</span>
<span id="cb32-477"><a href="#cb32-477" aria-hidden="true" tabindex="-1"></a>    initial_model_recover_effect.channel_contributions.isel(hdi<span class="op">=</span><span class="dv">1</span>).sel(channel<span class="op">=</span><span class="st">"x2"</span>),</span>
<span id="cb32-478"><a href="#cb32-478" aria-hidden="true" tabindex="-1"></a>    alpha<span class="op">=</span><span class="fl">0.2</span>,</span>
<span id="cb32-479"><a href="#cb32-479" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="st">"95% Credible Interval"</span>,</span>
<span id="cb32-480"><a href="#cb32-480" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span><span class="st">"orange"</span>,</span>
<span id="cb32-481"><a href="#cb32-481" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-482"><a href="#cb32-482" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(</span>
<span id="cb32-483"><a href="#cb32-483" aria-hidden="true" tabindex="-1"></a>    date_range, df[<span class="st">"x2_adstock_saturated"</span>], label<span class="op">=</span><span class="st">"Real x2 Effect"</span>, color<span class="op">=</span><span class="st">"black"</span></span>
<span id="cb32-484"><a href="#cb32-484" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-485"><a href="#cb32-485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-486"><a href="#cb32-486" aria-hidden="true" tabindex="-1"></a><span class="co"># x3 -&gt; internal</span></span>
<span id="cb32-487"><a href="#cb32-487" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(</span>
<span id="cb32-488"><a href="#cb32-488" aria-hidden="true" tabindex="-1"></a>    date_range,</span>
<span id="cb32-489"><a href="#cb32-489" aria-hidden="true" tabindex="-1"></a>    initial_model_mean_effect.sel(channel<span class="op">=</span><span class="st">"x3"</span>),</span>
<span id="cb32-490"><a href="#cb32-490" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="st">"Mean Recover x3 Effect"</span>,</span>
<span id="cb32-491"><a href="#cb32-491" aria-hidden="true" tabindex="-1"></a>    linestyle<span class="op">=</span><span class="st">"--"</span>,</span>
<span id="cb32-492"><a href="#cb32-492" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span><span class="st">"green"</span>,</span>
<span id="cb32-493"><a href="#cb32-493" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-494"><a href="#cb32-494" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].fill_between(</span>
<span id="cb32-495"><a href="#cb32-495" aria-hidden="true" tabindex="-1"></a>    date_range,</span>
<span id="cb32-496"><a href="#cb32-496" aria-hidden="true" tabindex="-1"></a>    initial_model_recover_effect.channel_contributions.isel(hdi<span class="op">=</span><span class="dv">0</span>).sel(channel<span class="op">=</span><span class="st">"x3"</span>),</span>
<span id="cb32-497"><a href="#cb32-497" aria-hidden="true" tabindex="-1"></a>    initial_model_recover_effect.channel_contributions.isel(hdi<span class="op">=</span><span class="dv">1</span>).sel(channel<span class="op">=</span><span class="st">"x3"</span>),</span>
<span id="cb32-498"><a href="#cb32-498" aria-hidden="true" tabindex="-1"></a>    alpha<span class="op">=</span><span class="fl">0.2</span>,</span>
<span id="cb32-499"><a href="#cb32-499" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="st">"95% Credible Interval"</span>,</span>
<span id="cb32-500"><a href="#cb32-500" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span><span class="st">"green"</span>,</span>
<span id="cb32-501"><a href="#cb32-501" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-502"><a href="#cb32-502" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(</span>
<span id="cb32-503"><a href="#cb32-503" aria-hidden="true" tabindex="-1"></a>    date_range, df[<span class="st">"x3_adstock_saturated"</span>], label<span class="op">=</span><span class="st">"Real x3 Effect"</span>, color<span class="op">=</span><span class="st">"black"</span></span>
<span id="cb32-504"><a href="#cb32-504" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-505"><a href="#cb32-505" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-506"><a href="#cb32-506" aria-hidden="true" tabindex="-1"></a><span class="co"># formatting</span></span>
<span id="cb32-507"><a href="#cb32-507" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].legend()</span>
<span id="cb32-508"><a href="#cb32-508" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].legend()</span>
<span id="cb32-509"><a href="#cb32-509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-510"><a href="#cb32-510" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb32-511"><a href="#cb32-511" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].<span class="bu">set</span>(xlabel<span class="op">=</span><span class="st">"date"</span>)</span>
<span id="cb32-512"><a href="#cb32-512" aria-hidden="true" tabindex="-1"></a>fig.suptitle(<span class="st">"Media Contribution Recovery"</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb32-513"><a href="#cb32-513" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb32-514"><a href="#cb32-514" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-515"><a href="#cb32-515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-516"><a href="#cb32-516" aria-hidden="true" tabindex="-1"></a>As anticipated, the model fails to accurately reflect the true contributions, resulting in estimates that significantly deviate from the actual values. How can this occur, and why is this happening?</span>
<span id="cb32-517"><a href="#cb32-517" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-518"><a href="#cb32-518" aria-hidden="true" tabindex="-1"></a>The explanation is straightforward: by neglecting any causal structure, we inadvertently impose one onto the data. The issue lies in our assumption of the simplest causal framework, which rarely aligns with real-world complexity.</span>
<span id="cb32-519"><a href="#cb32-519" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-520"><a href="#cb32-520" aria-hidden="true" tabindex="-1"></a>What kind of causal structure are we implicitly assuming when we fit the model?</span>
<span id="cb32-521"><a href="#cb32-521" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-524"><a href="#cb32-524" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-525"><a href="#cb32-525" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize a directed graph</span></span>
<span id="cb32-526"><a href="#cb32-526" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph <span class="op">=</span> Digraph()</span>
<span id="cb32-527"><a href="#cb32-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-528"><a href="#cb32-528" aria-hidden="true" tabindex="-1"></a><span class="co"># Add nodes</span></span>
<span id="cb32-529"><a href="#cb32-529" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.node(<span class="st">"X1"</span>, <span class="st">"Offline"</span>)</span>
<span id="cb32-530"><a href="#cb32-530" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.node(<span class="st">"X2"</span>, <span class="st">"Online"</span>)</span>
<span id="cb32-531"><a href="#cb32-531" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.node(<span class="st">"X3"</span>, <span class="st">"Internal"</span>)</span>
<span id="cb32-532"><a href="#cb32-532" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.node(<span class="st">"E"</span>, <span class="st">"Exogenous variables"</span>, style<span class="op">=</span><span class="st">"dashed"</span>)</span>
<span id="cb32-533"><a href="#cb32-533" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.node(<span class="st">"T"</span>, <span class="st">"Target"</span>)</span>
<span id="cb32-534"><a href="#cb32-534" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-535"><a href="#cb32-535" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.edge(<span class="st">"E"</span>, <span class="st">"T"</span>, style<span class="op">=</span><span class="st">"dashed"</span>)</span>
<span id="cb32-536"><a href="#cb32-536" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.edge(<span class="st">"X1"</span>, <span class="st">"T"</span>)</span>
<span id="cb32-537"><a href="#cb32-537" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.edge(<span class="st">"X2"</span>, <span class="st">"T"</span>)</span>
<span id="cb32-538"><a href="#cb32-538" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.edge(<span class="st">"X3"</span>, <span class="st">"T"</span>)</span>
<span id="cb32-539"><a href="#cb32-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-540"><a href="#cb32-540" aria-hidden="true" tabindex="-1"></a><span class="co"># Render the graph to SVG and display it inline</span></span>
<span id="cb32-541"><a href="#cb32-541" aria-hidden="true" tabindex="-1"></a>svg_str <span class="op">=</span> naive_causal_mmm_graph.pipe(<span class="bu">format</span><span class="op">=</span><span class="st">"svg"</span>)</span>
<span id="cb32-542"><a href="#cb32-542" aria-hidden="true" tabindex="-1"></a>display(SVG(svg_str))</span>
<span id="cb32-543"><a href="#cb32-543" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-544"><a href="#cb32-544" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-545"><a href="#cb32-545" aria-hidden="true" tabindex="-1"></a>The DAG above represents the causal structure that we are implicitly assuming when we fit the model. Here all variables are independent of each other, and those impact directly the target variable.</span>
<span id="cb32-546"><a href="#cb32-546" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-547"><a href="#cb32-547" aria-hidden="true" tabindex="-1"></a>During the model development, we established a specific structure and flow for our data. We concluded that the impacts of our channels operate independently of each other. Moreover, we determined that if any component of our ecosystem is missing, its influence will be accounted for by the baseline term due to this equation. As you can see, even by adopting this basic model, we are making significant assumptions.</span>
<span id="cb32-548"><a href="#cb32-548" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-549"><a href="#cb32-549" aria-hidden="true" tabindex="-1"></a>On one hand, you are assuming that the impact is not linear by applying these transformations, and you are suggesting that the impact is positive and that there may be a maximum delay of a certain number of days.</span>
<span id="cb32-550"><a href="#cb32-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-551"><a href="#cb32-551" aria-hidden="true" tabindex="-1"></a>You've even defined the direction of your relationships. By defining these relationships and assuming no direct causal connections between our variables, we can conclude that, if the nature of their relationship is accurately represented by the provided equation, then by controlling the relevant channels, we could uncover their true effects.</span>
<span id="cb32-552"><a href="#cb32-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-553"><a href="#cb32-553" aria-hidden="true" tabindex="-1"></a>This leads us to which causal DAG we assume is correct, based on our previous assumptions. If you recognize this process, congratulations! You've created a generative model or Structural Causal Model, with a Structural Causal Equation, using PyMC-marketing.</span>
<span id="cb32-554"><a href="#cb32-554" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-555"><a href="#cb32-555" aria-hidden="true" tabindex="-1"></a>However, this Causal DAG does not depict the true Causal DAG. Since our PyMC model is structural and causal, we must ask: *What happens if I create a model with a different causal structure than the real one?*</span>
<span id="cb32-556"><a href="#cb32-556" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-557"><a href="#cb32-557" aria-hidden="true" tabindex="-1"></a>The answer is what we observed above, the model will not be able to recover the true causal structure.</span>
<span id="cb32-558"><a href="#cb32-558" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-559"><a href="#cb32-559" aria-hidden="true" tabindex="-1"></a><span class="fu"># Learning about generative models</span></span>
<span id="cb32-560"><a href="#cb32-560" aria-hidden="true" tabindex="-1"></a>Generative models are frameworks that describe how data could be produced in the real world. They outline a process by defining probability distributions for each component, simulating the creation of data from underlying random variables. This approach captures uncertainty and variability, providing a complete picture of the data generation mechanism.</span>
<span id="cb32-561"><a href="#cb32-561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-562"><a href="#cb32-562" aria-hidden="true" tabindex="-1"></a>In PyMC, this concept is at the core of every model. PyMC lets you explicitly define priors, likelihoods, and the structure of your data generation process. Even simple models built in PyMC carry an inherent generative assumption, making them flexible and robust in representing how data might naturally arise.</span>
<span id="cb32-563"><a href="#cb32-563" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-564"><a href="#cb32-564" aria-hidden="true" tabindex="-1"></a>This means that each possible graph with N number of variables can be a specific model. How many models could we specify if we have 5 variables for one target?</span>
<span id="cb32-565"><a href="#cb32-565" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-566"><a href="#cb32-566" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-569"><a href="#cb32-569" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-570"><a href="#cb32-570" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb32-571"><a href="#cb32-571" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> lru_cache</span>
<span id="cb32-572"><a href="#cb32-572" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-573"><a href="#cb32-573" aria-hidden="true" tabindex="-1"></a><span class="at">@lru_cache</span>(maxsize<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb32-574"><a href="#cb32-574" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dag_with_exactly_s_sources(n: <span class="bu">int</span>, s: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb32-575"><a href="#cb32-575" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb32-576"><a href="#cb32-576" aria-hidden="true" tabindex="-1"></a><span class="co">    Count DAGs with exactly s source nodes.</span></span>
<span id="cb32-577"><a href="#cb32-577" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-578"><a href="#cb32-578" aria-hidden="true" tabindex="-1"></a><span class="co">    Uses formula: S(n,s) = C(n,s) * sum[(-1)^j * C(n-s,j) * 2^((m-j)(m-j-1)/2) *</span></span>
<span id="cb32-579"><a href="#cb32-579" aria-hidden="true" tabindex="-1"></a><span class="co">    (2^(m-j)-1)^s] where m=n-s and j=0..m. When n=s, S(n,n)=1.</span></span>
<span id="cb32-580"><a href="#cb32-580" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-581"><a href="#cb32-581" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb32-582"><a href="#cb32-582" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb32-583"><a href="#cb32-583" aria-hidden="true" tabindex="-1"></a><span class="co">    n : int</span></span>
<span id="cb32-584"><a href="#cb32-584" aria-hidden="true" tabindex="-1"></a><span class="co">        Total number of labeled nodes</span></span>
<span id="cb32-585"><a href="#cb32-585" aria-hidden="true" tabindex="-1"></a><span class="co">    s : int</span></span>
<span id="cb32-586"><a href="#cb32-586" aria-hidden="true" tabindex="-1"></a><span class="co">        Number of source nodes</span></span>
<span id="cb32-587"><a href="#cb32-587" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-588"><a href="#cb32-588" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb32-589"><a href="#cb32-589" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb32-590"><a href="#cb32-590" aria-hidden="true" tabindex="-1"></a><span class="co">    int</span></span>
<span id="cb32-591"><a href="#cb32-591" aria-hidden="true" tabindex="-1"></a><span class="co">        Number of possible DAGs</span></span>
<span id="cb32-592"><a href="#cb32-592" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb32-593"><a href="#cb32-593" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> s:</span>
<span id="cb32-594"><a href="#cb32-594" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb32-595"><a href="#cb32-595" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb32-596"><a href="#cb32-596" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> n <span class="op">-</span> s</span>
<span id="cb32-597"><a href="#cb32-597" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb32-598"><a href="#cb32-598" aria-hidden="true" tabindex="-1"></a>        term <span class="op">=</span> (</span>
<span id="cb32-599"><a href="#cb32-599" aria-hidden="true" tabindex="-1"></a>            (<span class="op">-</span><span class="dv">1</span>) <span class="op">**</span> j</span>
<span id="cb32-600"><a href="#cb32-600" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span> math.comb(m, j)</span>
<span id="cb32-601"><a href="#cb32-601" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span> <span class="dv">2</span> <span class="op">**</span> (((m <span class="op">-</span> j) <span class="op">*</span> (m <span class="op">-</span> j <span class="op">-</span> <span class="dv">1</span>)) <span class="op">//</span> <span class="dv">2</span>)</span>
<span id="cb32-602"><a href="#cb32-602" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span> (<span class="dv">2</span> <span class="op">**</span> (m <span class="op">-</span> j) <span class="op">-</span> <span class="dv">1</span>) <span class="op">**</span> s</span>
<span id="cb32-603"><a href="#cb32-603" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb32-604"><a href="#cb32-604" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> term</span>
<span id="cb32-605"><a href="#cb32-605" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> math.comb(n, s) <span class="op">*</span> total</span>
<span id="cb32-606"><a href="#cb32-606" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-607"><a href="#cb32-607" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_valid_final_graphs_with_parents(num_regressors: <span class="bu">int</span>, num_parents: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb32-608"><a href="#cb32-608" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Count valid final graphs with parent node restrictions.</span></span>
<span id="cb32-609"><a href="#cb32-609" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-610"><a href="#cb32-610" aria-hidden="true" tabindex="-1"></a><span class="co">    The counting process has two main steps:</span></span>
<span id="cb32-611"><a href="#cb32-611" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-612"><a href="#cb32-612" aria-hidden="true" tabindex="-1"></a><span class="co">    1. Build a DAG among regressors where parents have no incoming edges:</span></span>
<span id="cb32-613"><a href="#cb32-613" aria-hidden="true" tabindex="-1"></a><span class="co">       - For non-parents (Q = num_regressors - num_parents), count DAGs with given sinks</span></span>
<span id="cb32-614"><a href="#cb32-614" aria-hidden="true" tabindex="-1"></a><span class="co">       - Parents can only have edges to non-parents (Q options each)</span></span>
<span id="cb32-615"><a href="#cb32-615" aria-hidden="true" tabindex="-1"></a><span class="co">       - Non-sink parents must have ≥1 outgoing edge (2^Q - 1 ways)</span></span>
<span id="cb32-616"><a href="#cb32-616" aria-hidden="true" tabindex="-1"></a><span class="co">       - Sink parents have no edges (1 way)</span></span>
<span id="cb32-617"><a href="#cb32-617" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-618"><a href="#cb32-618" aria-hidden="true" tabindex="-1"></a><span class="co">    2. Add edges from regressors to target:</span></span>
<span id="cb32-619"><a href="#cb32-619" aria-hidden="true" tabindex="-1"></a><span class="co">       - Sink regressors must connect to target</span></span>
<span id="cb32-620"><a href="#cb32-620" aria-hidden="true" tabindex="-1"></a><span class="co">       - Non-sink regressors optionally connect</span></span>
<span id="cb32-621"><a href="#cb32-621" aria-hidden="true" tabindex="-1"></a><span class="co">       - Yields factor 2^(num_regressors - total_sinks)</span></span>
<span id="cb32-622"><a href="#cb32-622" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-623"><a href="#cb32-623" aria-hidden="true" tabindex="-1"></a><span class="co">    The total count formula is:</span></span>
<span id="cb32-624"><a href="#cb32-624" aria-hidden="true" tabindex="-1"></a><span class="co">    sum_{s_p=0}^P sum_{s_q=1}^Q [binom(P,s_p) * (2^Q-1)^(P-s_p) *</span></span>
<span id="cb32-625"><a href="#cb32-625" aria-hidden="true" tabindex="-1"></a><span class="co">    (DAGs_Q_s_q) * 2^((P+Q)-(s_p+s_q))]</span></span>
<span id="cb32-626"><a href="#cb32-626" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-627"><a href="#cb32-627" aria-hidden="true" tabindex="-1"></a><span class="co">    where P = num_parents, Q = num_regressors - num_parents</span></span>
<span id="cb32-628"><a href="#cb32-628" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-629"><a href="#cb32-629" aria-hidden="true" tabindex="-1"></a><span class="co">    When Q = 0 (all regressors are parents), the final graph is unique.</span></span>
<span id="cb32-630"><a href="#cb32-630" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-631"><a href="#cb32-631" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb32-632"><a href="#cb32-632" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb32-633"><a href="#cb32-633" aria-hidden="true" tabindex="-1"></a><span class="co">    num_regressors : int</span></span>
<span id="cb32-634"><a href="#cb32-634" aria-hidden="true" tabindex="-1"></a><span class="co">        Total number of regressor nodes in the graph</span></span>
<span id="cb32-635"><a href="#cb32-635" aria-hidden="true" tabindex="-1"></a><span class="co">    num_parents : int</span></span>
<span id="cb32-636"><a href="#cb32-636" aria-hidden="true" tabindex="-1"></a><span class="co">        Number of designated parent nodes that cannot have incoming edges</span></span>
<span id="cb32-637"><a href="#cb32-637" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-638"><a href="#cb32-638" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb32-639"><a href="#cb32-639" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb32-640"><a href="#cb32-640" aria-hidden="true" tabindex="-1"></a><span class="co">    int</span></span>
<span id="cb32-641"><a href="#cb32-641" aria-hidden="true" tabindex="-1"></a><span class="co">        Total count of valid final graph configurations</span></span>
<span id="cb32-642"><a href="#cb32-642" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb32-643"><a href="#cb32-643" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> num_parents</span>
<span id="cb32-644"><a href="#cb32-644" aria-hidden="true" tabindex="-1"></a>    Q <span class="op">=</span> num_regressors <span class="op">-</span> num_parents  <span class="co"># non-parents</span></span>
<span id="cb32-645"><a href="#cb32-645" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> Q <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb32-646"><a href="#cb32-646" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"num_parents cannot exceed num_regressors"</span>)</span>
<span id="cb32-647"><a href="#cb32-647" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-648"><a href="#cb32-648" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Case where all regressors are parents: no DAG edges are allowed;</span></span>
<span id="cb32-649"><a href="#cb32-649" aria-hidden="true" tabindex="-1"></a>    <span class="co"># every node is isolated (and hence a sink),</span></span>
<span id="cb32-650"><a href="#cb32-650" aria-hidden="true" tabindex="-1"></a>    <span class="co"># so the regressor-to-target assignment is forced.</span></span>
<span id="cb32-651"><a href="#cb32-651" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> Q <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb32-652"><a href="#cb32-652" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb32-653"><a href="#cb32-653" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-654"><a href="#cb32-654" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb32-655"><a href="#cb32-655" aria-hidden="true" tabindex="-1"></a>    <span class="co"># s_p: number of parents that end up as sinks</span></span>
<span id="cb32-656"><a href="#cb32-656" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (i.e. with no outgoing edge to any non-parent)</span></span>
<span id="cb32-657"><a href="#cb32-657" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s_p <span class="kw">in</span> <span class="bu">range</span>(P <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb32-658"><a href="#cb32-658" aria-hidden="true" tabindex="-1"></a>        <span class="co"># For each parent:</span></span>
<span id="cb32-659"><a href="#cb32-659" aria-hidden="true" tabindex="-1"></a>        <span class="co">#   - If not a sink: choose at least one outgoing edge</span></span>
<span id="cb32-660"><a href="#cb32-660" aria-hidden="true" tabindex="-1"></a>        <span class="co">#     among Q non-parents: (2^Q - 1) ways.</span></span>
<span id="cb32-661"><a href="#cb32-661" aria-hidden="true" tabindex="-1"></a>        <span class="co">#   - If a sink: only 1 way (choose no outgoing edge).</span></span>
<span id="cb32-662"><a href="#cb32-662" aria-hidden="true" tabindex="-1"></a>        parent_config <span class="op">=</span> math.comb(P, s_p) <span class="op">*</span> ((<span class="dv">2</span><span class="op">**</span>Q <span class="op">-</span> <span class="dv">1</span>) <span class="op">**</span> (P <span class="op">-</span> s_p))</span>
<span id="cb32-663"><a href="#cb32-663" aria-hidden="true" tabindex="-1"></a>        <span class="co"># s_q: number of sinks among non-parents in the DAG on Q nodes.</span></span>
<span id="cb32-664"><a href="#cb32-664" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Note: Every DAG on at least one node has at least one sink.</span></span>
<span id="cb32-665"><a href="#cb32-665" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> s_q <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, Q <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb32-666"><a href="#cb32-666" aria-hidden="true" tabindex="-1"></a>            nonparent_count <span class="op">=</span> dag_with_exactly_s_sources(Q, s_q)</span>
<span id="cb32-667"><a href="#cb32-667" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Total sinks in the regressor</span></span>
<span id="cb32-668"><a href="#cb32-668" aria-hidden="true" tabindex="-1"></a>            <span class="co"># DAG is s_p (from parents) plus s_q (from non-parents)</span></span>
<span id="cb32-669"><a href="#cb32-669" aria-hidden="true" tabindex="-1"></a>            total_sinks <span class="op">=</span> s_p <span class="op">+</span> s_q</span>
<span id="cb32-670"><a href="#cb32-670" aria-hidden="true" tabindex="-1"></a>            <span class="co"># For each regressor that is not a sink,</span></span>
<span id="cb32-671"><a href="#cb32-671" aria-hidden="true" tabindex="-1"></a>            <span class="co"># the regressor-to-target edge is optional.</span></span>
<span id="cb32-672"><a href="#cb32-672" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Thus, a factor of 2^( (P+Q) - total_sinks ).</span></span>
<span id="cb32-673"><a href="#cb32-673" aria-hidden="true" tabindex="-1"></a>            assignment_factor <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> ((P <span class="op">+</span> Q) <span class="op">-</span> total_sinks)</span>
<span id="cb32-674"><a href="#cb32-674" aria-hidden="true" tabindex="-1"></a>            total <span class="op">+=</span> parent_config <span class="op">*</span> nonparent_count <span class="op">*</span> assignment_factor</span>
<span id="cb32-675"><a href="#cb32-675" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total</span>
<span id="cb32-676"><a href="#cb32-676" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-677"><a href="#cb32-677" aria-hidden="true" tabindex="-1"></a>possible_dags <span class="op">=</span> count_valid_final_graphs_with_parents(num_regressors<span class="op">=</span><span class="dv">5</span>, num_parents<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb32-678"><a href="#cb32-678" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of possible DAGs with two parents (Graphical/Generative Model): </span><span class="sc">{</span>possible_dags<span class="sc">:,}</span><span class="ss">"</span>)</span>
<span id="cb32-679"><a href="#cb32-679" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-680"><a href="#cb32-680" aria-hidden="true" tabindex="-1"></a>possible_dags <span class="op">=</span> count_valid_final_graphs_with_parents(num_regressors<span class="op">=</span><span class="dv">5</span>, num_parents<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb32-681"><a href="#cb32-681" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of possible DAGs with one parent (Graphical/Generative Model): </span><span class="sc">{</span>possible_dags<span class="sc">:,}</span><span class="ss">"</span>)</span>
<span id="cb32-682"><a href="#cb32-682" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-683"><a href="#cb32-683" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-684"><a href="#cb32-684" aria-hidden="true" tabindex="-1"></a>The number of possible models we can generate with two out of five variables as parents is around 12,000, while having just one parent increases that number to approximately 52,000. Interestingly, removing a single parent node triples the potential models we can create, effectively multiplying the number of possible scenarios.</span>
<span id="cb32-685"><a href="#cb32-685" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-686"><a href="#cb32-686" aria-hidden="true" tabindex="-1"></a>This sheds light on the challenges posed by large models:  </span>
<span id="cb32-687"><a href="#cb32-687" aria-hidden="true" tabindex="-1"></a>a) As the number of variables increases, the exponential growth in potential relationships becomes overwhelming, making it difficult to pinpoint our actual situation.  </span>
<span id="cb32-688"><a href="#cb32-688" aria-hidden="true" tabindex="-1"></a>b) With more variables, the likelihood of mistakenly controlling for the wrong variables also increases.</span>
<span id="cb32-689"><a href="#cb32-689" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-690"><a href="#cb32-690" aria-hidden="true" tabindex="-1"></a>This latter point aligns with our earlier observation: if we control for inappropriate variables, the model fails to recover the true causal structure.</span>
<span id="cb32-691"><a href="#cb32-691" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-692"><a href="#cb32-692" aria-hidden="true" tabindex="-1"></a>So, why is it problematic to control for certain variables? Every variable should add more explanatory power, no?. Let's start learning about structures to understand.</span>
<span id="cb32-693"><a href="#cb32-693" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-694"><a href="#cb32-694" aria-hidden="true" tabindex="-1"></a><span class="fu"># Learning about causal structures</span></span>
<span id="cb32-695"><a href="#cb32-695" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-696"><a href="#cb32-696" aria-hidden="true" tabindex="-1"></a>**Forks**: A fork is a causal structure where a single variable acts as a common cause for two or more other variables. This common cause transmits its influence to all its direct descendants. The existence of a fork creates confounding, making the relationship between the descendant variables appear related. Controlling for the common cause can effectively block the backdoor paths created by this structure.</span>
<span id="cb32-697"><a href="#cb32-697" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-698"><a href="#cb32-698" aria-hidden="true" tabindex="-1"></a>**Chains**: A chain represents a sequential causal pathway where one variable influences another, which in turn affects a third variable. This structure highlights the mediation process through which causal effects are transmitted. The intermediate variable acts as a mediator, carrying the influence from the initial cause to the final outcome. Analyzing chains helps distinguish between direct and indirect effects in a causal system. Controlling for the mediator inappropriately may block parts of the causal effect that are of interest.</span>
<span id="cb32-699"><a href="#cb32-699" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-700"><a href="#cb32-700" aria-hidden="true" tabindex="-1"></a>**Colliders**: A collider is a variable that is the common effect of two or more causal factors. It sits at the convergence of different causal paths and can introduce spurious associations when conditioned upon. Controlling for a collider can inadvertently open up non-causal, backdoor paths, leading to biased estimates. This phenomenon, known as collider bias, distorts the true relationships among the causal variables. Avoiding conditioning on colliders is crucial for maintaining the validity of causal models.</span>
<span id="cb32-701"><a href="#cb32-701" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-704"><a href="#cb32-704" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-705"><a href="#cb32-705" aria-hidden="true" tabindex="-1"></a><span class="co"># Create figure with 3 subplots</span></span>
<span id="cb32-706"><a href="#cb32-706" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2, ax3) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>,)</span>
<span id="cb32-707"><a href="#cb32-707" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-708"><a href="#cb32-708" aria-hidden="true" tabindex="-1"></a><span class="co"># Create collider DAG</span></span>
<span id="cb32-709"><a href="#cb32-709" aria-hidden="true" tabindex="-1"></a>collider <span class="op">=</span> Digraph()</span>
<span id="cb32-710"><a href="#cb32-710" aria-hidden="true" tabindex="-1"></a>collider.attr(rankdir<span class="op">=</span><span class="st">'TB'</span>)</span>
<span id="cb32-711"><a href="#cb32-711" aria-hidden="true" tabindex="-1"></a>collider.node(<span class="st">'A'</span>, <span class="st">'A'</span>)</span>
<span id="cb32-712"><a href="#cb32-712" aria-hidden="true" tabindex="-1"></a>collider.node(<span class="st">'B'</span>, <span class="st">'B'</span>)</span>
<span id="cb32-713"><a href="#cb32-713" aria-hidden="true" tabindex="-1"></a>collider.node(<span class="st">'C'</span>, <span class="st">'C'</span>)</span>
<span id="cb32-714"><a href="#cb32-714" aria-hidden="true" tabindex="-1"></a>collider.edge(<span class="st">'A'</span>, <span class="st">'C'</span>)</span>
<span id="cb32-715"><a href="#cb32-715" aria-hidden="true" tabindex="-1"></a>collider.edge(<span class="st">'B'</span>, <span class="st">'C'</span>)</span>
<span id="cb32-716"><a href="#cb32-716" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">'Collider (A→C←B)'</span>)</span>
<span id="cb32-717"><a href="#cb32-717" aria-hidden="true" tabindex="-1"></a>ax1.imshow(Image.<span class="bu">open</span>(BytesIO(collider.pipe(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>))))</span>
<span id="cb32-718"><a href="#cb32-718" aria-hidden="true" tabindex="-1"></a>ax1.axis(<span class="st">'off'</span>)</span>
<span id="cb32-719"><a href="#cb32-719" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-720"><a href="#cb32-720" aria-hidden="true" tabindex="-1"></a><span class="co"># Create fork DAG</span></span>
<span id="cb32-721"><a href="#cb32-721" aria-hidden="true" tabindex="-1"></a>fork <span class="op">=</span> Digraph()</span>
<span id="cb32-722"><a href="#cb32-722" aria-hidden="true" tabindex="-1"></a>fork.attr(rankdir<span class="op">=</span><span class="st">'TB'</span>)</span>
<span id="cb32-723"><a href="#cb32-723" aria-hidden="true" tabindex="-1"></a>fork.node(<span class="st">'A'</span>, <span class="st">'A'</span>)</span>
<span id="cb32-724"><a href="#cb32-724" aria-hidden="true" tabindex="-1"></a>fork.node(<span class="st">'B'</span>, <span class="st">'B'</span>)</span>
<span id="cb32-725"><a href="#cb32-725" aria-hidden="true" tabindex="-1"></a>fork.node(<span class="st">'C'</span>, <span class="st">'C'</span>)</span>
<span id="cb32-726"><a href="#cb32-726" aria-hidden="true" tabindex="-1"></a>fork.edge(<span class="st">'A'</span>, <span class="st">'B'</span>)</span>
<span id="cb32-727"><a href="#cb32-727" aria-hidden="true" tabindex="-1"></a>fork.edge(<span class="st">'A'</span>, <span class="st">'C'</span>)</span>
<span id="cb32-728"><a href="#cb32-728" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">'Fork (B←A→C)'</span>)</span>
<span id="cb32-729"><a href="#cb32-729" aria-hidden="true" tabindex="-1"></a>ax2.imshow(Image.<span class="bu">open</span>(BytesIO(fork.pipe(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>))))</span>
<span id="cb32-730"><a href="#cb32-730" aria-hidden="true" tabindex="-1"></a>ax2.axis(<span class="st">'off'</span>)</span>
<span id="cb32-731"><a href="#cb32-731" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-732"><a href="#cb32-732" aria-hidden="true" tabindex="-1"></a><span class="co"># Create chain DAG</span></span>
<span id="cb32-733"><a href="#cb32-733" aria-hidden="true" tabindex="-1"></a>chain <span class="op">=</span> Digraph()</span>
<span id="cb32-734"><a href="#cb32-734" aria-hidden="true" tabindex="-1"></a>chain.attr(rankdir<span class="op">=</span><span class="st">'TB'</span>)</span>
<span id="cb32-735"><a href="#cb32-735" aria-hidden="true" tabindex="-1"></a>chain.node(<span class="st">'A'</span>, <span class="st">'A'</span>)</span>
<span id="cb32-736"><a href="#cb32-736" aria-hidden="true" tabindex="-1"></a>chain.node(<span class="st">'B'</span>, <span class="st">'B'</span>)</span>
<span id="cb32-737"><a href="#cb32-737" aria-hidden="true" tabindex="-1"></a>chain.node(<span class="st">'C'</span>, <span class="st">'C'</span>)</span>
<span id="cb32-738"><a href="#cb32-738" aria-hidden="true" tabindex="-1"></a>chain.edge(<span class="st">'A'</span>, <span class="st">'B'</span>)</span>
<span id="cb32-739"><a href="#cb32-739" aria-hidden="true" tabindex="-1"></a>chain.edge(<span class="st">'B'</span>, <span class="st">'C'</span>)</span>
<span id="cb32-740"><a href="#cb32-740" aria-hidden="true" tabindex="-1"></a>ax3.set_title(<span class="st">'Chain (A→B→C)'</span>)</span>
<span id="cb32-741"><a href="#cb32-741" aria-hidden="true" tabindex="-1"></a>ax3.imshow(Image.<span class="bu">open</span>(BytesIO(chain.pipe(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>))))</span>
<span id="cb32-742"><a href="#cb32-742" aria-hidden="true" tabindex="-1"></a>ax3.axis(<span class="st">'off'</span>)</span>
<span id="cb32-743"><a href="#cb32-743" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-744"><a href="#cb32-744" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb32-745"><a href="#cb32-745" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb32-746"><a href="#cb32-746" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-747"><a href="#cb32-747" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-748"><a href="#cb32-748" aria-hidden="true" tabindex="-1"></a>Causal structures play a crucial role in various causal inference methods, serving as the foundation for their functionality. For instance, chain structures are key to methods like instrumental variables (IV). In IV analysis, this chain structure comes into play by introducing an instrument—a variable that impacts the exposure but does not directly affect the outcome, except through that exposure. This approach helps break the confounding path, allowing us to isolate the exogenous variation in treatment.</span>
<span id="cb32-749"><a href="#cb32-749" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-750"><a href="#cb32-750" aria-hidden="true" tabindex="-1"></a>As a result, it enables a consistent estimation of causal effects, even when we encounter endogeneity. Therefore, grasping chain structures is essential, as it not only supports the rationale behind IV methods but also underscores the significance of identifying valid instruments.</span>
<span id="cb32-751"><a href="#cb32-751" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-752"><a href="#cb32-752" aria-hidden="true" tabindex="-1"></a>If you're particularly interested in learning more about IVs, I recommend checking out a post by Anton Bugaev or heading to the fifth floor if you’re at Bolt.</span>
<span id="cb32-753"><a href="#cb32-753" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-754"><a href="#cb32-754" aria-hidden="true" tabindex="-1"></a>Ultimately, each of these causal structures exhibits different observational behaviors. This means that based on the observational data, we can deduce which structure is present, and consecuently determinate whats the right variable set to control.</span>
<span id="cb32-755"><a href="#cb32-755" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-756"><a href="#cb32-756" aria-hidden="true" tabindex="-1"></a>One thing to understand what to control is find out the parent nodes to avoid to control by mediators, we could identify this understanding the conditional dependencies.</span>
<span id="cb32-757"><a href="#cb32-757" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-758"><a href="#cb32-758" aria-hidden="true" tabindex="-1"></a><span class="fu"># Lets check conditional independencies</span></span>
<span id="cb32-759"><a href="#cb32-759" aria-hidden="true" tabindex="-1"></a>Conditional independence is a core concept in probability theory and statistics where two variables are independent of each other once a third variable is held constant. This means that, given the value of the conditioning variable, the two variables do not provide additional information about one another. In causal discovery, conditional independencies are crucial because they reveal the underlying structure of causal relationships in a model or a directed acyclic graph (DAG). By identifying these independencies, we can determine how variables are related to each other, or not.</span>
<span id="cb32-760"><a href="#cb32-760" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-761"><a href="#cb32-761" aria-hidden="true" tabindex="-1"></a>Bayesian regression models allow us to estimate the conditional expectation of an outcome given a set of predictors, effectively uncovering the underlying conditional probabilities. In a bayesian linear regression, for example, we estimate $E(Y \mid X) = \beta_0 + \beta_1X_1 + \ldots + \beta_kX_k$, which represents the average outcome $Y$ when the predictors $X_1, \dots, X_k$ are held at specific values.</span>
<span id="cb32-762"><a href="#cb32-762" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-763"><a href="#cb32-763" aria-hidden="true" tabindex="-1"></a>Let's define a function to build and sample a linear model from a formula.</span>
<span id="cb32-764"><a href="#cb32-764" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-767"><a href="#cb32-767" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-768"><a href="#cb32-768" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_and_sample_model(data: pd.DataFrame, formula: <span class="bu">str</span>):</span>
<span id="cb32-769"><a href="#cb32-769" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb32-770"><a href="#cb32-770" aria-hidden="true" tabindex="-1"></a><span class="co">    Build and sample a linear model from a formula.</span></span>
<span id="cb32-771"><a href="#cb32-771" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb32-772"><a href="#cb32-772" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Parse the formula to get target and channels</span></span>
<span id="cb32-773"><a href="#cb32-773" aria-hidden="true" tabindex="-1"></a>    target, channels <span class="op">=</span> formula.split(<span class="st">'~'</span>)</span>
<span id="cb32-774"><a href="#cb32-774" aria-hidden="true" tabindex="-1"></a>    target <span class="op">=</span> target.strip()</span>
<span id="cb32-775"><a href="#cb32-775" aria-hidden="true" tabindex="-1"></a>    channels <span class="op">=</span> [ch.strip() <span class="cf">for</span> ch <span class="kw">in</span> channels.split(<span class="st">'+'</span>) <span class="cf">if</span> ch.strip() <span class="op">!=</span> <span class="st">"1"</span>]</span>
<span id="cb32-776"><a href="#cb32-776" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-777"><a href="#cb32-777" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Define coordinates</span></span>
<span id="cb32-778"><a href="#cb32-778" aria-hidden="true" tabindex="-1"></a>    coordinates <span class="op">=</span> {<span class="st">"date"</span>: data.date.unique()}</span>
<span id="cb32-779"><a href="#cb32-779" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> channels:  <span class="co"># If there are regressors, include them in coordinates</span></span>
<span id="cb32-780"><a href="#cb32-780" aria-hidden="true" tabindex="-1"></a>        coordinates[<span class="st">"channel"</span>] <span class="op">=</span> channels</span>
<span id="cb32-781"><a href="#cb32-781" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-782"><a href="#cb32-782" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Filter the dataset based on the formula</span></span>
<span id="cb32-783"><a href="#cb32-783" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> pm.Model(coords<span class="op">=</span>coordinates) <span class="im">as</span> linear_model:</span>
<span id="cb32-784"><a href="#cb32-784" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Load Data in Model</span></span>
<span id="cb32-785"><a href="#cb32-785" aria-hidden="true" tabindex="-1"></a>        target_data <span class="op">=</span> pm.Data(<span class="st">"target"</span>, data[target].values, dims<span class="op">=</span><span class="st">"date"</span>)</span>
<span id="cb32-786"><a href="#cb32-786" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-787"><a href="#cb32-787" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Constant or intercept</span></span>
<span id="cb32-788"><a href="#cb32-788" aria-hidden="true" tabindex="-1"></a>        intercept <span class="op">=</span> pm.Gamma(<span class="st">"intercept"</span>, mu<span class="op">=</span><span class="dv">3</span>, sigma<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb32-789"><a href="#cb32-789" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-790"><a href="#cb32-790" aria-hidden="true" tabindex="-1"></a>        mu_var <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb32-791"><a href="#cb32-791" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-792"><a href="#cb32-792" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> channels:  <span class="co"># If there are regressors, include them</span></span>
<span id="cb32-793"><a href="#cb32-793" aria-hidden="true" tabindex="-1"></a>            regressors <span class="op">=</span> pm.Data(<span class="st">"regressors"</span>, data[channels].values, dims<span class="op">=</span>(<span class="st">"date"</span>, <span class="st">"channel"</span>))</span>
<span id="cb32-794"><a href="#cb32-794" aria-hidden="true" tabindex="-1"></a>            gamma <span class="op">=</span> pm.Normal(<span class="st">"gamma"</span>, mu<span class="op">=</span><span class="dv">3</span>, sigma<span class="op">=</span><span class="dv">2</span>, dims<span class="op">=</span><span class="st">"channel"</span>)</span>
<span id="cb32-795"><a href="#cb32-795" aria-hidden="true" tabindex="-1"></a>            mu_var <span class="op">+=</span> (regressors <span class="op">*</span> gamma).<span class="bu">sum</span>(axis<span class="op">=-</span><span class="dv">1</span>) <span class="op">+</span> intercept</span>
<span id="cb32-796"><a href="#cb32-796" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb32-797"><a href="#cb32-797" aria-hidden="true" tabindex="-1"></a>            mu_var <span class="op">+=</span> intercept</span>
<span id="cb32-798"><a href="#cb32-798" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-799"><a href="#cb32-799" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Likelihood</span></span>
<span id="cb32-800"><a href="#cb32-800" aria-hidden="true" tabindex="-1"></a>        pm.Normal(<span class="st">"likelihood"</span>, mu<span class="op">=</span>mu_var, sigma<span class="op">=</span>pm.Gamma(<span class="st">"sigma"</span>, mu<span class="op">=</span><span class="dv">2</span>, sigma<span class="op">=</span><span class="dv">3</span>), observed<span class="op">=</span>target_data, dims<span class="op">=</span><span class="st">"date"</span>)</span>
<span id="cb32-801"><a href="#cb32-801" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-802"><a href="#cb32-802" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sample</span></span>
<span id="cb32-803"><a href="#cb32-803" aria-hidden="true" tabindex="-1"></a>        idata <span class="op">=</span> pm.sample_prior_predictive(random_seed<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb32-804"><a href="#cb32-804" aria-hidden="true" tabindex="-1"></a>        idata.extend(</span>
<span id="cb32-805"><a href="#cb32-805" aria-hidden="true" tabindex="-1"></a>            pm.sample(tune<span class="op">=</span><span class="dv">1000</span>, draws<span class="op">=</span><span class="dv">500</span>, chains<span class="op">=</span><span class="dv">4</span>, random_seed<span class="op">=</span><span class="dv">42</span>, target_accept<span class="op">=</span><span class="fl">0.9</span>, nuts_sampler<span class="op">=</span><span class="st">"numpyro"</span>, progressbar<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb32-806"><a href="#cb32-806" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb32-807"><a href="#cb32-807" aria-hidden="true" tabindex="-1"></a>        pm.compute_log_likelihood(idata, progressbar<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb32-808"><a href="#cb32-808" aria-hidden="true" tabindex="-1"></a>        idata.extend(</span>
<span id="cb32-809"><a href="#cb32-809" aria-hidden="true" tabindex="-1"></a>            pm.sample_posterior_predictive(idata, random_seed<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb32-810"><a href="#cb32-810" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb32-811"><a href="#cb32-811" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-812"><a href="#cb32-812" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (idata, linear_model)</span>
<span id="cb32-813"><a href="#cb32-813" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-814"><a href="#cb32-814" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-815"><a href="#cb32-815" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-816"><a href="#cb32-816" aria-hidden="true" tabindex="-1"></a>Now, let's build and sample the models for each variable.</span>
<span id="cb32-819"><a href="#cb32-819" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-820"><a href="#cb32-820" aria-hidden="true" tabindex="-1"></a>idata1, model1 <span class="op">=</span> build_and_sample_model(</span>
<span id="cb32-821"><a href="#cb32-821" aria-hidden="true" tabindex="-1"></a>    scaled_df,</span>
<span id="cb32-822"><a href="#cb32-822" aria-hidden="true" tabindex="-1"></a>    <span class="st">"x1 ~ 1"</span></span>
<span id="cb32-823"><a href="#cb32-823" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-824"><a href="#cb32-824" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-825"><a href="#cb32-825" aria-hidden="true" tabindex="-1"></a>idata2, model2 <span class="op">=</span> build_and_sample_model(</span>
<span id="cb32-826"><a href="#cb32-826" aria-hidden="true" tabindex="-1"></a>    scaled_df,</span>
<span id="cb32-827"><a href="#cb32-827" aria-hidden="true" tabindex="-1"></a>    <span class="st">"x1 ~ x2 + 1"</span></span>
<span id="cb32-828"><a href="#cb32-828" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-829"><a href="#cb32-829" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-830"><a href="#cb32-830" aria-hidden="true" tabindex="-1"></a>idata3, model3 <span class="op">=</span> build_and_sample_model(</span>
<span id="cb32-831"><a href="#cb32-831" aria-hidden="true" tabindex="-1"></a>    scaled_df,</span>
<span id="cb32-832"><a href="#cb32-832" aria-hidden="true" tabindex="-1"></a>    <span class="st">"x1 ~ x3 + 1"</span></span>
<span id="cb32-833"><a href="#cb32-833" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-834"><a href="#cb32-834" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-835"><a href="#cb32-835" aria-hidden="true" tabindex="-1"></a>idata4, model4 <span class="op">=</span> build_and_sample_model(</span>
<span id="cb32-836"><a href="#cb32-836" aria-hidden="true" tabindex="-1"></a>    scaled_df,</span>
<span id="cb32-837"><a href="#cb32-837" aria-hidden="true" tabindex="-1"></a>    <span class="st">"x1 ~ x2 + x3 + 1"</span></span>
<span id="cb32-838"><a href="#cb32-838" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-839"><a href="#cb32-839" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-840"><a href="#cb32-840" aria-hidden="true" tabindex="-1"></a>_real_mean <span class="op">=</span> scaled_df[<span class="st">"x1"</span>].mean()</span>
<span id="cb32-841"><a href="#cb32-841" aria-hidden="true" tabindex="-1"></a>_estimated_mean1 <span class="op">=</span> idata1.posterior_predictive.likelihood.mean(dim<span class="op">=</span>[<span class="st">"date"</span>]).values.flatten()</span>
<span id="cb32-842"><a href="#cb32-842" aria-hidden="true" tabindex="-1"></a>_estimated_mean2 <span class="op">=</span> idata2.posterior_predictive.likelihood.mean(dim<span class="op">=</span>[<span class="st">"date"</span>]).values.flatten()</span>
<span id="cb32-843"><a href="#cb32-843" aria-hidden="true" tabindex="-1"></a>_estimated_mean3 <span class="op">=</span> idata3.posterior_predictive.likelihood.mean(dim<span class="op">=</span>[<span class="st">"date"</span>]).values.flatten()</span>
<span id="cb32-844"><a href="#cb32-844" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-845"><a href="#cb32-845" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(_estimated_mean1 <span class="op">-</span> _real_mean, label<span class="op">=</span><span class="st">'Estimated Mean f(x1 ~ 1)'</span>, fill<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-846"><a href="#cb32-846" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(_estimated_mean2 <span class="op">-</span> _real_mean, label<span class="op">=</span><span class="st">'Estimated Mean f(x1 ~ x2 + 1)'</span>, fill<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-847"><a href="#cb32-847" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(_estimated_mean3 <span class="op">-</span> _real_mean, label<span class="op">=</span><span class="st">'Estimated Mean f(x1 ~ x3 + 1)'</span>, fill<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-848"><a href="#cb32-848" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'Zero'</span>)</span>
<span id="cb32-849"><a href="#cb32-849" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb32-850"><a href="#cb32-850" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb32-851"><a href="#cb32-851" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-852"><a href="#cb32-852" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-853"><a href="#cb32-853" aria-hidden="true" tabindex="-1"></a>In a causal system where the true direction is $x_1$ to $x_2$, the joint distribution factorizes as</span>
<span id="cb32-854"><a href="#cb32-854" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb32-855"><a href="#cb32-855" aria-hidden="true" tabindex="-1"></a>P(x_1, x_2) = P(x_1) \, P(x_2 \mid x_1),</span>
<span id="cb32-856"><a href="#cb32-856" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb32-857"><a href="#cb32-857" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-858"><a href="#cb32-858" aria-hidden="true" tabindex="-1"></a>where $x_1$ is exogenous and independent of any effects. This structure reflects that $x_1$'s distribution remains unchanged regardless of the downstream variable $x_2$.</span>
<span id="cb32-859"><a href="#cb32-859" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-860"><a href="#cb32-860" aria-hidden="true" tabindex="-1"></a>When regressing $x_2$ on $x_1$, the model leverages the causal direction, and the conditional distribution $P(x_2 \mid do(x_1))$ is more concentrated than the marginal $P(x_2)$. This results in residuals that are centered around zero, indicating that most variability in $x_2$ is explained by $x_1$.</span>
<span id="cb32-861"><a href="#cb32-861" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-862"><a href="#cb32-862" aria-hidden="true" tabindex="-1"></a>In contrast, reversing the regression by modeling $x_1$ as a function of $x_2$ disrupts the causal order. The conditional distribution $P(x_1 \mid do(x2))$ deviates from the true marginal $P(x_1)$, as it attempts to capture the cause from its effect, which is not supported by the causal structure.</span>
<span id="cb32-863"><a href="#cb32-863" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-864"><a href="#cb32-864" aria-hidden="true" tabindex="-1"></a>The bias in the reverse regression arises because conditioning on $x_2$ introduces variability from the noise inherent in $x_2$. This misattribution conflates the independent variability of $x_1$ with that induced by $x_2$, leading to residuals that systematically deviate from zero. Respect to the null model, the residuals are further from zero.</span>
<span id="cb32-865"><a href="#cb32-865" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-866"><a href="#cb32-866" aria-hidden="true" tabindex="-1"></a>This discrepancy underscores the importance of preserving the correct causal direction to avoid bias, as reversing the regression violates the causal Markov condition.</span>
<span id="cb32-867"><a href="#cb32-867" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-868"><a href="#cb32-868" aria-hidden="true" tabindex="-1"></a>Using this logic, we can identify not only independent variables but also the candidate parents for each variable based on how they deviate from the null model.</span>
<span id="cb32-869"><a href="#cb32-869" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-872"><a href="#cb32-872" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-873"><a href="#cb32-873" aria-hidden="true" tabindex="-1"></a>idata1, model1 <span class="op">=</span> build_and_sample_model(</span>
<span id="cb32-874"><a href="#cb32-874" aria-hidden="true" tabindex="-1"></a>scaled_df,</span>
<span id="cb32-875"><a href="#cb32-875" aria-hidden="true" tabindex="-1"></a><span class="st">"x2 ~ 1"</span></span>
<span id="cb32-876"><a href="#cb32-876" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-877"><a href="#cb32-877" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-878"><a href="#cb32-878" aria-hidden="true" tabindex="-1"></a>idata2, model2 <span class="op">=</span> build_and_sample_model(</span>
<span id="cb32-879"><a href="#cb32-879" aria-hidden="true" tabindex="-1"></a>scaled_df,</span>
<span id="cb32-880"><a href="#cb32-880" aria-hidden="true" tabindex="-1"></a><span class="st">"x2 ~ x1 + 1"</span></span>
<span id="cb32-881"><a href="#cb32-881" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-882"><a href="#cb32-882" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-883"><a href="#cb32-883" aria-hidden="true" tabindex="-1"></a>idata3, model3 <span class="op">=</span> build_and_sample_model(</span>
<span id="cb32-884"><a href="#cb32-884" aria-hidden="true" tabindex="-1"></a>scaled_df,</span>
<span id="cb32-885"><a href="#cb32-885" aria-hidden="true" tabindex="-1"></a><span class="st">"x2 ~ x3 + 1"</span></span>
<span id="cb32-886"><a href="#cb32-886" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-887"><a href="#cb32-887" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-888"><a href="#cb32-888" aria-hidden="true" tabindex="-1"></a>idata4, model4 <span class="op">=</span> build_and_sample_model(</span>
<span id="cb32-889"><a href="#cb32-889" aria-hidden="true" tabindex="-1"></a>scaled_df,</span>
<span id="cb32-890"><a href="#cb32-890" aria-hidden="true" tabindex="-1"></a><span class="st">"x2 ~ x1 + x3 + 1"</span></span>
<span id="cb32-891"><a href="#cb32-891" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-892"><a href="#cb32-892" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-893"><a href="#cb32-893" aria-hidden="true" tabindex="-1"></a>_real_mean <span class="op">=</span> scaled_df[<span class="st">"x2"</span>].mean()</span>
<span id="cb32-894"><a href="#cb32-894" aria-hidden="true" tabindex="-1"></a>_estimated_mean1 <span class="op">=</span> idata1.posterior_predictive.likelihood.mean(dim<span class="op">=</span>[<span class="st">"date"</span>]).values.flatten()</span>
<span id="cb32-895"><a href="#cb32-895" aria-hidden="true" tabindex="-1"></a>_estimated_mean2 <span class="op">=</span> idata2.posterior_predictive.likelihood.mean(dim<span class="op">=</span>[<span class="st">"date"</span>]).values.flatten()</span>
<span id="cb32-896"><a href="#cb32-896" aria-hidden="true" tabindex="-1"></a>_estimated_mean3 <span class="op">=</span> idata3.posterior_predictive.likelihood.mean(dim<span class="op">=</span>[<span class="st">"date"</span>]).values.flatten()</span>
<span id="cb32-897"><a href="#cb32-897" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-898"><a href="#cb32-898" aria-hidden="true" tabindex="-1"></a><span class="co">#plot distribution of means and real mean as vertical line</span></span>
<span id="cb32-899"><a href="#cb32-899" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(_estimated_mean1 <span class="op">-</span> _real_mean, label<span class="op">=</span><span class="st">'Estimated Mean f(x2 ~ 1)'</span>, fill<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-900"><a href="#cb32-900" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(_estimated_mean2 <span class="op">-</span> _real_mean, label<span class="op">=</span><span class="st">'Estimated Mean f(x2 ~ x1 + 1)'</span>, fill<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-901"><a href="#cb32-901" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(_estimated_mean3 <span class="op">-</span> _real_mean, label<span class="op">=</span><span class="st">'Estimated Mean f(x2 ~ x3 + 1)'</span>, fill<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-902"><a href="#cb32-902" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'Zero'</span>)</span>
<span id="cb32-903"><a href="#cb32-903" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb32-904"><a href="#cb32-904" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb32-905"><a href="#cb32-905" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-906"><a href="#cb32-906" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-907"><a href="#cb32-907" aria-hidden="true" tabindex="-1"></a>Here we can see that the residuals are centered around zero when we regress the marginal probability of $x_2$, but they are closer to zero with a probability distribution narrower than the null model when we regress $x_2$ on $x_1$. This is a good sign that $x_1$ is a parent of $x_2$.</span>
<span id="cb32-908"><a href="#cb32-908" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-909"><a href="#cb32-909" aria-hidden="true" tabindex="-1"></a>We can repeat this process for all the variables in our dataset to start to identify the parents of each variable, and thus identifying sections of the true causal graph.</span>
<span id="cb32-910"><a href="#cb32-910" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-911"><a href="#cb32-911" aria-hidden="true" tabindex="-1"></a>Let's implement this in code.</span>
<span id="cb32-912"><a href="#cb32-912" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-913"><a href="#cb32-913" aria-hidden="true" tabindex="-1"></a><span class="fu"># Identifying Parent Candidates</span></span>
<span id="cb32-914"><a href="#cb32-914" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-915"><a href="#cb32-915" aria-hidden="true" tabindex="-1"></a>To systematically identify potential parent variables in our causal graph, we'll create a class that evaluates different regression models and compares their residual distributions. This approach leverages the principle that when we correctly model the causal direction, residuals should be more tightly centered around zero compared to misspecified models.</span>
<span id="cb32-916"><a href="#cb32-916" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-917"><a href="#cb32-917" aria-hidden="true" tabindex="-1"></a>::: {.callout-warning}</span>
<span id="cb32-918"><a href="#cb32-918" aria-hidden="true" tabindex="-1"></a>While this approach provides a good initial signal for causal relationships, it has limitations. The method assumes linear relationships, doesn't account for hidden confounders, and may struggle with complex causal structures. Results should be considered as preliminary evidence rather than definitive proof of causal relationships.</span>
<span id="cb32-919"><a href="#cb32-919" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb32-920"><a href="#cb32-920" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-921"><a href="#cb32-921" aria-hidden="true" tabindex="-1"></a>The <span class="in">`ParentCandidateIdentifier`</span> class below will:</span>
<span id="cb32-922"><a href="#cb32-922" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Run a baseline model with only an intercept</span>
<span id="cb32-923"><a href="#cb32-923" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Run models with each potential parent variable</span>
<span id="cb32-924"><a href="#cb32-924" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Compare how much probability mass is concentrated near zero in the residual distributions</span>
<span id="cb32-925"><a href="#cb32-925" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Identify variables that improve the model fit as potential parent candidates</span>
<span id="cb32-926"><a href="#cb32-926" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-929"><a href="#cb32-929" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-930"><a href="#cb32-930" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ParentCandidateIdentifier:</span>
<span id="cb32-931"><a href="#cb32-931" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data: pd.DataFrame, node: <span class="bu">str</span>, possible_parents: <span class="bu">list</span>, epsilon: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.005</span>):</span>
<span id="cb32-932"><a href="#cb32-932" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb32-933"><a href="#cb32-933" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters:</span></span>
<span id="cb32-934"><a href="#cb32-934" aria-hidden="true" tabindex="-1"></a><span class="co">            data: DataFrame containing your data.</span></span>
<span id="cb32-935"><a href="#cb32-935" aria-hidden="true" tabindex="-1"></a><span class="co">            node: The target variable for which to identify candidate parents.</span></span>
<span id="cb32-936"><a href="#cb32-936" aria-hidden="true" tabindex="-1"></a><span class="co">            possible_parents: A list of potential parent variable names.</span></span>
<span id="cb32-937"><a href="#cb32-937" aria-hidden="true" tabindex="-1"></a><span class="co">            epsilon: Threshold to define "mass around zero" (default 0.05).</span></span>
<span id="cb32-938"><a href="#cb32-938" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb32-939"><a href="#cb32-939" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.data <span class="op">=</span> data</span>
<span id="cb32-940"><a href="#cb32-940" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.node <span class="op">=</span> node</span>
<span id="cb32-941"><a href="#cb32-941" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.possible_parents <span class="op">=</span> possible_parents</span>
<span id="cb32-942"><a href="#cb32-942" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.epsilon <span class="op">=</span> epsilon</span>
<span id="cb32-943"><a href="#cb32-943" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.runs <span class="op">=</span> {}</span>
<span id="cb32-944"><a href="#cb32-944" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.results <span class="op">=</span> <span class="va">None</span></span>
<span id="cb32-945"><a href="#cb32-945" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-946"><a href="#cb32-946" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> build_and_sample_model(<span class="va">self</span>, formula: <span class="bu">str</span>):</span>
<span id="cb32-947"><a href="#cb32-947" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Wrapper for the sampling function."""</span></span>
<span id="cb32-948"><a href="#cb32-948" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> build_and_sample_model(<span class="va">self</span>.data, formula)</span>
<span id="cb32-949"><a href="#cb32-949" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-950"><a href="#cb32-950" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> compute_mass_around_zero(<span class="va">self</span>, idata, real_mean):</span>
<span id="cb32-951"><a href="#cb32-951" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb32-952"><a href="#cb32-952" aria-hidden="true" tabindex="-1"></a><span class="co">        Compute the fraction of posterior predictive likelihood samples</span></span>
<span id="cb32-953"><a href="#cb32-953" aria-hidden="true" tabindex="-1"></a><span class="co">        (averaged over dates) within epsilon of the real mean.</span></span>
<span id="cb32-954"><a href="#cb32-954" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb32-955"><a href="#cb32-955" aria-hidden="true" tabindex="-1"></a>        estimated_mean <span class="op">=</span> idata.posterior_predictive.likelihood.mean(dim<span class="op">=</span>[<span class="st">"date"</span>]).values.flatten()</span>
<span id="cb32-956"><a href="#cb32-956" aria-hidden="true" tabindex="-1"></a>        distribution <span class="op">=</span> estimated_mean <span class="op">-</span> real_mean</span>
<span id="cb32-957"><a href="#cb32-957" aria-hidden="true" tabindex="-1"></a>        mass <span class="op">=</span> np.mean(np.<span class="bu">abs</span>(distribution) <span class="op">&lt;</span> <span class="va">self</span>.epsilon)</span>
<span id="cb32-958"><a href="#cb32-958" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> mass, distribution</span>
<span id="cb32-959"><a href="#cb32-959" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-960"><a href="#cb32-960" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> run_all_models(<span class="va">self</span>):</span>
<span id="cb32-961"><a href="#cb32-961" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb32-962"><a href="#cb32-962" aria-hidden="true" tabindex="-1"></a><span class="co">        Run the intercept-only model and each individual parent's model,</span></span>
<span id="cb32-963"><a href="#cb32-963" aria-hidden="true" tabindex="-1"></a><span class="co">        storing the sampling results, mass, and error distributions.</span></span>
<span id="cb32-964"><a href="#cb32-964" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb32-965"><a href="#cb32-965" aria-hidden="true" tabindex="-1"></a>        real_mean <span class="op">=</span> <span class="va">self</span>.data[<span class="va">self</span>.node].mean()</span>
<span id="cb32-966"><a href="#cb32-966" aria-hidden="true" tabindex="-1"></a>        runs <span class="op">=</span> {}</span>
<span id="cb32-967"><a href="#cb32-967" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-968"><a href="#cb32-968" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Intercept-only model: P(node)</span></span>
<span id="cb32-969"><a href="#cb32-969" aria-hidden="true" tabindex="-1"></a>        formula_intercept <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>node<span class="sc">}</span><span class="ss"> ~ 1"</span></span>
<span id="cb32-970"><a href="#cb32-970" aria-hidden="true" tabindex="-1"></a>        idata_int, _ <span class="op">=</span> <span class="va">self</span>.build_and_sample_model(formula_intercept)</span>
<span id="cb32-971"><a href="#cb32-971" aria-hidden="true" tabindex="-1"></a>        mass_int, dist_int <span class="op">=</span> <span class="va">self</span>.compute_mass_around_zero(idata_int, real_mean)</span>
<span id="cb32-972"><a href="#cb32-972" aria-hidden="true" tabindex="-1"></a>        runs[<span class="st">"intercept_only"</span>] <span class="op">=</span> {</span>
<span id="cb32-973"><a href="#cb32-973" aria-hidden="true" tabindex="-1"></a>            <span class="st">"formula"</span>: formula_intercept,</span>
<span id="cb32-974"><a href="#cb32-974" aria-hidden="true" tabindex="-1"></a>            <span class="st">"idata"</span>: idata_int,</span>
<span id="cb32-975"><a href="#cb32-975" aria-hidden="true" tabindex="-1"></a>            <span class="st">"mass"</span>: mass_int,</span>
<span id="cb32-976"><a href="#cb32-976" aria-hidden="true" tabindex="-1"></a>            <span class="st">"distribution"</span>: dist_int</span>
<span id="cb32-977"><a href="#cb32-977" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb32-978"><a href="#cb32-978" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-979"><a href="#cb32-979" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Individual candidate parent models: P(node|parent)</span></span>
<span id="cb32-980"><a href="#cb32-980" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> parent <span class="kw">in</span> <span class="va">self</span>.possible_parents:</span>
<span id="cb32-981"><a href="#cb32-981" aria-hidden="true" tabindex="-1"></a>            formula_parent <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>node<span class="sc">}</span><span class="ss"> ~ </span><span class="sc">{</span>parent<span class="sc">}</span><span class="ss"> + 1"</span></span>
<span id="cb32-982"><a href="#cb32-982" aria-hidden="true" tabindex="-1"></a>            idata_parent, _ <span class="op">=</span> <span class="va">self</span>.build_and_sample_model(formula_parent)</span>
<span id="cb32-983"><a href="#cb32-983" aria-hidden="true" tabindex="-1"></a>            mass_parent, dist_parent <span class="op">=</span> <span class="va">self</span>.compute_mass_around_zero(idata_parent, real_mean)</span>
<span id="cb32-984"><a href="#cb32-984" aria-hidden="true" tabindex="-1"></a>            runs[<span class="ss">f"parent_</span><span class="sc">{</span>parent<span class="sc">}</span><span class="ss">"</span>] <span class="op">=</span> {</span>
<span id="cb32-985"><a href="#cb32-985" aria-hidden="true" tabindex="-1"></a>                <span class="st">"formula"</span>: formula_parent,</span>
<span id="cb32-986"><a href="#cb32-986" aria-hidden="true" tabindex="-1"></a>                <span class="st">"idata"</span>: idata_parent,</span>
<span id="cb32-987"><a href="#cb32-987" aria-hidden="true" tabindex="-1"></a>                <span class="st">"mass"</span>: mass_parent,</span>
<span id="cb32-988"><a href="#cb32-988" aria-hidden="true" tabindex="-1"></a>                <span class="st">"distribution"</span>: dist_parent</span>
<span id="cb32-989"><a href="#cb32-989" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb32-990"><a href="#cb32-990" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-991"><a href="#cb32-991" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.runs <span class="op">=</span> runs</span>
<span id="cb32-992"><a href="#cb32-992" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> runs</span>
<span id="cb32-993"><a href="#cb32-993" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-994"><a href="#cb32-994" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> identify_candidate_parents(<span class="va">self</span>):</span>
<span id="cb32-995"><a href="#cb32-995" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb32-996"><a href="#cb32-996" aria-hidden="true" tabindex="-1"></a><span class="co">        Runs all models (if not already run), compares the mass around zero,</span></span>
<span id="cb32-997"><a href="#cb32-997" aria-hidden="true" tabindex="-1"></a><span class="co">        and returns a decision: if the intercept-only model is best, the target</span></span>
<span id="cb32-998"><a href="#cb32-998" aria-hidden="true" tabindex="-1"></a><span class="co">        is independent; otherwise, return the candidate parent with the highest mass.</span></span>
<span id="cb32-999"><a href="#cb32-999" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb32-1000"><a href="#cb32-1000" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.runs:</span>
<span id="cb32-1001"><a href="#cb32-1001" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.run_all_models()</span>
<span id="cb32-1002"><a href="#cb32-1002" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1003"><a href="#cb32-1003" aria-hidden="true" tabindex="-1"></a>        best_key, best_info <span class="op">=</span> <span class="bu">max</span>(<span class="va">self</span>.runs.items(), key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>][<span class="st">"mass"</span>])</span>
<span id="cb32-1004"><a href="#cb32-1004" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1005"><a href="#cb32-1005" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> best_key <span class="op">==</span> <span class="st">"intercept_only"</span>:</span>
<span id="cb32-1006"><a href="#cb32-1006" aria-hidden="true" tabindex="-1"></a>            decision <span class="op">=</span> <span class="st">"independent"</span></span>
<span id="cb32-1007"><a href="#cb32-1007" aria-hidden="true" tabindex="-1"></a>            candidate_parents <span class="op">=</span> []</span>
<span id="cb32-1008"><a href="#cb32-1008" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb32-1009"><a href="#cb32-1009" aria-hidden="true" tabindex="-1"></a>            decision <span class="op">=</span> <span class="st">"dependent"</span></span>
<span id="cb32-1010"><a href="#cb32-1010" aria-hidden="true" tabindex="-1"></a>            candidate_parents <span class="op">=</span> [best_key.split(<span class="st">"_"</span>, <span class="dv">1</span>)[<span class="dv">1</span>]]</span>
<span id="cb32-1011"><a href="#cb32-1011" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1012"><a href="#cb32-1012" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.results <span class="op">=</span> {</span>
<span id="cb32-1013"><a href="#cb32-1013" aria-hidden="true" tabindex="-1"></a>            <span class="st">"results"</span>: <span class="va">self</span>.runs,</span>
<span id="cb32-1014"><a href="#cb32-1014" aria-hidden="true" tabindex="-1"></a>            <span class="st">"best_model"</span>: {best_key: best_info},</span>
<span id="cb32-1015"><a href="#cb32-1015" aria-hidden="true" tabindex="-1"></a>            <span class="st">"decision"</span>: decision,</span>
<span id="cb32-1016"><a href="#cb32-1016" aria-hidden="true" tabindex="-1"></a>            <span class="st">"candidate_parents"</span>: candidate_parents</span>
<span id="cb32-1017"><a href="#cb32-1017" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb32-1018"><a href="#cb32-1018" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.results</span>
<span id="cb32-1019"><a href="#cb32-1019" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1020"><a href="#cb32-1020" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> plot_distributions(<span class="va">self</span>):</span>
<span id="cb32-1021"><a href="#cb32-1021" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb32-1022"><a href="#cb32-1022" aria-hidden="true" tabindex="-1"></a><span class="co">        Plot the error distributions from the stored runs using Seaborn.</span></span>
<span id="cb32-1023"><a href="#cb32-1023" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb32-1024"><a href="#cb32-1024" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.runs:</span>
<span id="cb32-1025"><a href="#cb32-1025" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.run_all_models()</span>
<span id="cb32-1026"><a href="#cb32-1026" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1027"><a href="#cb32-1027" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> key, run <span class="kw">in</span> <span class="va">self</span>.runs.items():</span>
<span id="cb32-1028"><a href="#cb32-1028" aria-hidden="true" tabindex="-1"></a>            sns.kdeplot(run[<span class="st">"distribution"</span>], label<span class="op">=</span>run[<span class="st">"formula"</span>], fill<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-1029"><a href="#cb32-1029" aria-hidden="true" tabindex="-1"></a>        plt.axvline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'Zero Error'</span>)</span>
<span id="cb32-1030"><a href="#cb32-1030" aria-hidden="true" tabindex="-1"></a>        plt.xlabel(<span class="st">"Error (Estimated Mean - Real Mean)"</span>)</span>
<span id="cb32-1031"><a href="#cb32-1031" aria-hidden="true" tabindex="-1"></a>        plt.ylabel(<span class="st">"Density"</span>)</span>
<span id="cb32-1032"><a href="#cb32-1032" aria-hidden="true" tabindex="-1"></a>        plt.title(<span class="st">"Posterior Predictive Error Distributions"</span>)</span>
<span id="cb32-1033"><a href="#cb32-1033" aria-hidden="true" tabindex="-1"></a>        plt.legend()</span>
<span id="cb32-1034"><a href="#cb32-1034" aria-hidden="true" tabindex="-1"></a>        plt.show()</span>
<span id="cb32-1035"><a href="#cb32-1035" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1036"><a href="#cb32-1036" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1037"><a href="#cb32-1037" aria-hidden="true" tabindex="-1"></a>Now we can identify the candidate parents for each variable..</span>
<span id="cb32-1038"><a href="#cb32-1038" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1041"><a href="#cb32-1041" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-1042"><a href="#cb32-1042" aria-hidden="true" tabindex="-1"></a>identifier <span class="op">=</span> ParentCandidateIdentifier(data<span class="op">=</span>scaled_df, node<span class="op">=</span><span class="st">"x3"</span>, possible_parents<span class="op">=</span>[<span class="st">"x1"</span>, <span class="st">"x2"</span>], epsilon<span class="op">=</span><span class="fl">0.0005</span>)</span>
<span id="cb32-1043"><a href="#cb32-1043" aria-hidden="true" tabindex="-1"></a>decision_info <span class="op">=</span> identifier.identify_candidate_parents()</span>
<span id="cb32-1044"><a href="#cb32-1044" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Possible parents: "</span>, decision_info[<span class="st">"candidate_parents"</span>])</span>
<span id="cb32-1045"><a href="#cb32-1045" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1046"><a href="#cb32-1046" aria-hidden="true" tabindex="-1"></a>identifier.plot_distributions()</span>
<span id="cb32-1047"><a href="#cb32-1047" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1048"><a href="#cb32-1048" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1049"><a href="#cb32-1049" aria-hidden="true" tabindex="-1"></a>Understanding the conditional independencies of the variables in our dataset allows us to identify the parents of each variable. Currently, we have identified that $x_3$ and $x_2$ are children of $x_1$, and $x_1$ is independent or truly exogenous.</span>
<span id="cb32-1050"><a href="#cb32-1050" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1051"><a href="#cb32-1051" aria-hidden="true" tabindex="-1"></a>We can now use this information to update our causal graph.</span>
<span id="cb32-1052"><a href="#cb32-1052" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1055"><a href="#cb32-1055" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-1056"><a href="#cb32-1056" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize a directed graph</span></span>
<span id="cb32-1057"><a href="#cb32-1057" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph <span class="op">=</span> Digraph()</span>
<span id="cb32-1058"><a href="#cb32-1058" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1059"><a href="#cb32-1059" aria-hidden="true" tabindex="-1"></a><span class="co"># Add nodes</span></span>
<span id="cb32-1060"><a href="#cb32-1060" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.node(<span class="st">"X1"</span>, <span class="st">"Offline"</span>)</span>
<span id="cb32-1061"><a href="#cb32-1061" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.node(<span class="st">"X2"</span>, <span class="st">"Online"</span>)</span>
<span id="cb32-1062"><a href="#cb32-1062" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.node(<span class="st">"X3"</span>, <span class="st">"Internal"</span>)</span>
<span id="cb32-1063"><a href="#cb32-1063" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.node(<span class="st">"E"</span>, <span class="st">"Exogenous variables"</span>, style<span class="op">=</span><span class="st">"dashed"</span>)</span>
<span id="cb32-1064"><a href="#cb32-1064" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.node(<span class="st">"T"</span>, <span class="st">"Target"</span>)</span>
<span id="cb32-1065"><a href="#cb32-1065" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1066"><a href="#cb32-1066" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.edge(<span class="st">"E"</span>, <span class="st">"T"</span>, style<span class="op">=</span><span class="st">"dashed"</span>)</span>
<span id="cb32-1067"><a href="#cb32-1067" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.edge(<span class="st">"X1"</span>, <span class="st">"T"</span>)</span>
<span id="cb32-1068"><a href="#cb32-1068" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.edge(<span class="st">"X1"</span>,<span class="st">"X2"</span>)</span>
<span id="cb32-1069"><a href="#cb32-1069" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.edge(<span class="st">"X1"</span>,<span class="st">"X3"</span>)</span>
<span id="cb32-1070"><a href="#cb32-1070" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.edge(<span class="st">"X2"</span>, <span class="st">"T"</span>)</span>
<span id="cb32-1071"><a href="#cb32-1071" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.edge(<span class="st">"X3"</span>, <span class="st">"T"</span>)</span>
<span id="cb32-1072"><a href="#cb32-1072" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1073"><a href="#cb32-1073" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a figure with five subplots</span></span>
<span id="cb32-1074"><a href="#cb32-1074" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>,)</span>
<span id="cb32-1075"><a href="#cb32-1075" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1076"><a href="#cb32-1076" aria-hidden="true" tabindex="-1"></a><span class="co"># Set titles for each subplot</span></span>
<span id="cb32-1077"><a href="#cb32-1077" aria-hidden="true" tabindex="-1"></a>titles <span class="op">=</span> [<span class="st">"Naive DAG"</span>, <span class="st">"Updated DAG"</span>]</span>
<span id="cb32-1078"><a href="#cb32-1078" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, title <span class="kw">in</span> <span class="bu">zip</span>(axes, titles):</span>
<span id="cb32-1079"><a href="#cb32-1079" aria-hidden="true" tabindex="-1"></a>    ax.set_title(title, fontsize<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb32-1080"><a href="#cb32-1080" aria-hidden="true" tabindex="-1"></a>    ax.axis(<span class="st">'off'</span>)</span>
<span id="cb32-1081"><a href="#cb32-1081" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1082"><a href="#cb32-1082" aria-hidden="true" tabindex="-1"></a><span class="co"># Render and plot each graph</span></span>
<span id="cb32-1083"><a href="#cb32-1083" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/naive_dag'</span>)</span>
<span id="cb32-1084"><a href="#cb32-1084" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].imshow(mpimg.imread(<span class="st">'images/naive_dag.png'</span>))</span>
<span id="cb32-1085"><a href="#cb32-1085" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1086"><a href="#cb32-1086" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/updated_dag'</span>)</span>
<span id="cb32-1087"><a href="#cb32-1087" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].imshow(mpimg.imread(<span class="st">'images/updated_dag.png'</span>))</span>
<span id="cb32-1088"><a href="#cb32-1088" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1089"><a href="#cb32-1089" aria-hidden="true" tabindex="-1"></a><span class="co"># Add main title</span></span>
<span id="cb32-1090"><a href="#cb32-1090" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">"Comparison of DAG Graphs"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb32-1091"><a href="#cb32-1091" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb32-1092"><a href="#cb32-1092" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1093"><a href="#cb32-1093" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1094"><a href="#cb32-1094" aria-hidden="true" tabindex="-1"></a>Great, we can update our model of the world to include the causal relationships we have identified. How else can we use this information to learn more about the causal relationships in our dataset?</span>
<span id="cb32-1095"><a href="#cb32-1095" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1096"><a href="#cb32-1096" aria-hidden="true" tabindex="-1"></a><span class="fu"># Mediation analysis for the causal discovery</span></span>
<span id="cb32-1097"><a href="#cb32-1097" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1098"><a href="#cb32-1098" aria-hidden="true" tabindex="-1"></a>In mediation analysis, the total effect of a predictor $X1$ on a target $T$ is decomposed into direct and indirect components. The indirect effect operates through a mediator $M$, modeled as $M = \alpha_m + a \times X1 + \text{error}$. Simultaneously, the outcome is modeled as $T = \alpha_y + c' \times X1 + b \times M + \text{error}$. Here, the product $a \times b$ quantifies the indirect effect, while $c'$ represents the direct effect of $X1$ on $T$. By estimating these coefficients, we can assess whether the influence of $X1$ on $T$ is transmitted via $M$, entirely direct, or a combination of both. Statistical inference is performed using credible intervals, where intervals excluding zero indicate significant effects.</span>
<span id="cb32-1099"><a href="#cb32-1099" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1100"><a href="#cb32-1100" aria-hidden="true" tabindex="-1"></a>If the indirect effect $a \times b$ is significant and the direct effect $c'$ is not, we conclude that $X1$'s impact on $T$ is fully mediated by $M$. Conversely, significant values for both $a \times b$ and $c'$ suggest that $X1$ exerts both direct and indirect influences on $T$.</span>
<span id="cb32-1101"><a href="#cb32-1101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1102"><a href="#cb32-1102" aria-hidden="true" tabindex="-1"></a>In simple terms, mediation analysis helps us determine whether a predictor $X1$ influences an outcome $T$ directly or mainly by first affecting a mediator $M$, which then impacts $T$. If the mediator's effect is significant while the direct effect is not, it suggests that $X1$ affects $T$ primarily through its influence on $M$.</span>
<span id="cb32-1103"><a href="#cb32-1103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1104"><a href="#cb32-1104" aria-hidden="true" tabindex="-1"></a>Why do this on top of the causal discovery we have already done? The reason is that we can use the mediation analysis to verify the causal relationships we have identified, becuase if a node is parent the other then some effect is mediated, if we can detect that mediation, then we can decide if the causal relationship is direct or indirect. If we fail to detect mediation, then probably our findings are not robust to the causal discovery we have done.</span>
<span id="cb32-1107"><a href="#cb32-1107" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-1108"><a href="#cb32-1108" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MediationAnalysis:</span>
<span id="cb32-1109"><a href="#cb32-1109" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb32-1110"><a href="#cb32-1110" aria-hidden="true" tabindex="-1"></a><span class="co">    A class for performing Bayesian mediation analysis using a joint mediation model.</span></span>
<span id="cb32-1111"><a href="#cb32-1111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1112"><a href="#cb32-1112" aria-hidden="true" tabindex="-1"></a><span class="co">    The model is specified as:</span></span>
<span id="cb32-1113"><a href="#cb32-1113" aria-hidden="true" tabindex="-1"></a><span class="co">      Mediator:    M = α_m + a * X + error</span></span>
<span id="cb32-1114"><a href="#cb32-1114" aria-hidden="true" tabindex="-1"></a><span class="co">      Outcome:     Y = α_y + c′ * X + b * M + error</span></span>
<span id="cb32-1115"><a href="#cb32-1115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1116"><a href="#cb32-1116" aria-hidden="true" tabindex="-1"></a><span class="co">    Derived parameters:</span></span>
<span id="cb32-1117"><a href="#cb32-1117" aria-hidden="true" tabindex="-1"></a><span class="co">      - Indirect effect: ab = a * b</span></span>
<span id="cb32-1118"><a href="#cb32-1118" aria-hidden="true" tabindex="-1"></a><span class="co">      - Total effect:    c  = c′ + (a * b)</span></span>
<span id="cb32-1119"><a href="#cb32-1119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1120"><a href="#cb32-1120" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb32-1121"><a href="#cb32-1121" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb32-1122"><a href="#cb32-1122" aria-hidden="true" tabindex="-1"></a><span class="co">    data : pd.DataFrame</span></span>
<span id="cb32-1123"><a href="#cb32-1123" aria-hidden="true" tabindex="-1"></a><span class="co">        DataFrame containing the predictor, mediator, and outcome variables.</span></span>
<span id="cb32-1124"><a href="#cb32-1124" aria-hidden="true" tabindex="-1"></a><span class="co">    x : str</span></span>
<span id="cb32-1125"><a href="#cb32-1125" aria-hidden="true" tabindex="-1"></a><span class="co">        Column name for the predictor (X).</span></span>
<span id="cb32-1126"><a href="#cb32-1126" aria-hidden="true" tabindex="-1"></a><span class="co">    m : str</span></span>
<span id="cb32-1127"><a href="#cb32-1127" aria-hidden="true" tabindex="-1"></a><span class="co">        Column name for the mediator (M).</span></span>
<span id="cb32-1128"><a href="#cb32-1128" aria-hidden="true" tabindex="-1"></a><span class="co">    y : str</span></span>
<span id="cb32-1129"><a href="#cb32-1129" aria-hidden="true" tabindex="-1"></a><span class="co">        Column name for the outcome (Y).</span></span>
<span id="cb32-1130"><a href="#cb32-1130" aria-hidden="true" tabindex="-1"></a><span class="co">    hdi : float, optional</span></span>
<span id="cb32-1131"><a href="#cb32-1131" aria-hidden="true" tabindex="-1"></a><span class="co">        Credible interval width for HDI (default 0.95).</span></span>
<span id="cb32-1132"><a href="#cb32-1132" aria-hidden="true" tabindex="-1"></a><span class="co">    sampler_kwargs : dict, optional</span></span>
<span id="cb32-1133"><a href="#cb32-1133" aria-hidden="true" tabindex="-1"></a><span class="co">        Additional keyword arguments for the sampler.</span></span>
<span id="cb32-1134"><a href="#cb32-1134" aria-hidden="true" tabindex="-1"></a><span class="co">        Default: {"tune": 1000, "draws": 500, "chains": 4,</span></span>
<span id="cb32-1135"><a href="#cb32-1135" aria-hidden="true" tabindex="-1"></a><span class="co">                  "random_seed": 42, "target_accept": 0.9,</span></span>
<span id="cb32-1136"><a href="#cb32-1136" aria-hidden="true" tabindex="-1"></a><span class="co">                  "nuts_sampler": "numpyro", "progressbar": False}</span></span>
<span id="cb32-1137"><a href="#cb32-1137" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb32-1138"><a href="#cb32-1138" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data: pd.DataFrame, x: <span class="bu">str</span>, m: <span class="bu">str</span>, y: <span class="bu">str</span>, hdi: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.95</span>, sampler_kwargs: <span class="bu">dict</span> <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb32-1139"><a href="#cb32-1139" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.data <span class="op">=</span> data</span>
<span id="cb32-1140"><a href="#cb32-1140" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> x</span>
<span id="cb32-1141"><a href="#cb32-1141" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.m <span class="op">=</span> m</span>
<span id="cb32-1142"><a href="#cb32-1142" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.y <span class="op">=</span> y</span>
<span id="cb32-1143"><a href="#cb32-1143" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.hdi <span class="op">=</span> hdi</span>
<span id="cb32-1144"><a href="#cb32-1144" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sampler_kwargs <span class="op">=</span> sampler_kwargs <span class="kw">or</span> {</span>
<span id="cb32-1145"><a href="#cb32-1145" aria-hidden="true" tabindex="-1"></a>            <span class="st">"tune"</span>: <span class="dv">1000</span>,</span>
<span id="cb32-1146"><a href="#cb32-1146" aria-hidden="true" tabindex="-1"></a>            <span class="st">"draws"</span>: <span class="dv">500</span>,</span>
<span id="cb32-1147"><a href="#cb32-1147" aria-hidden="true" tabindex="-1"></a>            <span class="st">"chains"</span>: <span class="dv">4</span>,</span>
<span id="cb32-1148"><a href="#cb32-1148" aria-hidden="true" tabindex="-1"></a>            <span class="st">"random_seed"</span>: <span class="dv">42</span>,</span>
<span id="cb32-1149"><a href="#cb32-1149" aria-hidden="true" tabindex="-1"></a>            <span class="st">"target_accept"</span>: <span class="fl">0.9</span>,</span>
<span id="cb32-1150"><a href="#cb32-1150" aria-hidden="true" tabindex="-1"></a>            <span class="st">"nuts_sampler"</span>: <span class="st">"numpyro"</span>,</span>
<span id="cb32-1151"><a href="#cb32-1151" aria-hidden="true" tabindex="-1"></a>            <span class="st">"progressbar"</span>: <span class="va">False</span></span>
<span id="cb32-1152"><a href="#cb32-1152" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb32-1153"><a href="#cb32-1153" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.idata <span class="op">=</span> <span class="va">None</span></span>
<span id="cb32-1154"><a href="#cb32-1154" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.model <span class="op">=</span> <span class="va">None</span></span>
<span id="cb32-1155"><a href="#cb32-1155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1156"><a href="#cb32-1156" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> build_model(<span class="va">self</span>):</span>
<span id="cb32-1157"><a href="#cb32-1157" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb32-1158"><a href="#cb32-1158" aria-hidden="true" tabindex="-1"></a><span class="co">        Build the Bayesian mediation model.</span></span>
<span id="cb32-1159"><a href="#cb32-1159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1160"><a href="#cb32-1160" aria-hidden="true" tabindex="-1"></a><span class="co">        This method constructs the PyMC model and stores it in self.model.</span></span>
<span id="cb32-1161"><a href="#cb32-1161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1162"><a href="#cb32-1162" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb32-1163"><a href="#cb32-1163" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb32-1164"><a href="#cb32-1164" aria-hidden="true" tabindex="-1"></a><span class="co">        model : pm.Model</span></span>
<span id="cb32-1165"><a href="#cb32-1165" aria-hidden="true" tabindex="-1"></a><span class="co">            The constructed PyMC model.</span></span>
<span id="cb32-1166"><a href="#cb32-1166" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb32-1167"><a href="#cb32-1167" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract data arrays</span></span>
<span id="cb32-1168"><a href="#cb32-1168" aria-hidden="true" tabindex="-1"></a>        X_data <span class="op">=</span> <span class="va">self</span>.data[<span class="va">self</span>.x].values</span>
<span id="cb32-1169"><a href="#cb32-1169" aria-hidden="true" tabindex="-1"></a>        M_data <span class="op">=</span> <span class="va">self</span>.data[<span class="va">self</span>.m].values</span>
<span id="cb32-1170"><a href="#cb32-1170" aria-hidden="true" tabindex="-1"></a>        Y_data <span class="op">=</span> <span class="va">self</span>.data[<span class="va">self</span>.y].values</span>
<span id="cb32-1171"><a href="#cb32-1171" aria-hidden="true" tabindex="-1"></a>        N <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.data)</span>
<span id="cb32-1172"><a href="#cb32-1172" aria-hidden="true" tabindex="-1"></a>        coords <span class="op">=</span> {<span class="st">"obs"</span>: <span class="bu">range</span>(N)}</span>
<span id="cb32-1173"><a href="#cb32-1173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1174"><a href="#cb32-1174" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> pm.Model(coords<span class="op">=</span>coords) <span class="im">as</span> model:</span>
<span id="cb32-1175"><a href="#cb32-1175" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Mediator path: M = α_m + a * X + error</span></span>
<span id="cb32-1176"><a href="#cb32-1176" aria-hidden="true" tabindex="-1"></a>            alpha_m <span class="op">=</span> pm.Normal(<span class="st">"alpha_m"</span>, mu<span class="op">=</span><span class="fl">0.0</span>, sigma<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb32-1177"><a href="#cb32-1177" aria-hidden="true" tabindex="-1"></a>            a <span class="op">=</span> pm.Normal(<span class="st">"a"</span>, mu<span class="op">=</span><span class="fl">0.0</span>, sigma<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb32-1178"><a href="#cb32-1178" aria-hidden="true" tabindex="-1"></a>            sigma_m <span class="op">=</span> pm.Exponential(<span class="st">"sigma_m"</span>, lam<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb32-1179"><a href="#cb32-1179" aria-hidden="true" tabindex="-1"></a>            mu_m <span class="op">=</span> alpha_m <span class="op">+</span> a <span class="op">*</span> X_data</span>
<span id="cb32-1180"><a href="#cb32-1180" aria-hidden="true" tabindex="-1"></a>            pm.Normal(<span class="st">"M_obs"</span>, mu<span class="op">=</span>mu_m, sigma<span class="op">=</span>sigma_m, observed<span class="op">=</span>M_data, dims<span class="op">=</span><span class="st">"obs"</span>)</span>
<span id="cb32-1181"><a href="#cb32-1181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1182"><a href="#cb32-1182" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Outcome path: Y = α_y + c′ * X + b * M + error</span></span>
<span id="cb32-1183"><a href="#cb32-1183" aria-hidden="true" tabindex="-1"></a>            alpha_y <span class="op">=</span> pm.Normal(<span class="st">"alpha_y"</span>, mu<span class="op">=</span><span class="fl">0.0</span>, sigma<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb32-1184"><a href="#cb32-1184" aria-hidden="true" tabindex="-1"></a>            c_prime <span class="op">=</span> pm.Normal(<span class="st">"c_prime"</span>, mu<span class="op">=</span><span class="fl">0.0</span>, sigma<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb32-1185"><a href="#cb32-1185" aria-hidden="true" tabindex="-1"></a>            b <span class="op">=</span> pm.Normal(<span class="st">"b"</span>, mu<span class="op">=</span><span class="fl">0.0</span>, sigma<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb32-1186"><a href="#cb32-1186" aria-hidden="true" tabindex="-1"></a>            sigma_y <span class="op">=</span> pm.Exponential(<span class="st">"sigma_y"</span>, lam<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb32-1187"><a href="#cb32-1187" aria-hidden="true" tabindex="-1"></a>            mu_y <span class="op">=</span> alpha_y <span class="op">+</span> c_prime <span class="op">*</span> X_data <span class="op">+</span> b <span class="op">*</span> M_data</span>
<span id="cb32-1188"><a href="#cb32-1188" aria-hidden="true" tabindex="-1"></a>            pm.Normal(<span class="st">"Y_obs"</span>, mu<span class="op">=</span>mu_y, sigma<span class="op">=</span>sigma_y, observed<span class="op">=</span>Y_data, dims<span class="op">=</span><span class="st">"obs"</span>)</span>
<span id="cb32-1189"><a href="#cb32-1189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1190"><a href="#cb32-1190" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Derived parameters: indirect and total effects</span></span>
<span id="cb32-1191"><a href="#cb32-1191" aria-hidden="true" tabindex="-1"></a>            pm.Deterministic(<span class="st">"ab"</span>, a <span class="op">*</span> b)</span>
<span id="cb32-1192"><a href="#cb32-1192" aria-hidden="true" tabindex="-1"></a>            pm.Deterministic(<span class="st">"c"</span>, c_prime <span class="op">+</span> a <span class="op">*</span> b)</span>
<span id="cb32-1193"><a href="#cb32-1193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1194"><a href="#cb32-1194" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.model <span class="op">=</span> model</span>
<span id="cb32-1195"><a href="#cb32-1195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1196"><a href="#cb32-1196" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fit(<span class="va">self</span>):</span>
<span id="cb32-1197"><a href="#cb32-1197" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb32-1198"><a href="#cb32-1198" aria-hidden="true" tabindex="-1"></a><span class="co">        Sample from the previously built mediation model.</span></span>
<span id="cb32-1199"><a href="#cb32-1199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1200"><a href="#cb32-1200" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb32-1201"><a href="#cb32-1201" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb32-1202"><a href="#cb32-1202" aria-hidden="true" tabindex="-1"></a><span class="co">        self : MediationAnalysis</span></span>
<span id="cb32-1203"><a href="#cb32-1203" aria-hidden="true" tabindex="-1"></a><span class="co">            The fitted mediation analysis object.</span></span>
<span id="cb32-1204"><a href="#cb32-1204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1205"><a href="#cb32-1205" aria-hidden="true" tabindex="-1"></a><span class="co">        Raises</span></span>
<span id="cb32-1206"><a href="#cb32-1206" aria-hidden="true" tabindex="-1"></a><span class="co">        ------</span></span>
<span id="cb32-1207"><a href="#cb32-1207" aria-hidden="true" tabindex="-1"></a><span class="co">        ValueError</span></span>
<span id="cb32-1208"><a href="#cb32-1208" aria-hidden="true" tabindex="-1"></a><span class="co">            If the model has not been built yet.</span></span>
<span id="cb32-1209"><a href="#cb32-1209" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb32-1210"><a href="#cb32-1210" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.model <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb32-1211"><a href="#cb32-1211" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"The model has not been built. Call build_model() before fit()."</span>)</span>
<span id="cb32-1212"><a href="#cb32-1212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1213"><a href="#cb32-1213" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> <span class="va">self</span>.model:</span>
<span id="cb32-1214"><a href="#cb32-1214" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.idata <span class="op">=</span> pm.sample(<span class="op">**</span><span class="va">self</span>.sampler_kwargs)</span>
<span id="cb32-1215"><a href="#cb32-1215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1216"><a href="#cb32-1216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1217"><a href="#cb32-1217" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_summary(<span class="va">self</span>):</span>
<span id="cb32-1218"><a href="#cb32-1218" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb32-1219"><a href="#cb32-1219" aria-hidden="true" tabindex="-1"></a><span class="co">        Get a numerical summary of the mediation parameters.</span></span>
<span id="cb32-1220"><a href="#cb32-1220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1221"><a href="#cb32-1221" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb32-1222"><a href="#cb32-1222" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb32-1223"><a href="#cb32-1223" aria-hidden="true" tabindex="-1"></a><span class="co">        dict</span></span>
<span id="cb32-1224"><a href="#cb32-1224" aria-hidden="true" tabindex="-1"></a><span class="co">            Dictionary with mean estimates and HDI bounds for each parameter.</span></span>
<span id="cb32-1225"><a href="#cb32-1225" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb32-1226"><a href="#cb32-1226" aria-hidden="true" tabindex="-1"></a>        var_names <span class="op">=</span> [<span class="st">"alpha_m"</span>, <span class="st">"a"</span>, <span class="st">"alpha_y"</span>, <span class="st">"c_prime"</span>, <span class="st">"b"</span>, <span class="st">"ab"</span>, <span class="st">"c"</span>]</span>
<span id="cb32-1227"><a href="#cb32-1227" aria-hidden="true" tabindex="-1"></a>        summary_df <span class="op">=</span> az.summary(<span class="va">self</span>.idata, var_names<span class="op">=</span>var_names, hdi_prob<span class="op">=</span><span class="va">self</span>.hdi)</span>
<span id="cb32-1228"><a href="#cb32-1228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1229"><a href="#cb32-1229" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compute the HDI column names based on the specified interval</span></span>
<span id="cb32-1230"><a href="#cb32-1230" aria-hidden="true" tabindex="-1"></a>        lower_percent <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.hdi) <span class="op">/</span> <span class="dv">2</span> <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb32-1231"><a href="#cb32-1231" aria-hidden="true" tabindex="-1"></a>        upper_percent <span class="op">=</span> <span class="dv">100</span> <span class="op">-</span> lower_percent</span>
<span id="cb32-1232"><a href="#cb32-1232" aria-hidden="true" tabindex="-1"></a>        lower_col <span class="op">=</span> <span class="ss">f"hdi_</span><span class="sc">{</span>lower_percent<span class="sc">:.1f}</span><span class="ss">%"</span></span>
<span id="cb32-1233"><a href="#cb32-1233" aria-hidden="true" tabindex="-1"></a>        upper_col <span class="op">=</span> <span class="ss">f"hdi_</span><span class="sc">{</span>upper_percent<span class="sc">:.1f}</span><span class="ss">%"</span></span>
<span id="cb32-1234"><a href="#cb32-1234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1235"><a href="#cb32-1235" aria-hidden="true" tabindex="-1"></a>        results <span class="op">=</span> {}</span>
<span id="cb32-1236"><a href="#cb32-1236" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> key <span class="kw">in</span> var_names:</span>
<span id="cb32-1237"><a href="#cb32-1237" aria-hidden="true" tabindex="-1"></a>            results[key] <span class="op">=</span> {</span>
<span id="cb32-1238"><a href="#cb32-1238" aria-hidden="true" tabindex="-1"></a>                <span class="st">"mean"</span>: summary_df.loc[key, <span class="st">"mean"</span>],</span>
<span id="cb32-1239"><a href="#cb32-1239" aria-hidden="true" tabindex="-1"></a>                <span class="st">"hdi_lower"</span>: summary_df.loc[key, lower_col],</span>
<span id="cb32-1240"><a href="#cb32-1240" aria-hidden="true" tabindex="-1"></a>                <span class="st">"hdi_upper"</span>: summary_df.loc[key, upper_col]</span>
<span id="cb32-1241"><a href="#cb32-1241" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb32-1242"><a href="#cb32-1242" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> results</span>
<span id="cb32-1243"><a href="#cb32-1243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1244"><a href="#cb32-1244" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_report(<span class="va">self</span>, x_label: <span class="bu">str</span> <span class="op">=</span> <span class="va">None</span>, m_label: <span class="bu">str</span> <span class="op">=</span> <span class="va">None</span>, y_label: <span class="bu">str</span> <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb32-1245"><a href="#cb32-1245" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb32-1246"><a href="#cb32-1246" aria-hidden="true" tabindex="-1"></a><span class="co">        Generate a plain-language report of the mediation analysis results.</span></span>
<span id="cb32-1247"><a href="#cb32-1247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1248"><a href="#cb32-1248" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb32-1249"><a href="#cb32-1249" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb32-1250"><a href="#cb32-1250" aria-hidden="true" tabindex="-1"></a><span class="co">        x_label : str, optional</span></span>
<span id="cb32-1251"><a href="#cb32-1251" aria-hidden="true" tabindex="-1"></a><span class="co">            Label for the predictor variable (default uses self.x).</span></span>
<span id="cb32-1252"><a href="#cb32-1252" aria-hidden="true" tabindex="-1"></a><span class="co">        m_label : str, optional</span></span>
<span id="cb32-1253"><a href="#cb32-1253" aria-hidden="true" tabindex="-1"></a><span class="co">            Label for the mediator variable (default uses self.m).</span></span>
<span id="cb32-1254"><a href="#cb32-1254" aria-hidden="true" tabindex="-1"></a><span class="co">        y_label : str, optional</span></span>
<span id="cb32-1255"><a href="#cb32-1255" aria-hidden="true" tabindex="-1"></a><span class="co">            Label for the outcome variable (default uses self.y).</span></span>
<span id="cb32-1256"><a href="#cb32-1256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1257"><a href="#cb32-1257" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb32-1258"><a href="#cb32-1258" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb32-1259"><a href="#cb32-1259" aria-hidden="true" tabindex="-1"></a><span class="co">        str</span></span>
<span id="cb32-1260"><a href="#cb32-1260" aria-hidden="true" tabindex="-1"></a><span class="co">            A human-readable summary of the mediation effects.</span></span>
<span id="cb32-1261"><a href="#cb32-1261" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb32-1262"><a href="#cb32-1262" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Use provided labels or default to variable names</span></span>
<span id="cb32-1263"><a href="#cb32-1263" aria-hidden="true" tabindex="-1"></a>        x_label <span class="op">=</span> x_label <span class="kw">or</span> <span class="va">self</span>.x</span>
<span id="cb32-1264"><a href="#cb32-1264" aria-hidden="true" tabindex="-1"></a>        m_label <span class="op">=</span> m_label <span class="kw">or</span> <span class="va">self</span>.m</span>
<span id="cb32-1265"><a href="#cb32-1265" aria-hidden="true" tabindex="-1"></a>        y_label <span class="op">=</span> y_label <span class="kw">or</span> <span class="va">self</span>.y</span>
<span id="cb32-1266"><a href="#cb32-1266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1267"><a href="#cb32-1267" aria-hidden="true" tabindex="-1"></a>        var_names <span class="op">=</span> [<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c_prime"</span>, <span class="st">"ab"</span>, <span class="st">"c"</span>]</span>
<span id="cb32-1268"><a href="#cb32-1268" aria-hidden="true" tabindex="-1"></a>        summary_df <span class="op">=</span> az.summary(<span class="va">self</span>.idata, var_names<span class="op">=</span>var_names, hdi_prob<span class="op">=</span><span class="va">self</span>.hdi)</span>
<span id="cb32-1269"><a href="#cb32-1269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1270"><a href="#cb32-1270" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> hdi_includes_zero(row):</span>
<span id="cb32-1271"><a href="#cb32-1271" aria-hidden="true" tabindex="-1"></a>            lower_percent <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.hdi) <span class="op">/</span> <span class="dv">2</span> <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb32-1272"><a href="#cb32-1272" aria-hidden="true" tabindex="-1"></a>            upper_percent <span class="op">=</span> <span class="dv">100</span> <span class="op">-</span> lower_percent</span>
<span id="cb32-1273"><a href="#cb32-1273" aria-hidden="true" tabindex="-1"></a>            lower_col <span class="op">=</span> <span class="ss">f"hdi_</span><span class="sc">{</span>lower_percent<span class="sc">:.1f}</span><span class="ss">%"</span></span>
<span id="cb32-1274"><a href="#cb32-1274" aria-hidden="true" tabindex="-1"></a>            upper_col <span class="op">=</span> <span class="ss">f"hdi_</span><span class="sc">{</span>upper_percent<span class="sc">:.1f}</span><span class="ss">%"</span></span>
<span id="cb32-1275"><a href="#cb32-1275" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> row[lower_col] <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">&lt;=</span> row[upper_col]</span>
<span id="cb32-1276"><a href="#cb32-1276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1277"><a href="#cb32-1277" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract summary statistics</span></span>
<span id="cb32-1278"><a href="#cb32-1278" aria-hidden="true" tabindex="-1"></a>        a_stats <span class="op">=</span> summary_df.loc[<span class="st">"a"</span>]</span>
<span id="cb32-1279"><a href="#cb32-1279" aria-hidden="true" tabindex="-1"></a>        b_stats <span class="op">=</span> summary_df.loc[<span class="st">"b"</span>]</span>
<span id="cb32-1280"><a href="#cb32-1280" aria-hidden="true" tabindex="-1"></a>        c_prime_stats <span class="op">=</span> summary_df.loc[<span class="st">"c_prime"</span>]</span>
<span id="cb32-1281"><a href="#cb32-1281" aria-hidden="true" tabindex="-1"></a>        ab_stats <span class="op">=</span> summary_df.loc[<span class="st">"ab"</span>]</span>
<span id="cb32-1282"><a href="#cb32-1282" aria-hidden="true" tabindex="-1"></a>        c_stats <span class="op">=</span> summary_df.loc[<span class="st">"c"</span>]</span>
<span id="cb32-1283"><a href="#cb32-1283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1284"><a href="#cb32-1284" aria-hidden="true" tabindex="-1"></a>        a_mean <span class="op">=</span> a_stats[<span class="st">"mean"</span>]</span>
<span id="cb32-1285"><a href="#cb32-1285" aria-hidden="true" tabindex="-1"></a>        b_mean <span class="op">=</span> b_stats[<span class="st">"mean"</span>]</span>
<span id="cb32-1286"><a href="#cb32-1286" aria-hidden="true" tabindex="-1"></a>        c_prime_mean <span class="op">=</span> c_prime_stats[<span class="st">"mean"</span>]</span>
<span id="cb32-1287"><a href="#cb32-1287" aria-hidden="true" tabindex="-1"></a>        ab_mean <span class="op">=</span> ab_stats[<span class="st">"mean"</span>]</span>
<span id="cb32-1288"><a href="#cb32-1288" aria-hidden="true" tabindex="-1"></a>        c_mean <span class="op">=</span> c_stats[<span class="st">"mean"</span>]</span>
<span id="cb32-1289"><a href="#cb32-1289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1290"><a href="#cb32-1290" aria-hidden="true" tabindex="-1"></a>        a_zero <span class="op">=</span> hdi_includes_zero(a_stats)</span>
<span id="cb32-1291"><a href="#cb32-1291" aria-hidden="true" tabindex="-1"></a>        b_zero <span class="op">=</span> hdi_includes_zero(b_stats)</span>
<span id="cb32-1292"><a href="#cb32-1292" aria-hidden="true" tabindex="-1"></a>        c_prime_zero <span class="op">=</span> hdi_includes_zero(c_prime_stats)</span>
<span id="cb32-1293"><a href="#cb32-1293" aria-hidden="true" tabindex="-1"></a>        ab_zero <span class="op">=</span> hdi_includes_zero(ab_stats)</span>
<span id="cb32-1294"><a href="#cb32-1294" aria-hidden="true" tabindex="-1"></a>        c_zero <span class="op">=</span> hdi_includes_zero(c_stats)</span>
<span id="cb32-1295"><a href="#cb32-1295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1296"><a href="#cb32-1296" aria-hidden="true" tabindex="-1"></a>        lines <span class="op">=</span> []</span>
<span id="cb32-1297"><a href="#cb32-1297" aria-hidden="true" tabindex="-1"></a>        lines.append(<span class="ss">f"**Bayesian Mediation Analysis Overview** (</span><span class="sc">{</span><span class="bu">int</span>(<span class="va">self</span>.hdi <span class="op">*</span> <span class="dv">100</span>)<span class="sc">}</span><span class="ss">% HDI)"</span>)</span>
<span id="cb32-1298"><a href="#cb32-1298" aria-hidden="true" tabindex="-1"></a>        lines.append(<span class="ss">f"Variables: </span><span class="sc">{</span>x_label<span class="sc">}</span><span class="ss"> (predictor), </span><span class="sc">{</span>m_label<span class="sc">}</span><span class="ss"> (mediator), </span><span class="sc">{</span>y_label<span class="sc">}</span><span class="ss"> (outcome)."</span>)</span>
<span id="cb32-1299"><a href="#cb32-1299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1300"><a href="#cb32-1300" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Interpret each path</span></span>
<span id="cb32-1301"><a href="#cb32-1301" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> a_zero:</span>
<span id="cb32-1302"><a href="#cb32-1302" aria-hidden="true" tabindex="-1"></a>            direction <span class="op">=</span> <span class="st">"positive"</span> <span class="cf">if</span> a_mean <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="st">"negative"</span></span>
<span id="cb32-1303"><a href="#cb32-1303" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Path a (</span><span class="sc">{</span>x_label<span class="sc">}</span><span class="ss"> → </span><span class="sc">{</span>m_label<span class="sc">}</span><span class="ss">) is credibly </span><span class="sc">{</span>direction<span class="sc">}</span><span class="ss"> (mean = </span><span class="sc">{</span>a_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb32-1304"><a href="#cb32-1304" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb32-1305"><a href="#cb32-1305" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Path a (</span><span class="sc">{</span>x_label<span class="sc">}</span><span class="ss"> → </span><span class="sc">{</span>m_label<span class="sc">}</span><span class="ss">) is weak (HDI includes 0, mean = </span><span class="sc">{</span>a_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb32-1306"><a href="#cb32-1306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1307"><a href="#cb32-1307" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> b_zero:</span>
<span id="cb32-1308"><a href="#cb32-1308" aria-hidden="true" tabindex="-1"></a>            direction <span class="op">=</span> <span class="st">"positive"</span> <span class="cf">if</span> b_mean <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="st">"negative"</span></span>
<span id="cb32-1309"><a href="#cb32-1309" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Path b (</span><span class="sc">{</span>m_label<span class="sc">}</span><span class="ss"> → </span><span class="sc">{</span>y_label<span class="sc">}</span><span class="ss">, controlling for </span><span class="sc">{</span>x_label<span class="sc">}</span><span class="ss">) is credibly </span><span class="sc">{</span>direction<span class="sc">}</span><span class="ss"> (mean = </span><span class="sc">{</span>b_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb32-1310"><a href="#cb32-1310" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb32-1311"><a href="#cb32-1311" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Path b (</span><span class="sc">{</span>m_label<span class="sc">}</span><span class="ss"> → </span><span class="sc">{</span>y_label<span class="sc">}</span><span class="ss">, controlling for </span><span class="sc">{</span>x_label<span class="sc">}</span><span class="ss">) is weak (HDI includes 0, mean = </span><span class="sc">{</span>b_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb32-1312"><a href="#cb32-1312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1313"><a href="#cb32-1313" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> ab_zero:</span>
<span id="cb32-1314"><a href="#cb32-1314" aria-hidden="true" tabindex="-1"></a>            direction <span class="op">=</span> <span class="st">"positive"</span> <span class="cf">if</span> ab_mean <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="st">"negative"</span></span>
<span id="cb32-1315"><a href="#cb32-1315" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Indirect effect (a×b) is credibly </span><span class="sc">{</span>direction<span class="sc">}</span><span class="ss"> (mean = </span><span class="sc">{</span>ab_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb32-1316"><a href="#cb32-1316" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb32-1317"><a href="#cb32-1317" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Indirect effect (a×b) is uncertain (HDI includes 0, mean = </span><span class="sc">{</span>ab_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb32-1318"><a href="#cb32-1318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1319"><a href="#cb32-1319" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> c_prime_zero:</span>
<span id="cb32-1320"><a href="#cb32-1320" aria-hidden="true" tabindex="-1"></a>            direction <span class="op">=</span> <span class="st">"positive"</span> <span class="cf">if</span> c_prime_mean <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="st">"negative"</span></span>
<span id="cb32-1321"><a href="#cb32-1321" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Direct effect (c') is credibly </span><span class="sc">{</span>direction<span class="sc">}</span><span class="ss"> (mean = </span><span class="sc">{</span>c_prime_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb32-1322"><a href="#cb32-1322" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb32-1323"><a href="#cb32-1323" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Direct effect (c') is near zero (HDI includes 0, mean = </span><span class="sc">{</span>c_prime_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb32-1324"><a href="#cb32-1324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1325"><a href="#cb32-1325" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> c_zero:</span>
<span id="cb32-1326"><a href="#cb32-1326" aria-hidden="true" tabindex="-1"></a>            direction <span class="op">=</span> <span class="st">"positive"</span> <span class="cf">if</span> c_mean <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="st">"negative"</span></span>
<span id="cb32-1327"><a href="#cb32-1327" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Total effect (c) is credibly </span><span class="sc">{</span>direction<span class="sc">}</span><span class="ss"> (mean = </span><span class="sc">{</span>c_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb32-1328"><a href="#cb32-1328" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb32-1329"><a href="#cb32-1329" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"- Total effect (c) is uncertain (HDI includes 0, mean = </span><span class="sc">{</span>c_mean<span class="sc">:.3f}</span><span class="ss">)."</span>)</span>
<span id="cb32-1330"><a href="#cb32-1330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1331"><a href="#cb32-1331" aria-hidden="true" tabindex="-1"></a>        lines.append(<span class="st">""</span>)</span>
<span id="cb32-1332"><a href="#cb32-1332" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> ab_zero <span class="kw">and</span> c_prime_zero:</span>
<span id="cb32-1333"><a href="#cb32-1333" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"It appears that </span><span class="sc">{</span>m_label<span class="sc">}</span><span class="ss"> fully mediates the effect of </span><span class="sc">{</span>x_label<span class="sc">}</span><span class="ss"> on </span><span class="sc">{</span>y_label<span class="sc">}</span><span class="ss"> (indirect effect is non-zero while direct effect is near zero)."</span>)</span>
<span id="cb32-1334"><a href="#cb32-1334" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="kw">not</span> ab_zero <span class="kw">and</span> <span class="kw">not</span> c_prime_zero:</span>
<span id="cb32-1335"><a href="#cb32-1335" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="ss">f"It appears that </span><span class="sc">{</span>m_label<span class="sc">}</span><span class="ss"> partially mediates the effect of </span><span class="sc">{</span>x_label<span class="sc">}</span><span class="ss"> on </span><span class="sc">{</span>y_label<span class="sc">}</span><span class="ss"> (both indirect and direct effects are credibly non-zero)."</span>)</span>
<span id="cb32-1336"><a href="#cb32-1336" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb32-1337"><a href="#cb32-1337" aria-hidden="true" tabindex="-1"></a>            lines.append(<span class="st">"Mediation is unclear or absent (the indirect effect includes zero or the total effect is not clearly different from zero)."</span>)</span>
<span id="cb32-1338"><a href="#cb32-1338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1339"><a href="#cb32-1339" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>.join(lines)</span>
<span id="cb32-1340"><a href="#cb32-1340" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1341"><a href="#cb32-1341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1342"><a href="#cb32-1342" aria-hidden="true" tabindex="-1"></a>Let's run the mediation analysis for the first two variables.</span>
<span id="cb32-1345"><a href="#cb32-1345" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-1346"><a href="#cb32-1346" aria-hidden="true" tabindex="-1"></a>analysis1 <span class="op">=</span> MediationAnalysis(data<span class="op">=</span>scaled_df, x<span class="op">=</span><span class="st">"x1"</span>, m<span class="op">=</span><span class="st">"x2"</span>, y<span class="op">=</span><span class="st">"y"</span>)</span>
<span id="cb32-1347"><a href="#cb32-1347" aria-hidden="true" tabindex="-1"></a>analysis1.build_model()</span>
<span id="cb32-1348"><a href="#cb32-1348" aria-hidden="true" tabindex="-1"></a>analysis1.fit()</span>
<span id="cb32-1349"><a href="#cb32-1349" aria-hidden="true" tabindex="-1"></a>analysis1.get_summary()</span>
<span id="cb32-1350"><a href="#cb32-1350" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(analysis1.get_report())</span>
<span id="cb32-1351"><a href="#cb32-1351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1352"><a href="#cb32-1352" aria-hidden="true" tabindex="-1"></a>analysis2 <span class="op">=</span> MediationAnalysis(data<span class="op">=</span>scaled_df, x<span class="op">=</span><span class="st">"x1"</span>, m<span class="op">=</span><span class="st">"x3"</span>, y<span class="op">=</span><span class="st">"y"</span>)</span>
<span id="cb32-1353"><a href="#cb32-1353" aria-hidden="true" tabindex="-1"></a>analysis2.build_model()</span>
<span id="cb32-1354"><a href="#cb32-1354" aria-hidden="true" tabindex="-1"></a>analysis2.fit()</span>
<span id="cb32-1355"><a href="#cb32-1355" aria-hidden="true" tabindex="-1"></a>analysis2.get_summary()</span>
<span id="cb32-1356"><a href="#cb32-1356" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(analysis2.get_report())</span>
<span id="cb32-1357"><a href="#cb32-1357" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1358"><a href="#cb32-1358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1359"><a href="#cb32-1359" aria-hidden="true" tabindex="-1"></a>Great 👏🏻 Based on the following results we can conclude that $x_1$ affects $y$ through $x_2$ and $x_3$ but not directly. This conclusion is based on the indirect effect being significant and the direct effect being near zero when controlling for the mediator $x2$ and partial for $x3$.</span>
<span id="cb32-1360"><a href="#cb32-1360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1361"><a href="#cb32-1361" aria-hidden="true" tabindex="-1"></a>If both factor were present, the indirect effect would be stronger, given the previous results. So, for simplicity, we'll not test the mediation when both factors are present.</span>
<span id="cb32-1362"><a href="#cb32-1362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1363"><a href="#cb32-1363" aria-hidden="true" tabindex="-1"></a>We can again, update our causal graph to reflect the new findings.</span>
<span id="cb32-1364"><a href="#cb32-1364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1367"><a href="#cb32-1367" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-1368"><a href="#cb32-1368" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize a directed graph</span></span>
<span id="cb32-1369"><a href="#cb32-1369" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1 <span class="op">=</span> Digraph()</span>
<span id="cb32-1370"><a href="#cb32-1370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1371"><a href="#cb32-1371" aria-hidden="true" tabindex="-1"></a><span class="co"># Add nodes</span></span>
<span id="cb32-1372"><a href="#cb32-1372" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.node(<span class="st">"X1"</span>, <span class="st">"Offline"</span>)</span>
<span id="cb32-1373"><a href="#cb32-1373" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.node(<span class="st">"X2"</span>, <span class="st">"Online"</span>)</span>
<span id="cb32-1374"><a href="#cb32-1374" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.node(<span class="st">"X3"</span>, <span class="st">"Internal"</span>)</span>
<span id="cb32-1375"><a href="#cb32-1375" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.node(<span class="st">"E"</span>, <span class="st">"Exogenous variables"</span>, style<span class="op">=</span><span class="st">"dashed"</span>)</span>
<span id="cb32-1376"><a href="#cb32-1376" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.node(<span class="st">"T"</span>, <span class="st">"Target"</span>)</span>
<span id="cb32-1377"><a href="#cb32-1377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1378"><a href="#cb32-1378" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.edge(<span class="st">"E"</span>, <span class="st">"T"</span>, style<span class="op">=</span><span class="st">"dashed"</span>)</span>
<span id="cb32-1379"><a href="#cb32-1379" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.edge(<span class="st">"X1"</span>,<span class="st">"X2"</span>)</span>
<span id="cb32-1380"><a href="#cb32-1380" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.edge(<span class="st">"X1"</span>,<span class="st">"X3"</span>)</span>
<span id="cb32-1381"><a href="#cb32-1381" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.edge(<span class="st">"X2"</span>, <span class="st">"T"</span>)</span>
<span id="cb32-1382"><a href="#cb32-1382" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.edge(<span class="st">"X3"</span>, <span class="st">"T"</span>)</span>
<span id="cb32-1383"><a href="#cb32-1383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1384"><a href="#cb32-1384" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a figure with five subplots</span></span>
<span id="cb32-1385"><a href="#cb32-1385" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>,)</span>
<span id="cb32-1386"><a href="#cb32-1386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1387"><a href="#cb32-1387" aria-hidden="true" tabindex="-1"></a><span class="co"># Set titles for each subplot</span></span>
<span id="cb32-1388"><a href="#cb32-1388" aria-hidden="true" tabindex="-1"></a>titles <span class="op">=</span> [<span class="st">"Naive DAG"</span>, <span class="st">"Updated DAG V0"</span>, <span class="st">"Updated DAG V1"</span>]</span>
<span id="cb32-1389"><a href="#cb32-1389" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, title <span class="kw">in</span> <span class="bu">zip</span>(axes, titles):</span>
<span id="cb32-1390"><a href="#cb32-1390" aria-hidden="true" tabindex="-1"></a>    ax.set_title(title, fontsize<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb32-1391"><a href="#cb32-1391" aria-hidden="true" tabindex="-1"></a>    ax.axis(<span class="st">'off'</span>)</span>
<span id="cb32-1392"><a href="#cb32-1392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1393"><a href="#cb32-1393" aria-hidden="true" tabindex="-1"></a><span class="co"># Render and plot each graph</span></span>
<span id="cb32-1394"><a href="#cb32-1394" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/naive_dag'</span>)</span>
<span id="cb32-1395"><a href="#cb32-1395" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].imshow(mpimg.imread(<span class="st">'images/naive_dag.png'</span>))</span>
<span id="cb32-1396"><a href="#cb32-1396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1397"><a href="#cb32-1397" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/updated_dag'</span>)</span>
<span id="cb32-1398"><a href="#cb32-1398" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].imshow(mpimg.imread(<span class="st">'images/updated_dag.png'</span>))</span>
<span id="cb32-1399"><a href="#cb32-1399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1400"><a href="#cb32-1400" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/updated_dag1'</span>)</span>
<span id="cb32-1401"><a href="#cb32-1401" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].imshow(mpimg.imread(<span class="st">'images/updated_dag1.png'</span>))</span>
<span id="cb32-1402"><a href="#cb32-1402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1403"><a href="#cb32-1403" aria-hidden="true" tabindex="-1"></a><span class="co"># Add main title</span></span>
<span id="cb32-1404"><a href="#cb32-1404" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">"Comparison of DAG Graphs"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb32-1405"><a href="#cb32-1405" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb32-1406"><a href="#cb32-1406" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1407"><a href="#cb32-1407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1408"><a href="#cb32-1408" aria-hidden="true" tabindex="-1"></a>This is great! Our new causal graph is more complex, but it is more accurate to the one defined before. Nevertheless, we need a significant amount of time, and manual work to arrive to this conclusion.</span>
<span id="cb32-1409"><a href="#cb32-1409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1410"><a href="#cb32-1410" aria-hidden="true" tabindex="-1"></a>How could we automate this process? It's even possible? and how this would solve the intial problem?</span>
<span id="cb32-1411"><a href="#cb32-1411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1412"><a href="#cb32-1412" aria-hidden="true" tabindex="-1"></a>Yes, it is possible! We can use causal discovery algorithms to automate this process.</span>
<span id="cb32-1413"><a href="#cb32-1413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1414"><a href="#cb32-1414" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction to causal discovery</span></span>
<span id="cb32-1415"><a href="#cb32-1415" aria-hidden="true" tabindex="-1"></a>Causal discovery infers directional cause-and-effect relationships from observational data. It uses computational algorithms to construct directed acyclic graphs that represent potential causal mechanisms. These techniques are based on the causal Markov condition and the assumption of statistical faithfulness. They employ statistical tests for conditional independence to differentiate direct influences from indirect associations. This approach integrates statistical inference and graph theory to model complex systems. Overall, it uncovers hidden causal structures that enhance our understanding and estimations of dynamic phenomena.</span>
<span id="cb32-1416"><a href="#cb32-1416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1417"><a href="#cb32-1417" aria-hidden="true" tabindex="-1"></a><span class="at">&gt; Causal Markov Assumption: Each variable is independent of its non-effects given its direct causes, meaning that the joint probability distribution can be factorized according to the directed acyclic graph structure. This implies that once you condition on a variable's immediate causes, any further upstream or parallel influences are rendered statistically irrelevant.</span></span>
<span id="cb32-1418"><a href="#cb32-1418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1419"><a href="#cb32-1419" aria-hidden="true" tabindex="-1"></a><span class="at">&gt; Statistical Faithfulness: This assumption posits that all and only the conditional independence relations observed in the data are those implied by the causal graph. In other words, there are no accidental cancellations or coincidental independencies beyond what the causal structure predicts.</span></span>
<span id="cb32-1420"><a href="#cb32-1420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1421"><a href="#cb32-1421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1424"><a href="#cb32-1424" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-1425"><a href="#cb32-1425" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CausalDiscovery:</span>
<span id="cb32-1426"><a href="#cb32-1426" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data):</span>
<span id="cb32-1427"><a href="#cb32-1427" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.data <span class="op">=</span> data</span>
<span id="cb32-1428"><a href="#cb32-1428" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.labels <span class="op">=</span> [<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> col <span class="kw">in</span> data.columns.to_list()]</span>
<span id="cb32-1429"><a href="#cb32-1429" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1430"><a href="#cb32-1430" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> greedy_search(<span class="va">self</span>, <span class="op">**</span>kwargs):</span>
<span id="cb32-1431"><a href="#cb32-1431" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> ges(X<span class="op">=</span><span class="va">self</span>.data.to_numpy(), <span class="op">**</span>kwargs)</span>
<span id="cb32-1432"><a href="#cb32-1432" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result[<span class="st">"G"</span>]</span>
<span id="cb32-1433"><a href="#cb32-1433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1434"><a href="#cb32-1434" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> peter_clark(<span class="va">self</span>, <span class="op">**</span>kwargs):</span>
<span id="cb32-1435"><a href="#cb32-1435" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> pc(<span class="va">self</span>.data.to_numpy(), <span class="op">**</span>kwargs)</span>
<span id="cb32-1436"><a href="#cb32-1436" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result.G</span>
<span id="cb32-1437"><a href="#cb32-1437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1438"><a href="#cb32-1438" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> to_pydot(<span class="va">self</span>, graph):</span>
<span id="cb32-1439"><a href="#cb32-1439" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> GraphUtils.to_pydot(graph, labels<span class="op">=</span><span class="va">self</span>.labels)</span>
<span id="cb32-1440"><a href="#cb32-1440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1441"><a href="#cb32-1441" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> to_dict(<span class="va">self</span>, graph):</span>
<span id="cb32-1442"><a href="#cb32-1442" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb32-1443"><a href="#cb32-1443" aria-hidden="true" tabindex="-1"></a><span class="co">        Convert a general graph to a dictionary representation where each node is a key</span></span>
<span id="cb32-1444"><a href="#cb32-1444" aria-hidden="true" tabindex="-1"></a><span class="co">        and the value is a list of its descendants.</span></span>
<span id="cb32-1445"><a href="#cb32-1445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1446"><a href="#cb32-1446" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb32-1447"><a href="#cb32-1447" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb32-1448"><a href="#cb32-1448" aria-hidden="true" tabindex="-1"></a><span class="co">        graph : causallearn.graph.GeneralGraph.GeneralGraph</span></span>
<span id="cb32-1449"><a href="#cb32-1449" aria-hidden="true" tabindex="-1"></a><span class="co">            The input graph.</span></span>
<span id="cb32-1450"><a href="#cb32-1450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1451"><a href="#cb32-1451" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb32-1452"><a href="#cb32-1452" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb32-1453"><a href="#cb32-1453" aria-hidden="true" tabindex="-1"></a><span class="co">        dict</span></span>
<span id="cb32-1454"><a href="#cb32-1454" aria-hidden="true" tabindex="-1"></a><span class="co">            A dictionary where keys are node labels and values are lists of descendant node labels.</span></span>
<span id="cb32-1455"><a href="#cb32-1455" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb32-1456"><a href="#cb32-1456" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> {}</span>
<span id="cb32-1457"><a href="#cb32-1457" aria-hidden="true" tabindex="-1"></a>        nodes <span class="op">=</span> <span class="bu">sorted</span>(graph.get_nodes(), key<span class="op">=</span><span class="kw">lambda</span> x: <span class="bu">str</span>(x))</span>
<span id="cb32-1458"><a href="#cb32-1458" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1459"><a href="#cb32-1459" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Initialize the dictionary with empty lists for all nodes</span></span>
<span id="cb32-1460"><a href="#cb32-1460" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, node <span class="kw">in</span> <span class="bu">enumerate</span>(nodes):</span>
<span id="cb32-1461"><a href="#cb32-1461" aria-hidden="true" tabindex="-1"></a>            result[<span class="va">self</span>.labels[i]] <span class="op">=</span> []</span>
<span id="cb32-1462"><a href="#cb32-1462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1463"><a href="#cb32-1463" aria-hidden="true" tabindex="-1"></a>        <span class="co"># For each node, find its children (direct descendants)</span></span>
<span id="cb32-1464"><a href="#cb32-1464" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, node <span class="kw">in</span> <span class="bu">enumerate</span>(nodes):</span>
<span id="cb32-1465"><a href="#cb32-1465" aria-hidden="true" tabindex="-1"></a>            node_label <span class="op">=</span> <span class="va">self</span>.labels[i]</span>
<span id="cb32-1466"><a href="#cb32-1466" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j, potential_child <span class="kw">in</span> <span class="bu">enumerate</span>(nodes):</span>
<span id="cb32-1467"><a href="#cb32-1467" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="op">!=</span> j <span class="kw">and</span> graph.get_edge(node, potential_child) <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb32-1468"><a href="#cb32-1468" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Check if there's a directed edge from node to potential_child</span></span>
<span id="cb32-1469"><a href="#cb32-1469" aria-hidden="true" tabindex="-1"></a>                    edge <span class="op">=</span> graph.get_edge(node, potential_child)</span>
<span id="cb32-1470"><a href="#cb32-1470" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> (edge.get_endpoint1() <span class="op">==</span> Endpoint.TAIL <span class="kw">and</span></span>
<span id="cb32-1471"><a href="#cb32-1471" aria-hidden="true" tabindex="-1"></a>                        edge.get_endpoint2() <span class="op">==</span> Endpoint.ARROW):</span>
<span id="cb32-1472"><a href="#cb32-1472" aria-hidden="true" tabindex="-1"></a>                        result[node_label].append(<span class="va">self</span>.labels[j])</span>
<span id="cb32-1473"><a href="#cb32-1473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1474"><a href="#cb32-1474" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result</span>
<span id="cb32-1475"><a href="#cb32-1475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1476"><a href="#cb32-1476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1477"><a href="#cb32-1477" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> to_graphviz(<span class="va">self</span>, graph, handle_circle<span class="op">=</span><span class="st">"skip"</span>):</span>
<span id="cb32-1478"><a href="#cb32-1478" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb32-1479"><a href="#cb32-1479" aria-hidden="true" tabindex="-1"></a><span class="co">        Convert a general graph into a Graphviz Digraph using the pydot conversion</span></span>
<span id="cb32-1480"><a href="#cb32-1480" aria-hidden="true" tabindex="-1"></a><span class="co">        for nodes while preserving the original directed edge ordering.</span></span>
<span id="cb32-1481"><a href="#cb32-1481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1482"><a href="#cb32-1482" aria-hidden="true" tabindex="-1"></a><span class="co">        Only if the original graph indicates that an edge is undirected (both endpoints</span></span>
<span id="cb32-1483"><a href="#cb32-1483" aria-hidden="true" tabindex="-1"></a><span class="co">        are TAIL) do we override the arrow style (using dir="none"). Otherwise, we leave</span></span>
<span id="cb32-1484"><a href="#cb32-1484" aria-hidden="true" tabindex="-1"></a><span class="co">        the pydot-provided direction unchanged.</span></span>
<span id="cb32-1485"><a href="#cb32-1485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1486"><a href="#cb32-1486" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb32-1487"><a href="#cb32-1487" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb32-1488"><a href="#cb32-1488" aria-hidden="true" tabindex="-1"></a><span class="co">        graph : causallearn.graph.GeneralGraph.GeneralGraph</span></span>
<span id="cb32-1489"><a href="#cb32-1489" aria-hidden="true" tabindex="-1"></a><span class="co">            The input graph.</span></span>
<span id="cb32-1490"><a href="#cb32-1490" aria-hidden="true" tabindex="-1"></a><span class="co">        handle_circle : str, optional</span></span>
<span id="cb32-1491"><a href="#cb32-1491" aria-hidden="true" tabindex="-1"></a><span class="co">            How to handle circle endpoints (not used explicitly here but available for future logic).</span></span>
<span id="cb32-1492"><a href="#cb32-1492" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1493"><a href="#cb32-1493" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb32-1494"><a href="#cb32-1494" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb32-1495"><a href="#cb32-1495" aria-hidden="true" tabindex="-1"></a><span class="co">        graphviz.Digraph</span></span>
<span id="cb32-1496"><a href="#cb32-1496" aria-hidden="true" tabindex="-1"></a><span class="co">            A Graphviz Digraph where undirected edges are rendered without arrowheads.</span></span>
<span id="cb32-1497"><a href="#cb32-1497" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb32-1498"><a href="#cb32-1498" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Get the pydot graph (for node positions/labels)</span></span>
<span id="cb32-1499"><a href="#cb32-1499" aria-hidden="true" tabindex="-1"></a>        dot <span class="op">=</span> <span class="va">self</span>.to_pydot(graph)</span>
<span id="cb32-1500"><a href="#cb32-1500" aria-hidden="true" tabindex="-1"></a>        digraph <span class="op">=</span> Digraph()</span>
<span id="cb32-1501"><a href="#cb32-1501" aria-hidden="true" tabindex="-1"></a>        digraph.attr(size<span class="op">=</span><span class="st">'8,8'</span>)</span>
<span id="cb32-1502"><a href="#cb32-1502" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1503"><a href="#cb32-1503" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Build a mapping of the original graph nodes based on sorted order.</span></span>
<span id="cb32-1504"><a href="#cb32-1504" aria-hidden="true" tabindex="-1"></a>        original_nodes <span class="op">=</span> <span class="bu">sorted</span>(graph.get_nodes(), key<span class="op">=</span><span class="kw">lambda</span> x: <span class="bu">str</span>(x))</span>
<span id="cb32-1505"><a href="#cb32-1505" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Map string indices ("0", "1", …) to the original nodes.</span></span>
<span id="cb32-1506"><a href="#cb32-1506" aria-hidden="true" tabindex="-1"></a>        index_to_node <span class="op">=</span> {<span class="bu">str</span>(i): node <span class="cf">for</span> i, node <span class="kw">in</span> <span class="bu">enumerate</span>(original_nodes)}</span>
<span id="cb32-1507"><a href="#cb32-1507" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Map indices to labels using self.labels.</span></span>
<span id="cb32-1508"><a href="#cb32-1508" aria-hidden="true" tabindex="-1"></a>        node_labels <span class="op">=</span> {<span class="bu">str</span>(i): <span class="va">self</span>.labels[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(original_nodes))}</span>
<span id="cb32-1509"><a href="#cb32-1509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1510"><a href="#cb32-1510" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add nodes to the Graphviz Digraph.</span></span>
<span id="cb32-1511"><a href="#cb32-1511" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> idx_str, label <span class="kw">in</span> node_labels.items():</span>
<span id="cb32-1512"><a href="#cb32-1512" aria-hidden="true" tabindex="-1"></a>            digraph.node(label)</span>
<span id="cb32-1513"><a href="#cb32-1513" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1514"><a href="#cb32-1514" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Process each edge from the pydot graph.</span></span>
<span id="cb32-1515"><a href="#cb32-1515" aria-hidden="true" tabindex="-1"></a>        processed <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb32-1516"><a href="#cb32-1516" aria-hidden="true" tabindex="-1"></a>        pydot_edges <span class="op">=</span> dot.get_edges()</span>
<span id="cb32-1517"><a href="#cb32-1517" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1518"><a href="#cb32-1518" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> edge <span class="kw">in</span> pydot_edges:</span>
<span id="cb32-1519"><a href="#cb32-1519" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Get source and destination from pydot.</span></span>
<span id="cb32-1520"><a href="#cb32-1520" aria-hidden="true" tabindex="-1"></a>            src_raw <span class="op">=</span> edge.get_source()</span>
<span id="cb32-1521"><a href="#cb32-1521" aria-hidden="true" tabindex="-1"></a>            dst_raw <span class="op">=</span> edge.get_destination()</span>
<span id="cb32-1522"><a href="#cb32-1522" aria-hidden="true" tabindex="-1"></a>            src_str <span class="op">=</span> src_raw.strip(<span class="st">'"'</span>) <span class="cf">if</span> <span class="bu">isinstance</span>(src_raw, <span class="bu">str</span>) <span class="cf">else</span> <span class="bu">str</span>(src_raw)</span>
<span id="cb32-1523"><a href="#cb32-1523" aria-hidden="true" tabindex="-1"></a>            dst_str <span class="op">=</span> dst_raw.strip(<span class="st">'"'</span>) <span class="cf">if</span> <span class="bu">isinstance</span>(dst_raw, <span class="bu">str</span>) <span class="cf">else</span> <span class="bu">str</span>(dst_raw)</span>
<span id="cb32-1524"><a href="#cb32-1524" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1525"><a href="#cb32-1525" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Get original node objects using our mapping.</span></span>
<span id="cb32-1526"><a href="#cb32-1526" aria-hidden="true" tabindex="-1"></a>            src_node <span class="op">=</span> index_to_node.get(src_str)</span>
<span id="cb32-1527"><a href="#cb32-1527" aria-hidden="true" tabindex="-1"></a>            dst_node <span class="op">=</span> index_to_node.get(dst_str)</span>
<span id="cb32-1528"><a href="#cb32-1528" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> src_node <span class="kw">is</span> <span class="va">None</span> <span class="kw">or</span> dst_node <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb32-1529"><a href="#cb32-1529" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb32-1530"><a href="#cb32-1530" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1531"><a href="#cb32-1531" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Get display labels.</span></span>
<span id="cb32-1532"><a href="#cb32-1532" aria-hidden="true" tabindex="-1"></a>            src_label <span class="op">=</span> node_labels.get(src_str, src_str)</span>
<span id="cb32-1533"><a href="#cb32-1533" aria-hidden="true" tabindex="-1"></a>            dst_label <span class="op">=</span> node_labels.get(dst_str, dst_str)</span>
<span id="cb32-1534"><a href="#cb32-1534" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1535"><a href="#cb32-1535" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Use a tuple (src_str, dst_str) to ensure we don't add duplicates.</span></span>
<span id="cb32-1536"><a href="#cb32-1536" aria-hidden="true" tabindex="-1"></a>            edge_key <span class="op">=</span> (src_str, dst_str)</span>
<span id="cb32-1537"><a href="#cb32-1537" aria-hidden="true" tabindex="-1"></a>            reverse_key <span class="op">=</span> (dst_str, src_str)</span>
<span id="cb32-1538"><a href="#cb32-1538" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> edge_key <span class="kw">in</span> processed <span class="kw">or</span> reverse_key <span class="kw">in</span> processed:</span>
<span id="cb32-1539"><a href="#cb32-1539" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb32-1540"><a href="#cb32-1540" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1541"><a href="#cb32-1541" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb32-1542"><a href="#cb32-1542" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Get endpoint information from the original graph.</span></span>
<span id="cb32-1543"><a href="#cb32-1543" aria-hidden="true" tabindex="-1"></a>                e_uv <span class="op">=</span> graph.get_endpoint(src_node, dst_node)</span>
<span id="cb32-1544"><a href="#cb32-1544" aria-hidden="true" tabindex="-1"></a>                e_vu <span class="op">=</span> graph.get_endpoint(dst_node, src_node)</span>
<span id="cb32-1545"><a href="#cb32-1545" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span> <span class="pp">KeyError</span>:</span>
<span id="cb32-1546"><a href="#cb32-1546" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Skip if the original graph doesn't contain this edge.</span></span>
<span id="cb32-1547"><a href="#cb32-1547" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb32-1548"><a href="#cb32-1548" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1549"><a href="#cb32-1549" aria-hidden="true" tabindex="-1"></a>            <span class="co"># If both endpoints are TAIL, we treat the edge as undirected.</span></span>
<span id="cb32-1550"><a href="#cb32-1550" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> e_uv <span class="op">==</span> Endpoint.TAIL <span class="kw">and</span> e_vu <span class="op">==</span> Endpoint.TAIL:</span>
<span id="cb32-1551"><a href="#cb32-1551" aria-hidden="true" tabindex="-1"></a>                digraph.edge(src_label, dst_label, <span class="bu">dir</span><span class="op">=</span><span class="st">"none"</span>)</span>
<span id="cb32-1552"><a href="#cb32-1552" aria-hidden="true" tabindex="-1"></a>                processed.add(edge_key)</span>
<span id="cb32-1553"><a href="#cb32-1553" aria-hidden="true" tabindex="-1"></a>                processed.add(reverse_key)</span>
<span id="cb32-1554"><a href="#cb32-1554" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb32-1555"><a href="#cb32-1555" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Otherwise, preserve the original pydot direction.</span></span>
<span id="cb32-1556"><a href="#cb32-1556" aria-hidden="true" tabindex="-1"></a>                digraph.edge(src_label, dst_label)</span>
<span id="cb32-1557"><a href="#cb32-1557" aria-hidden="true" tabindex="-1"></a>                processed.add(edge_key)</span>
<span id="cb32-1558"><a href="#cb32-1558" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1559"><a href="#cb32-1559" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> digraph</span>
<span id="cb32-1560"><a href="#cb32-1560" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1561"><a href="#cb32-1561" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> to_networkx(<span class="va">self</span>, graph) <span class="op">-&gt;</span> nx.DiGraph:</span>
<span id="cb32-1562"><a href="#cb32-1562" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb32-1563"><a href="#cb32-1563" aria-hidden="true" tabindex="-1"></a><span class="co">        Convert a general graph (e.g. from causallearn) into a NetworkX DiGraph.</span></span>
<span id="cb32-1564"><a href="#cb32-1564" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1565"><a href="#cb32-1565" aria-hidden="true" tabindex="-1"></a><span class="co">        Nodes are added as provided by graph.get_nodes(), and for each ordered pair (u, v)</span></span>
<span id="cb32-1566"><a href="#cb32-1566" aria-hidden="true" tabindex="-1"></a><span class="co">        where an edge exists (as determined by graph.get_endpoint(u, v)), we add a directed</span></span>
<span id="cb32-1567"><a href="#cb32-1567" aria-hidden="true" tabindex="-1"></a><span class="co">        edge with an attribute 'endpoint' that stores the edge marker.</span></span>
<span id="cb32-1568"><a href="#cb32-1568" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1569"><a href="#cb32-1569" aria-hidden="true" tabindex="-1"></a><span class="co">        If the general graph does not provide a direct list of edges (e.g. via a get_edges() method),</span></span>
<span id="cb32-1570"><a href="#cb32-1570" aria-hidden="true" tabindex="-1"></a><span class="co">        we iterate over all pairs of nodes.</span></span>
<span id="cb32-1571"><a href="#cb32-1571" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb32-1572"><a href="#cb32-1572" aria-hidden="true" tabindex="-1"></a>        digraph <span class="op">=</span> nx.DiGraph()</span>
<span id="cb32-1573"><a href="#cb32-1573" aria-hidden="true" tabindex="-1"></a>        nodes <span class="op">=</span> graph.get_nodes()</span>
<span id="cb32-1574"><a href="#cb32-1574" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add nodes to the networkx graph.</span></span>
<span id="cb32-1575"><a href="#cb32-1575" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> node <span class="kw">in</span> nodes:</span>
<span id="cb32-1576"><a href="#cb32-1576" aria-hidden="true" tabindex="-1"></a>            digraph.add_node(node)</span>
<span id="cb32-1577"><a href="#cb32-1577" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1578"><a href="#cb32-1578" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If available, use a dedicated method to get edges.</span></span>
<span id="cb32-1579"><a href="#cb32-1579" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb32-1580"><a href="#cb32-1580" aria-hidden="true" tabindex="-1"></a>            edges <span class="op">=</span> graph.get_edges()</span>
<span id="cb32-1581"><a href="#cb32-1581" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">AttributeError</span>:</span>
<span id="cb32-1582"><a href="#cb32-1582" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Fallback: iterate over all ordered pairs (inefficient for large graphs)</span></span>
<span id="cb32-1583"><a href="#cb32-1583" aria-hidden="true" tabindex="-1"></a>            edges <span class="op">=</span> []</span>
<span id="cb32-1584"><a href="#cb32-1584" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> u <span class="kw">in</span> nodes:</span>
<span id="cb32-1585"><a href="#cb32-1585" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> v <span class="kw">in</span> nodes:</span>
<span id="cb32-1586"><a href="#cb32-1586" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> u <span class="op">==</span> v:</span>
<span id="cb32-1587"><a href="#cb32-1587" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">continue</span></span>
<span id="cb32-1588"><a href="#cb32-1588" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">try</span>:</span>
<span id="cb32-1589"><a href="#cb32-1589" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Attempt to get an endpoint; if present, we consider that an edge exists.</span></span>
<span id="cb32-1590"><a href="#cb32-1590" aria-hidden="true" tabindex="-1"></a>                        _ <span class="op">=</span> graph.get_endpoint(u, v)</span>
<span id="cb32-1591"><a href="#cb32-1591" aria-hidden="true" tabindex="-1"></a>                        edges.append((u, v))</span>
<span id="cb32-1592"><a href="#cb32-1592" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">except</span> <span class="pp">KeyError</span>:</span>
<span id="cb32-1593"><a href="#cb32-1593" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">continue</span></span>
<span id="cb32-1594"><a href="#cb32-1594" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1595"><a href="#cb32-1595" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add edges with endpoint attributes.</span></span>
<span id="cb32-1596"><a href="#cb32-1596" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> u, v <span class="kw">in</span> edges:</span>
<span id="cb32-1597"><a href="#cb32-1597" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb32-1598"><a href="#cb32-1598" aria-hidden="true" tabindex="-1"></a>                endpoint_uv <span class="op">=</span> graph.get_endpoint(u, v)</span>
<span id="cb32-1599"><a href="#cb32-1599" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span> <span class="pp">KeyError</span>:</span>
<span id="cb32-1600"><a href="#cb32-1600" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb32-1601"><a href="#cb32-1601" aria-hidden="true" tabindex="-1"></a>            digraph.add_edge(u, v, endpoint<span class="op">=</span>endpoint_uv)</span>
<span id="cb32-1602"><a href="#cb32-1602" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1603"><a href="#cb32-1603" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> digraph</span>
<span id="cb32-1604"><a href="#cb32-1604" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1605"><a href="#cb32-1605" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _networkx_to_graphviz(<span class="va">self</span>, nx_graph: nx.DiGraph) <span class="op">-&gt;</span> Digraph:</span>
<span id="cb32-1606"><a href="#cb32-1606" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb32-1607"><a href="#cb32-1607" aria-hidden="true" tabindex="-1"></a><span class="co">        Convert a NetworkX DiGraph into a Graphviz Digraph.</span></span>
<span id="cb32-1608"><a href="#cb32-1608" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1609"><a href="#cb32-1609" aria-hidden="true" tabindex="-1"></a><span class="co">        This method uses similar logic to 'to_graphviz', checking for reciprocal edges.</span></span>
<span id="cb32-1610"><a href="#cb32-1610" aria-hidden="true" tabindex="-1"></a><span class="co">        If an edge (u,v) and its reverse (v,u) exist and both have the attribute endpoint</span></span>
<span id="cb32-1611"><a href="#cb32-1611" aria-hidden="true" tabindex="-1"></a><span class="co">        equal to Endpoint.TAIL, the edge is rendered as undirected (dir="none").</span></span>
<span id="cb32-1612"><a href="#cb32-1612" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb32-1613"><a href="#cb32-1613" aria-hidden="true" tabindex="-1"></a>        digraph <span class="op">=</span> Digraph()</span>
<span id="cb32-1614"><a href="#cb32-1614" aria-hidden="true" tabindex="-1"></a>        digraph.attr(size<span class="op">=</span><span class="st">'8,8'</span>)</span>
<span id="cb32-1615"><a href="#cb32-1615" aria-hidden="true" tabindex="-1"></a>        processed <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb32-1616"><a href="#cb32-1616" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1617"><a href="#cb32-1617" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sort nodes to create a consistent mapping with self.labels.</span></span>
<span id="cb32-1618"><a href="#cb32-1618" aria-hidden="true" tabindex="-1"></a>        sorted_nodes <span class="op">=</span> <span class="bu">sorted</span>(nx_graph.nodes(), key<span class="op">=</span><span class="kw">lambda</span> x: <span class="bu">str</span>(x))</span>
<span id="cb32-1619"><a href="#cb32-1619" aria-hidden="true" tabindex="-1"></a>        node_labels <span class="op">=</span> {}</span>
<span id="cb32-1620"><a href="#cb32-1620" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, node <span class="kw">in</span> <span class="bu">enumerate</span>(sorted_nodes):</span>
<span id="cb32-1621"><a href="#cb32-1621" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Use self.labels if available, otherwise default to the node's string representation.</span></span>
<span id="cb32-1622"><a href="#cb32-1622" aria-hidden="true" tabindex="-1"></a>            label <span class="op">=</span> <span class="va">self</span>.labels[i] <span class="cf">if</span> i <span class="op">&lt;</span> <span class="bu">len</span>(<span class="va">self</span>.labels) <span class="cf">else</span> <span class="bu">str</span>(node)</span>
<span id="cb32-1623"><a href="#cb32-1623" aria-hidden="true" tabindex="-1"></a>            node_labels[node] <span class="op">=</span> label</span>
<span id="cb32-1624"><a href="#cb32-1624" aria-hidden="true" tabindex="-1"></a>            digraph.node(label)</span>
<span id="cb32-1625"><a href="#cb32-1625" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1626"><a href="#cb32-1626" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> u, v <span class="kw">in</span> nx_graph.edges():</span>
<span id="cb32-1627"><a href="#cb32-1627" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (u, v) <span class="kw">in</span> processed <span class="kw">or</span> (v, u) <span class="kw">in</span> processed:</span>
<span id="cb32-1628"><a href="#cb32-1628" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb32-1629"><a href="#cb32-1629" aria-hidden="true" tabindex="-1"></a>            src_label <span class="op">=</span> node_labels.get(u, <span class="bu">str</span>(u))</span>
<span id="cb32-1630"><a href="#cb32-1630" aria-hidden="true" tabindex="-1"></a>            dst_label <span class="op">=</span> node_labels.get(v, <span class="bu">str</span>(v))</span>
<span id="cb32-1631"><a href="#cb32-1631" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1632"><a href="#cb32-1632" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Check if the reverse edge exists to potentially mark as undirected.</span></span>
<span id="cb32-1633"><a href="#cb32-1633" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nx_graph.has_edge(v, u):</span>
<span id="cb32-1634"><a href="#cb32-1634" aria-hidden="true" tabindex="-1"></a>                endpoint_uv <span class="op">=</span> nx_graph.edges[u, v].get(<span class="st">'endpoint'</span>, <span class="va">None</span>)</span>
<span id="cb32-1635"><a href="#cb32-1635" aria-hidden="true" tabindex="-1"></a>                endpoint_vu <span class="op">=</span> nx_graph.edges[v, u].get(<span class="st">'endpoint'</span>, <span class="va">None</span>)</span>
<span id="cb32-1636"><a href="#cb32-1636" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> endpoint_uv <span class="op">==</span> Endpoint.TAIL <span class="kw">and</span> endpoint_vu <span class="op">==</span> Endpoint.TAIL:</span>
<span id="cb32-1637"><a href="#cb32-1637" aria-hidden="true" tabindex="-1"></a>                    digraph.edge(src_label, dst_label, <span class="bu">dir</span><span class="op">=</span><span class="st">"none"</span>)</span>
<span id="cb32-1638"><a href="#cb32-1638" aria-hidden="true" tabindex="-1"></a>                    processed.add((u, v))</span>
<span id="cb32-1639"><a href="#cb32-1639" aria-hidden="true" tabindex="-1"></a>                    processed.add((v, u))</span>
<span id="cb32-1640"><a href="#cb32-1640" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">continue</span></span>
<span id="cb32-1641"><a href="#cb32-1641" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Otherwise, add the edge as directed.</span></span>
<span id="cb32-1642"><a href="#cb32-1642" aria-hidden="true" tabindex="-1"></a>            digraph.edge(src_label, dst_label)</span>
<span id="cb32-1643"><a href="#cb32-1643" aria-hidden="true" tabindex="-1"></a>            processed.add((u, v))</span>
<span id="cb32-1644"><a href="#cb32-1644" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1645"><a href="#cb32-1645" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> digraph</span>
<span id="cb32-1646"><a href="#cb32-1646" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1647"><a href="#cb32-1647" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _graphviz_to_networkx(<span class="va">self</span>, gv_graph: Digraph) <span class="op">-&gt;</span> nx.DiGraph:</span>
<span id="cb32-1648"><a href="#cb32-1648" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb32-1649"><a href="#cb32-1649" aria-hidden="true" tabindex="-1"></a><span class="co">        Convert a Graphviz Digraph into a NetworkX DiGraph.</span></span>
<span id="cb32-1650"><a href="#cb32-1650" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1651"><a href="#cb32-1651" aria-hidden="true" tabindex="-1"></a><span class="co">        This method extracts the DOT source from the provided Graphviz Digraph,</span></span>
<span id="cb32-1652"><a href="#cb32-1652" aria-hidden="true" tabindex="-1"></a><span class="co">        parses it using pydot, and then converts the resulting pydot graph into</span></span>
<span id="cb32-1653"><a href="#cb32-1653" aria-hidden="true" tabindex="-1"></a><span class="co">        a NetworkX directed graph. This ensures that node labels and edge orientations</span></span>
<span id="cb32-1654"><a href="#cb32-1654" aria-hidden="true" tabindex="-1"></a><span class="co">        are maintained consistently.</span></span>
<span id="cb32-1655"><a href="#cb32-1655" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1656"><a href="#cb32-1656" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb32-1657"><a href="#cb32-1657" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb32-1658"><a href="#cb32-1658" aria-hidden="true" tabindex="-1"></a><span class="co">        gv_graph : graphviz.Digraph</span></span>
<span id="cb32-1659"><a href="#cb32-1659" aria-hidden="true" tabindex="-1"></a><span class="co">            The Graphviz Digraph to be converted.</span></span>
<span id="cb32-1660"><a href="#cb32-1660" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1661"><a href="#cb32-1661" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb32-1662"><a href="#cb32-1662" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb32-1663"><a href="#cb32-1663" aria-hidden="true" tabindex="-1"></a><span class="co">        nx.DiGraph</span></span>
<span id="cb32-1664"><a href="#cb32-1664" aria-hidden="true" tabindex="-1"></a><span class="co">            A NetworkX DiGraph representation of the input Graphviz graph.</span></span>
<span id="cb32-1665"><a href="#cb32-1665" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb32-1666"><a href="#cb32-1666" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Retrieve the DOT source code from the Graphviz Digraph.</span></span>
<span id="cb32-1667"><a href="#cb32-1667" aria-hidden="true" tabindex="-1"></a>        dot_str <span class="op">=</span> gv_graph.source</span>
<span id="cb32-1668"><a href="#cb32-1668" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1669"><a href="#cb32-1669" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Parse the DOT data using pydot.</span></span>
<span id="cb32-1670"><a href="#cb32-1670" aria-hidden="true" tabindex="-1"></a>        pydot_graphs <span class="op">=</span> pydot.graph_from_dot_data(dot_str)</span>
<span id="cb32-1671"><a href="#cb32-1671" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> pydot_graphs:</span>
<span id="cb32-1672"><a href="#cb32-1672" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"No valid pydot graphs could be parsed from the DOT data."</span>)</span>
<span id="cb32-1673"><a href="#cb32-1673" aria-hidden="true" tabindex="-1"></a>        <span class="co"># pydot.graph_from_dot_data returns a list; we take the first one.</span></span>
<span id="cb32-1674"><a href="#cb32-1674" aria-hidden="true" tabindex="-1"></a>        pydot_graph <span class="op">=</span> pydot_graphs[<span class="dv">0</span>]</span>
<span id="cb32-1675"><a href="#cb32-1675" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1676"><a href="#cb32-1676" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Use NetworkX’s built-in conversion from a pydot graph to a DiGraph.</span></span>
<span id="cb32-1677"><a href="#cb32-1677" aria-hidden="true" tabindex="-1"></a>        nx_graph <span class="op">=</span> nx.nx_pydot.from_pydot(pydot_graph)</span>
<span id="cb32-1678"><a href="#cb32-1678" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> nx_graph</span>
<span id="cb32-1679"><a href="#cb32-1679" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1680"><a href="#cb32-1680" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1681"><a href="#cb32-1681" aria-hidden="true" tabindex="-1"></a>Causal Learn allows use to use different algorithms to infer the markov equivalent class of the causal graph. The previous class is a wrapper that allows us to use the different algorithms implemented in the causal learn library, and plot them more easily.</span>
<span id="cb32-1682"><a href="#cb32-1682" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1683"><a href="#cb32-1683" aria-hidden="true" tabindex="-1"></a>Currently we wrap the following algorithms:</span>
<span id="cb32-1684"><a href="#cb32-1684" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1685"><a href="#cb32-1685" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Greedy Search (GES)</span>
<span id="cb32-1686"><a href="#cb32-1686" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Peter-Clark (PC)</span>
<span id="cb32-1687"><a href="#cb32-1687" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1688"><a href="#cb32-1688" aria-hidden="true" tabindex="-1"></a>::: {.callout-info}</span>
<span id="cb32-1689"><a href="#cb32-1689" aria-hidden="true" tabindex="-1"></a><span class="fu">## Causal Discovery Algorithms</span></span>
<span id="cb32-1690"><a href="#cb32-1690" aria-hidden="true" tabindex="-1"></a>The **Peter-Clark algorithm** is a constraint-based method that infers causal structures from observational data using conditional independence tests. It starts with a fully connected undirected graph where every variable is initially connected to every other variable. The algorithm systematically tests conditional independence between pairs of variables, conditioning on increasingly larger subsets of other variables. When a conditional independence is detected, the corresponding edge is removed from the graph.</span>
<span id="cb32-1691"><a href="#cb32-1691" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1692"><a href="#cb32-1692" aria-hidden="true" tabindex="-1"></a>On the other hand, **Greedy Search** is a score-based method that iteratively improves a candidate causal model by locally modifying its structure. It begins with an initial directed acyclic graph and evaluates a scoring metric that balances goodness-of-fit with model complexity. The algorithm explores modifications such as adding, deleting, or reversing edges to find local improvements in the score. At each iteration, it selects the change that produces the highest increase in the score, following a step-by-step improvement strategy. The search continues until no single modification can further enhance the model's score. This method efficiently navigates the combinatorial search space of possible graphs by making locally optimal choices.</span>
<span id="cb32-1693"><a href="#cb32-1693" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb32-1694"><a href="#cb32-1694" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1695"><a href="#cb32-1695" aria-hidden="true" tabindex="-1"></a>::: {.callout-warning}</span>
<span id="cb32-1696"><a href="#cb32-1696" aria-hidden="true" tabindex="-1"></a><span class="fu">## Causal Sufficiency Assumption</span></span>
<span id="cb32-1697"><a href="#cb32-1697" aria-hidden="true" tabindex="-1"></a>Any causal discovery algorithm is based on the assumption that all the relevant variables are observed. If some relevant variable is not observed, the algorithm will not be able to infer the correct causal graph. Each variable, even the unobserved ones, should be represented in the dataset, so the algorithm can include them in the causal graph and validation tests.</span>
<span id="cb32-1698"><a href="#cb32-1698" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb32-1699"><a href="#cb32-1699" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1700"><a href="#cb32-1700" aria-hidden="true" tabindex="-1"></a>The following example shows the causal graph inferred using the Greedy Search algorithm.</span>
<span id="cb32-1701"><a href="#cb32-1701" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1704"><a href="#cb32-1704" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-1705"><a href="#cb32-1705" aria-hidden="true" tabindex="-1"></a>causal_model <span class="op">=</span> CausalDiscovery(scaled_df[[<span class="st">"holiday_signal"</span>, <span class="st">"inflation"</span>, <span class="st">"x1"</span>, <span class="st">"x2"</span>, <span class="st">"x3"</span>, <span class="st">"y"</span>]])</span>
<span id="cb32-1706"><a href="#cb32-1706" aria-hidden="true" tabindex="-1"></a>ges_graph <span class="op">=</span> causal_model.greedy_search()</span>
<span id="cb32-1707"><a href="#cb32-1707" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1708"><a href="#cb32-1708" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a figure with five subplots</span></span>
<span id="cb32-1709"><a href="#cb32-1709" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">4</span>,)</span>
<span id="cb32-1710"><a href="#cb32-1710" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1711"><a href="#cb32-1711" aria-hidden="true" tabindex="-1"></a><span class="co"># Set titles for each subplot</span></span>
<span id="cb32-1712"><a href="#cb32-1712" aria-hidden="true" tabindex="-1"></a>titles <span class="op">=</span> [<span class="st">"Naive DAG"</span>, <span class="st">"Updated DAG"</span>, <span class="st">"Updated DAG 1"</span>, <span class="st">"Discovered DAG"</span>]</span>
<span id="cb32-1713"><a href="#cb32-1713" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, title <span class="kw">in</span> <span class="bu">zip</span>(axes, titles):</span>
<span id="cb32-1714"><a href="#cb32-1714" aria-hidden="true" tabindex="-1"></a>    ax.set_title(title, fontsize<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb32-1715"><a href="#cb32-1715" aria-hidden="true" tabindex="-1"></a>    ax.axis(<span class="st">'off'</span>)</span>
<span id="cb32-1716"><a href="#cb32-1716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1717"><a href="#cb32-1717" aria-hidden="true" tabindex="-1"></a><span class="co"># Render and plot each graph</span></span>
<span id="cb32-1718"><a href="#cb32-1718" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/naive_dag'</span>)</span>
<span id="cb32-1719"><a href="#cb32-1719" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].imshow(mpimg.imread(<span class="st">'images/naive_dag.png'</span>))</span>
<span id="cb32-1720"><a href="#cb32-1720" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1721"><a href="#cb32-1721" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/updated_dag'</span>)</span>
<span id="cb32-1722"><a href="#cb32-1722" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].imshow(mpimg.imread(<span class="st">'images/updated_dag.png'</span>))</span>
<span id="cb32-1723"><a href="#cb32-1723" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1724"><a href="#cb32-1724" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/updated_dag1'</span>)</span>
<span id="cb32-1725"><a href="#cb32-1725" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].imshow(mpimg.imread(<span class="st">'images/updated_dag1.png'</span>))</span>
<span id="cb32-1726"><a href="#cb32-1726" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1727"><a href="#cb32-1727" aria-hidden="true" tabindex="-1"></a>real_dag_graph <span class="op">=</span> causal_model.to_graphviz(ges_graph)</span>
<span id="cb32-1728"><a href="#cb32-1728" aria-hidden="true" tabindex="-1"></a>real_dag_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/discovered_dag'</span>)</span>
<span id="cb32-1729"><a href="#cb32-1729" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>].imshow(mpimg.imread(<span class="st">'images/discovered_dag.png'</span>))</span>
<span id="cb32-1730"><a href="#cb32-1730" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1731"><a href="#cb32-1731" aria-hidden="true" tabindex="-1"></a><span class="co"># Add main title</span></span>
<span id="cb32-1732"><a href="#cb32-1732" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">"Comparison of DAG Graphs"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb32-1733"><a href="#cb32-1733" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb32-1734"><a href="#cb32-1734" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1735"><a href="#cb32-1735" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1736"><a href="#cb32-1736" aria-hidden="true" tabindex="-1"></a>The causal graph capture by greedy search is very similar to the true causal graph. Some arrows are directed to variables that are not related, but this is expected given the nature of the data, we still have noise in the data, and sporious correlations that can't be fully falsify by the independence tests. Additionally, the finded graph can lie in the markov equivalence class of the true causal graph, meaning that there are multiple DAGs that are compatible with the data.</span>
<span id="cb32-1737"><a href="#cb32-1737" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1738"><a href="#cb32-1738" aria-hidden="true" tabindex="-1"></a>This instead of being a problem, is a great news because we can now start to work with experimentation to test the current structure, and improve it iteratively, without the need to wait for these answers to get the right estimates in a regression model.</span>
<span id="cb32-1739"><a href="#cb32-1739" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1740"><a href="#cb32-1740" aria-hidden="true" tabindex="-1"></a>Let's break down the causal paths from x2 to y in the graph:</span>
<span id="cb32-1741"><a href="#cb32-1741" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1742"><a href="#cb32-1742" aria-hidden="true" tabindex="-1"></a>**Confounding paths:**</span>
<span id="cb32-1743"><a href="#cb32-1743" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1744"><a href="#cb32-1744" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Holiday: Affects both x2 and y (holiday → x2 and holiday → y).</span>
<span id="cb32-1745"><a href="#cb32-1745" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Inflation: Affects both x2 and y (inflation → x2 and inflation → y).</span>
<span id="cb32-1746"><a href="#cb32-1746" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>x1: Influences x2 (x1 → x2) and also affects y indirectly through x3 (x1 → x3 → y).</span>
<span id="cb32-1747"><a href="#cb32-1747" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1748"><a href="#cb32-1748" aria-hidden="true" tabindex="-1"></a>**Mediating path:**</span>
<span id="cb32-1749"><a href="#cb32-1749" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1750"><a href="#cb32-1750" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>x3: Lies on the causal pathway from x2 to y (x2 → x3 → y).</span>
<span id="cb32-1751"><a href="#cb32-1751" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1752"><a href="#cb32-1752" aria-hidden="true" tabindex="-1"></a>**What needs to be controlled?**</span>
<span id="cb32-1753"><a href="#cb32-1753" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1754"><a href="#cb32-1754" aria-hidden="true" tabindex="-1"></a>To estimate the total effect of x2 on y without bias, you need to block all backdoor (confounding) paths. This means controlling for the common causes:</span>
<span id="cb32-1755"><a href="#cb32-1755" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1756"><a href="#cb32-1756" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Holiday</span>
<span id="cb32-1757"><a href="#cb32-1757" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Inflation</span>
<span id="cb32-1758"><a href="#cb32-1758" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>x1</span>
<span id="cb32-1759"><a href="#cb32-1759" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1760"><a href="#cb32-1760" aria-hidden="true" tabindex="-1"></a>**Why not control for x3?**</span>
<span id="cb32-1761"><a href="#cb32-1761" aria-hidden="true" tabindex="-1"></a>Since x3 is a mediator (i.e., it transmits part of the effect of x2 to y), including it in your regression would block the indirect effect of x2 on y. This “over-control” would result in an estimate that reflects only the direct effect of x2 on y, not the total effect. Additionally, controlling for mediators can sometimes introduce bias if there are other complex relationships in the graph.</span>
<span id="cb32-1762"><a href="#cb32-1762" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1765"><a href="#cb32-1765" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-1766"><a href="#cb32-1766" aria-hidden="true" tabindex="-1"></a>mmm <span class="op">=</span> MMM(</span>
<span id="cb32-1767"><a href="#cb32-1767" aria-hidden="true" tabindex="-1"></a>    model_config<span class="op">=</span>model_config,</span>
<span id="cb32-1768"><a href="#cb32-1768" aria-hidden="true" tabindex="-1"></a>    date_column<span class="op">=</span><span class="st">"date"</span>,</span>
<span id="cb32-1769"><a href="#cb32-1769" aria-hidden="true" tabindex="-1"></a>    channel_columns<span class="op">=</span>[</span>
<span id="cb32-1770"><a href="#cb32-1770" aria-hidden="true" tabindex="-1"></a>        <span class="st">"x1"</span>,</span>
<span id="cb32-1771"><a href="#cb32-1771" aria-hidden="true" tabindex="-1"></a>        <span class="co"># "x2",</span></span>
<span id="cb32-1772"><a href="#cb32-1772" aria-hidden="true" tabindex="-1"></a>        <span class="st">"x3"</span></span>
<span id="cb32-1773"><a href="#cb32-1773" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb32-1774"><a href="#cb32-1774" aria-hidden="true" tabindex="-1"></a>    control_columns<span class="op">=</span>[</span>
<span id="cb32-1775"><a href="#cb32-1775" aria-hidden="true" tabindex="-1"></a>        <span class="st">"holiday_signal"</span>,</span>
<span id="cb32-1776"><a href="#cb32-1776" aria-hidden="true" tabindex="-1"></a>        <span class="st">"inflation"</span>,</span>
<span id="cb32-1777"><a href="#cb32-1777" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb32-1778"><a href="#cb32-1778" aria-hidden="true" tabindex="-1"></a>    adstock<span class="op">=</span>GeometricAdstock(l_max<span class="op">=</span><span class="dv">24</span>),</span>
<span id="cb32-1779"><a href="#cb32-1779" aria-hidden="true" tabindex="-1"></a>    saturation<span class="op">=</span>MichaelisMentenSaturation(),</span>
<span id="cb32-1780"><a href="#cb32-1780" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-1781"><a href="#cb32-1781" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1782"><a href="#cb32-1782" aria-hidden="true" tabindex="-1"></a>mmm.fit(X, y, <span class="op">**</span>fit_kwargs)</span>
<span id="cb32-1783"><a href="#cb32-1783" aria-hidden="true" tabindex="-1"></a>mmm.sample_posterior_predictive(</span>
<span id="cb32-1784"><a href="#cb32-1784" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>X,</span>
<span id="cb32-1785"><a href="#cb32-1785" aria-hidden="true" tabindex="-1"></a>    extend_idata<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb32-1786"><a href="#cb32-1786" aria-hidden="true" tabindex="-1"></a>    combined<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb32-1787"><a href="#cb32-1787" aria-hidden="true" tabindex="-1"></a>    random_seed<span class="op">=</span>rng,</span>
<span id="cb32-1788"><a href="#cb32-1788" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-1789"><a href="#cb32-1789" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1790"><a href="#cb32-1790" aria-hidden="true" tabindex="-1"></a>initial_model_recover_effect <span class="op">=</span> (</span>
<span id="cb32-1791"><a href="#cb32-1791" aria-hidden="true" tabindex="-1"></a>    az.hdi(mmm.fit_result[<span class="st">"channel_contributions"</span>], hdi_prob<span class="op">=</span><span class="fl">0.95</span>)</span>
<span id="cb32-1792"><a href="#cb32-1792" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> mmm.target_transformer[<span class="st">"scaler"</span>].scale_.item()</span>
<span id="cb32-1793"><a href="#cb32-1793" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-1794"><a href="#cb32-1794" aria-hidden="true" tabindex="-1"></a>initial_model_mean_effect <span class="op">=</span> (</span>
<span id="cb32-1795"><a href="#cb32-1795" aria-hidden="true" tabindex="-1"></a>    mmm.fit_result.channel_contributions.mean(dim<span class="op">=</span>[<span class="st">"chain"</span>, <span class="st">"draw"</span>])</span>
<span id="cb32-1796"><a href="#cb32-1796" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> mmm.target_transformer[<span class="st">"scaler"</span>].scale_.item()</span>
<span id="cb32-1797"><a href="#cb32-1797" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-1798"><a href="#cb32-1798" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1799"><a href="#cb32-1799" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1800"><a href="#cb32-1800" aria-hidden="true" tabindex="-1"></a>Now let's plot the posterior distribution of the effect of x3 on y.</span>
<span id="cb32-1801"><a href="#cb32-1801" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1804"><a href="#cb32-1804" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-1805"><a href="#cb32-1805" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_posterior(y_real, posterior, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>), path_color<span class="op">=</span><span class="st">'orange'</span>, hist_color<span class="op">=</span><span class="st">'orange'</span>, <span class="op">**</span>kwargs):</span>
<span id="cb32-1806"><a href="#cb32-1806" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb32-1807"><a href="#cb32-1807" aria-hidden="true" tabindex="-1"></a><span class="co">    Plot the posterior distribution of a stochastic process.</span></span>
<span id="cb32-1808"><a href="#cb32-1808" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb32-1809"><a href="#cb32-1809" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb32-1810"><a href="#cb32-1810" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb32-1811"><a href="#cb32-1811" aria-hidden="true" tabindex="-1"></a><span class="co">    y_real : array-like</span></span>
<span id="cb32-1812"><a href="#cb32-1812" aria-hidden="true" tabindex="-1"></a><span class="co">        The real values to compare against the posterior.</span></span>
<span id="cb32-1813"><a href="#cb32-1813" aria-hidden="true" tabindex="-1"></a><span class="co">    posterior : xarray.DataArray</span></span>
<span id="cb32-1814"><a href="#cb32-1814" aria-hidden="true" tabindex="-1"></a><span class="co">        The posterior distribution with shape (draw, chain, date).</span></span>
<span id="cb32-1815"><a href="#cb32-1815" aria-hidden="true" tabindex="-1"></a><span class="co">    figsize : tuple, optional</span></span>
<span id="cb32-1816"><a href="#cb32-1816" aria-hidden="true" tabindex="-1"></a><span class="co">        Size of the figure. Default is (8, 4).</span></span>
<span id="cb32-1817"><a href="#cb32-1817" aria-hidden="true" tabindex="-1"></a><span class="co">    path_color : str, optional</span></span>
<span id="cb32-1818"><a href="#cb32-1818" aria-hidden="true" tabindex="-1"></a><span class="co">        Color of the paths in the time series plot. Default is 'orange'.</span></span>
<span id="cb32-1819"><a href="#cb32-1819" aria-hidden="true" tabindex="-1"></a><span class="co">    hist_color : str, optional</span></span>
<span id="cb32-1820"><a href="#cb32-1820" aria-hidden="true" tabindex="-1"></a><span class="co">        Color of the histogram. Default is 'orange'.</span></span>
<span id="cb32-1821"><a href="#cb32-1821" aria-hidden="true" tabindex="-1"></a><span class="co">    **kwargs : dict</span></span>
<span id="cb32-1822"><a href="#cb32-1822" aria-hidden="true" tabindex="-1"></a><span class="co">        Additional keyword arguments to pass to the plotting functions.</span></span>
<span id="cb32-1823"><a href="#cb32-1823" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb32-1824"><a href="#cb32-1824" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb32-1825"><a href="#cb32-1825" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb32-1826"><a href="#cb32-1826" aria-hidden="true" tabindex="-1"></a><span class="co">    fig : matplotlib.figure.Figure</span></span>
<span id="cb32-1827"><a href="#cb32-1827" aria-hidden="true" tabindex="-1"></a><span class="co">        The figure object containing the plots.</span></span>
<span id="cb32-1828"><a href="#cb32-1828" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb32-1829"><a href="#cb32-1829" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1830"><a href="#cb32-1830" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the expected value (mean) across all draws and chains for each date</span></span>
<span id="cb32-1831"><a href="#cb32-1831" aria-hidden="true" tabindex="-1"></a>    expected_value <span class="op">=</span> posterior.mean(dim<span class="op">=</span>(<span class="st">"draw"</span>, <span class="st">"chain"</span>))</span>
<span id="cb32-1832"><a href="#cb32-1832" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1833"><a href="#cb32-1833" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a figure and a grid of subplots</span></span>
<span id="cb32-1834"><a href="#cb32-1834" aria-hidden="true" tabindex="-1"></a>    fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>figsize)</span>
<span id="cb32-1835"><a href="#cb32-1835" aria-hidden="true" tabindex="-1"></a>    gs <span class="op">=</span> fig.add_gridspec(<span class="dv">1</span>, <span class="dv">2</span>, width_ratios<span class="op">=</span>[<span class="dv">3</span>, <span class="dv">1</span>])</span>
<span id="cb32-1836"><a href="#cb32-1836" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1837"><a href="#cb32-1837" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Time series plot</span></span>
<span id="cb32-1838"><a href="#cb32-1838" aria-hidden="true" tabindex="-1"></a>    ax1 <span class="op">=</span> fig.add_subplot(gs[<span class="dv">0</span>])</span>
<span id="cb32-1839"><a href="#cb32-1839" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> chain <span class="kw">in</span> <span class="bu">range</span>(posterior.shape[<span class="dv">1</span>]):</span>
<span id="cb32-1840"><a href="#cb32-1840" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> draw <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, posterior.shape[<span class="dv">0</span>], <span class="dv">10</span>):  <span class="co"># Plot every 10th draw for performance</span></span>
<span id="cb32-1841"><a href="#cb32-1841" aria-hidden="true" tabindex="-1"></a>            ax1.plot(posterior.date, posterior[draw, chain], color<span class="op">=</span>path_color, alpha<span class="op">=</span><span class="fl">0.1</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb32-1842"><a href="#cb32-1842" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1843"><a href="#cb32-1843" aria-hidden="true" tabindex="-1"></a>    ax1.plot(posterior.date, expected_value, color<span class="op">=</span><span class="st">'grey'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb32-1844"><a href="#cb32-1844" aria-hidden="true" tabindex="-1"></a>    ax1.plot(posterior.date, y_real, color<span class="op">=</span><span class="st">'black'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Real'</span>,)</span>
<span id="cb32-1845"><a href="#cb32-1845" aria-hidden="true" tabindex="-1"></a>    ax1.set_title(<span class="st">"Posterior Predictive"</span>)</span>
<span id="cb32-1846"><a href="#cb32-1846" aria-hidden="true" tabindex="-1"></a>    ax1.set_xlabel(<span class="st">'Date'</span>)</span>
<span id="cb32-1847"><a href="#cb32-1847" aria-hidden="true" tabindex="-1"></a>    ax1.set_ylabel(<span class="st">'Value'</span>)</span>
<span id="cb32-1848"><a href="#cb32-1848" aria-hidden="true" tabindex="-1"></a>    ax1.grid(<span class="va">True</span>)</span>
<span id="cb32-1849"><a href="#cb32-1849" aria-hidden="true" tabindex="-1"></a>    ax1.legend()</span>
<span id="cb32-1850"><a href="#cb32-1850" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1851"><a href="#cb32-1851" aria-hidden="true" tabindex="-1"></a>    <span class="co"># KDE plot</span></span>
<span id="cb32-1852"><a href="#cb32-1852" aria-hidden="true" tabindex="-1"></a>    ax2 <span class="op">=</span> fig.add_subplot(gs[<span class="dv">1</span>])</span>
<span id="cb32-1853"><a href="#cb32-1853" aria-hidden="true" tabindex="-1"></a>    final_values <span class="op">=</span> posterior[:, :, <span class="op">-</span><span class="dv">1</span>].values.flatten()</span>
<span id="cb32-1854"><a href="#cb32-1854" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1855"><a href="#cb32-1855" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Use seaborn for KDE plot</span></span>
<span id="cb32-1856"><a href="#cb32-1856" aria-hidden="true" tabindex="-1"></a>    sns.kdeplot(y<span class="op">=</span>final_values, ax<span class="op">=</span>ax2, fill<span class="op">=</span><span class="va">True</span>, color<span class="op">=</span>hist_color, alpha<span class="op">=</span><span class="fl">0.6</span>, <span class="op">**</span>kwargs)</span>
<span id="cb32-1857"><a href="#cb32-1857" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1858"><a href="#cb32-1858" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add histogram on top of KDE</span></span>
<span id="cb32-1859"><a href="#cb32-1859" aria-hidden="true" tabindex="-1"></a>    ax2.hist(final_values, orientation<span class="op">=</span><span class="st">'horizontal'</span>, color<span class="op">=</span>hist_color, bins<span class="op">=</span><span class="dv">30</span>,</span>
<span id="cb32-1860"><a href="#cb32-1860" aria-hidden="true" tabindex="-1"></a>             alpha<span class="op">=</span><span class="fl">0.3</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-1861"><a href="#cb32-1861" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1862"><a href="#cb32-1862" aria-hidden="true" tabindex="-1"></a>    ax2.axhline(y<span class="op">=</span>expected_value[<span class="op">-</span><span class="dv">1</span>], color<span class="op">=</span><span class="st">'grey'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb32-1863"><a href="#cb32-1863" aria-hidden="true" tabindex="-1"></a>    ax2.set_title(<span class="st">'Distribution at T'</span>)</span>
<span id="cb32-1864"><a href="#cb32-1864" aria-hidden="true" tabindex="-1"></a>    ax2.set_xlabel(<span class="st">'Density'</span>)</span>
<span id="cb32-1865"><a href="#cb32-1865" aria-hidden="true" tabindex="-1"></a>    ax2.set_yticklabels([])  <span class="co"># Hide y tick labels to avoid duplication</span></span>
<span id="cb32-1866"><a href="#cb32-1866" aria-hidden="true" tabindex="-1"></a>    ax2.grid(<span class="va">True</span>)</span>
<span id="cb32-1867"><a href="#cb32-1867" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fig</span>
<span id="cb32-1868"><a href="#cb32-1868" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1869"><a href="#cb32-1869" aria-hidden="true" tabindex="-1"></a>plot_posterior(</span>
<span id="cb32-1870"><a href="#cb32-1870" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"x3_adstock_saturated"</span>].values,</span>
<span id="cb32-1871"><a href="#cb32-1871" aria-hidden="true" tabindex="-1"></a>    mmm.idata.posterior.channel_contributions.sel(channel<span class="op">=</span><span class="st">"x3"</span>) <span class="op">*</span> df[<span class="st">"y"</span>].<span class="bu">max</span>(),</span>
<span id="cb32-1872"><a href="#cb32-1872" aria-hidden="true" tabindex="-1"></a>    path_color<span class="op">=</span><span class="st">'lightblue'</span>,</span>
<span id="cb32-1873"><a href="#cb32-1873" aria-hidden="true" tabindex="-1"></a>    hist_color<span class="op">=</span><span class="st">'lightblue'</span></span>
<span id="cb32-1874"><a href="#cb32-1874" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span>
<span id="cb32-1875"><a href="#cb32-1875" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1876"><a href="#cb32-1876" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1877"><a href="#cb32-1877" aria-hidden="true" tabindex="-1"></a>The effect was recovered perfectly, using this model, we can safely inform how much we'll get back if we invest in x3. Nevertheless, we need to control by holiday and inflation to get the total effect. What happen if we don't have this control variables?</span>
<span id="cb32-1878"><a href="#cb32-1878" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1879"><a href="#cb32-1879" aria-hidden="true" tabindex="-1"></a><span class="fu"># How to get right estimates if we don't have all the covariates?</span></span>
<span id="cb32-1880"><a href="#cb32-1880" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1881"><a href="#cb32-1881" aria-hidden="true" tabindex="-1"></a>If we are confident in our data generative process we can be sure that by surgically excluding a node, a Gaussian process can absorb such variability. Let's see how this works in practice.</span>
<span id="cb32-1882"><a href="#cb32-1882" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1885"><a href="#cb32-1885" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-1886"><a href="#cb32-1886" aria-hidden="true" tabindex="-1"></a>mmm <span class="op">=</span> MMM(</span>
<span id="cb32-1887"><a href="#cb32-1887" aria-hidden="true" tabindex="-1"></a>    model_config<span class="op">=</span>model_config,</span>
<span id="cb32-1888"><a href="#cb32-1888" aria-hidden="true" tabindex="-1"></a>    date_column<span class="op">=</span><span class="st">"date"</span>,</span>
<span id="cb32-1889"><a href="#cb32-1889" aria-hidden="true" tabindex="-1"></a>    channel_columns<span class="op">=</span>[</span>
<span id="cb32-1890"><a href="#cb32-1890" aria-hidden="true" tabindex="-1"></a>        <span class="st">"x1"</span>,</span>
<span id="cb32-1891"><a href="#cb32-1891" aria-hidden="true" tabindex="-1"></a>        <span class="st">"x2"</span>,</span>
<span id="cb32-1892"><a href="#cb32-1892" aria-hidden="true" tabindex="-1"></a>        <span class="co"># "x3"</span></span>
<span id="cb32-1893"><a href="#cb32-1893" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb32-1894"><a href="#cb32-1894" aria-hidden="true" tabindex="-1"></a>    adstock<span class="op">=</span>GeometricAdstock(l_max<span class="op">=</span><span class="dv">24</span>),</span>
<span id="cb32-1895"><a href="#cb32-1895" aria-hidden="true" tabindex="-1"></a>    saturation<span class="op">=</span>MichaelisMentenSaturation(),</span>
<span id="cb32-1896"><a href="#cb32-1896" aria-hidden="true" tabindex="-1"></a>    time_varying_intercept<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb32-1897"><a href="#cb32-1897" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-1898"><a href="#cb32-1898" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1899"><a href="#cb32-1899" aria-hidden="true" tabindex="-1"></a>mmm.model_config[<span class="st">"intercept_tvp_config"</span>].ls_mu <span class="op">=</span> <span class="dv">15</span></span>
<span id="cb32-1900"><a href="#cb32-1900" aria-hidden="true" tabindex="-1"></a>mmm.model_config[<span class="st">"intercept_tvp_config"</span>].m <span class="op">=</span> <span class="dv">200</span></span>
<span id="cb32-1901"><a href="#cb32-1901" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1902"><a href="#cb32-1902" aria-hidden="true" tabindex="-1"></a>mmm.fit(X, y, <span class="op">**</span>fit_kwargs)</span>
<span id="cb32-1903"><a href="#cb32-1903" aria-hidden="true" tabindex="-1"></a>mmm.sample_posterior_predictive(</span>
<span id="cb32-1904"><a href="#cb32-1904" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>X,</span>
<span id="cb32-1905"><a href="#cb32-1905" aria-hidden="true" tabindex="-1"></a>    extend_idata<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb32-1906"><a href="#cb32-1906" aria-hidden="true" tabindex="-1"></a>    combined<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb32-1907"><a href="#cb32-1907" aria-hidden="true" tabindex="-1"></a>    random_seed<span class="op">=</span>rng,</span>
<span id="cb32-1908"><a href="#cb32-1908" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-1909"><a href="#cb32-1909" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1910"><a href="#cb32-1910" aria-hidden="true" tabindex="-1"></a>az.summary(mmm.idata, var_names<span class="op">=</span>[<span class="st">"saturation_alpha"</span>, <span class="st">"saturation_lam"</span>, <span class="st">"adstock_alpha"</span>,])</span>
<span id="cb32-1911"><a href="#cb32-1911" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1912"><a href="#cb32-1912" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1913"><a href="#cb32-1913" aria-hidden="true" tabindex="-1"></a>We can see by the parameters of the model is able to recover the effect of x2 on y, even though we removed x3 from the model.</span>
<span id="cb32-1914"><a href="#cb32-1914" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1917"><a href="#cb32-1917" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-1918"><a href="#cb32-1918" aria-hidden="true" tabindex="-1"></a>plot_posterior(</span>
<span id="cb32-1919"><a href="#cb32-1919" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"x2_adstock_saturated"</span>].values,</span>
<span id="cb32-1920"><a href="#cb32-1920" aria-hidden="true" tabindex="-1"></a>    mmm.idata.posterior.channel_contributions.sel(channel<span class="op">=</span><span class="st">"x2"</span>) <span class="op">*</span> df[<span class="st">"y"</span>].<span class="bu">max</span>(),</span>
<span id="cb32-1921"><a href="#cb32-1921" aria-hidden="true" tabindex="-1"></a>    path_color<span class="op">=</span><span class="st">'lightgreen'</span>,</span>
<span id="cb32-1922"><a href="#cb32-1922" aria-hidden="true" tabindex="-1"></a>    hist_color<span class="op">=</span><span class="st">'lightgreen'</span></span>
<span id="cb32-1923"><a href="#cb32-1923" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span>
<span id="cb32-1924"><a href="#cb32-1924" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1925"><a href="#cb32-1925" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1926"><a href="#cb32-1926" aria-hidden="true" tabindex="-1"></a>As expected, the effect of x2 on y is recovered, even though we removed control variables from the model, and use a gaussian process to account for the variability of the data instead.</span>
<span id="cb32-1927"><a href="#cb32-1927" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1928"><a href="#cb32-1928" aria-hidden="true" tabindex="-1"></a><span class="fu"># Conclusions</span></span>
<span id="cb32-1929"><a href="#cb32-1929" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1930"><a href="#cb32-1930" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Don't seek the one single model: The real world is very dynamic, before its possible that the one single model it doesn't exist.</span>
<span id="cb32-1931"><a href="#cb32-1931" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1932"><a href="#cb32-1932" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>"Find" the Causal Truth: Dive into the world of causal structures and learn how to map out the hidden pathways that influence your outcomes. Not consider causal structures will drive you to consider more simple causal structures, which can be problematic in a real world enviroment.</span>
<span id="cb32-1933"><a href="#cb32-1933" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1934"><a href="#cb32-1934" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Embrace Model Evolution: Don't get too attached to your first model! As we saw in our DAG progression, models can (and should) change as we learn more. Starting simple is fine, but be ready to level up your model game when the data shows there's more to the story.</span>
<span id="cb32-1935"><a href="#cb32-1935" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1936"><a href="#cb32-1936" aria-hidden="true" tabindex="-1"></a><span class="fu"># Our causal discovery process in a nutshell</span></span>
<span id="cb32-1937"><a href="#cb32-1937" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1938"><a href="#cb32-1938" aria-hidden="true" tabindex="-1"></a>During the notebook, we have seen how we can use bayesian regression models to identify the causal structure of a dataset, and how we can use this information to make better decisions. We have also seen how we can use this information to make better decisions. In short, we start with a simple naive understanding of the world, which was evolved through the identification of the causal structure of the data, and the use of the causal graph to make better modelling decisions.</span>
<span id="cb32-1939"><a href="#cb32-1939" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1942"><a href="#cb32-1942" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-1943"><a href="#cb32-1943" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a figure with five subplots</span></span>
<span id="cb32-1944"><a href="#cb32-1944" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">5</span>,)</span>
<span id="cb32-1945"><a href="#cb32-1945" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1946"><a href="#cb32-1946" aria-hidden="true" tabindex="-1"></a><span class="co"># Set titles for each subplot</span></span>
<span id="cb32-1947"><a href="#cb32-1947" aria-hidden="true" tabindex="-1"></a>titles <span class="op">=</span> [<span class="st">"Naive DAG"</span>, <span class="st">"Updated DAG"</span>, <span class="st">"Updated DAG 1"</span>, <span class="st">"Discovered DAG"</span>, <span class="st">"True DAG"</span>]</span>
<span id="cb32-1948"><a href="#cb32-1948" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, title <span class="kw">in</span> <span class="bu">zip</span>(axes, titles):</span>
<span id="cb32-1949"><a href="#cb32-1949" aria-hidden="true" tabindex="-1"></a>    ax.set_title(title, fontsize<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb32-1950"><a href="#cb32-1950" aria-hidden="true" tabindex="-1"></a>    ax.axis(<span class="st">'off'</span>)</span>
<span id="cb32-1951"><a href="#cb32-1951" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1952"><a href="#cb32-1952" aria-hidden="true" tabindex="-1"></a><span class="co"># Render and plot each graph</span></span>
<span id="cb32-1953"><a href="#cb32-1953" aria-hidden="true" tabindex="-1"></a>naive_causal_mmm_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/naive_dag'</span>)</span>
<span id="cb32-1954"><a href="#cb32-1954" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].imshow(mpimg.imread(<span class="st">'images/naive_dag.png'</span>))</span>
<span id="cb32-1955"><a href="#cb32-1955" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1956"><a href="#cb32-1956" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/updated_dag'</span>)</span>
<span id="cb32-1957"><a href="#cb32-1957" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].imshow(mpimg.imread(<span class="st">'images/updated_dag.png'</span>))</span>
<span id="cb32-1958"><a href="#cb32-1958" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1959"><a href="#cb32-1959" aria-hidden="true" tabindex="-1"></a>updated_naive_causal_mmm_graph1.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/updated_dag1'</span>)</span>
<span id="cb32-1960"><a href="#cb32-1960" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].imshow(mpimg.imread(<span class="st">'images/updated_dag1.png'</span>))</span>
<span id="cb32-1961"><a href="#cb32-1961" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1962"><a href="#cb32-1962" aria-hidden="true" tabindex="-1"></a>real_dag_graph <span class="op">=</span> causal_model.to_graphviz(ges_graph)</span>
<span id="cb32-1963"><a href="#cb32-1963" aria-hidden="true" tabindex="-1"></a>real_dag_graph.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/discovered_dag'</span>)</span>
<span id="cb32-1964"><a href="#cb32-1964" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>].imshow(mpimg.imread(<span class="st">'images/discovered_dag.png'</span>))</span>
<span id="cb32-1965"><a href="#cb32-1965" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1966"><a href="#cb32-1966" aria-hidden="true" tabindex="-1"></a>new_real_dag.render(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>, filename<span class="op">=</span><span class="st">'images/true_dag'</span>)</span>
<span id="cb32-1967"><a href="#cb32-1967" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">4</span>].imshow(mpimg.imread(<span class="st">'images/true_dag.png'</span>))</span>
<span id="cb32-1968"><a href="#cb32-1968" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1969"><a href="#cb32-1969" aria-hidden="true" tabindex="-1"></a><span class="co"># Add main title</span></span>
<span id="cb32-1970"><a href="#cb32-1970" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">"Comparison of DAG Graphs"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb32-1971"><a href="#cb32-1971" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb32-1972"><a href="#cb32-1972" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1973"><a href="#cb32-1973" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1974"><a href="#cb32-1974" aria-hidden="true" tabindex="-1"></a>Last update:</span>
<span id="cb32-1977"><a href="#cb32-1977" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb32-1978"><a href="#cb32-1978" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load_ext watermark</span>
<span id="cb32-1979"><a href="#cb32-1979" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>watermark <span class="op">-</span>n <span class="op">-</span>u <span class="op">-</span>v <span class="op">-</span>iv <span class="op">-</span>w <span class="op">-</span>p pymc_marketing,pytensor</span>
<span id="cb32-1980"><a href="#cb32-1980" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 Connect with me:
  </li>  
</ul>
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 © 2023 Carlos Trujillo
  </li>  
</ul>
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/cetagostini/cetagostini.github.io/edit/main/articles/baby_steps_for_causal_discovery/baby_steps_for_causal_discovery.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/cetagostini/cetagostini.github.io/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/cetagostini">
      <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/cetagostini">
      <i class="bi bi-twitter" role="img" aria-label="Twitter">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://linkedin.com/in/cetagostini">
      <i class="bi bi-linkedin" role="img" aria-label="LinkedIn">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://instagram.com/cetagostini">
      <i class="bi bi-instagram" role="img" aria-label="Instagram">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="mailto:carlos.trujillo.agostini@gmail.com">
      <i class="bi bi-envelope" role="img" aria-label="Email">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>
<script src="../../js/cookie-consent.js"></script>




</body></html>